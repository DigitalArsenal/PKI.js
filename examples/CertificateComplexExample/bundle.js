(function () {
	'use strict';

	//**************************************************************************************
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Get value for input parameters, or set a default value
	 * @param {Object} parameters
	 * @param {string} name
	 * @param defaultValue
	 */
	function getParametersValue(parameters, name, defaultValue)
	{
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		if((parameters instanceof Object) === false)
			return defaultValue;
		
		// noinspection NonBlockStatementBodyJS
		if(name in parameters)
			return parameters[name];
		
		return defaultValue;
	}
	//**************************************************************************************
	/**
	 * Converts "ArrayBuffer" into a hexdecimal string
	 * @param {ArrayBuffer} inputBuffer
	 * @param {number} [inputOffset=0]
	 * @param {number} [inputLength=inputBuffer.byteLength]
	 * @param {boolean} [insertSpace=false]
	 * @returns {string}
	 */
	function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false)
	{
		let result = "";
		
		for(const item of (new Uint8Array(inputBuffer, inputOffset, inputLength)))
		{
			// noinspection ChainedFunctionCallJS
			const str = item.toString(16).toUpperCase();
			
			// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
			if(str.length === 1)
				result += "0";
			
			result += str;
			
			// noinspection NonBlockStatementBodyJS
			if(insertSpace)
				result += " ";
		}
		
		return result.trim();
	}
	//**************************************************************************************
	// noinspection JSValidateJSDoc, FunctionWithMultipleReturnPointsJS
	/**
	 * Check input "ArrayBuffer" for common functions
	 * @param {LocalBaseBlock} baseBlock
	 * @param {ArrayBuffer} inputBuffer
	 * @param {number} inputOffset
	 * @param {number} inputLength
	 * @returns {boolean}
	 */
	function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)
	{
		// noinspection ConstantOnRightSideOfComparisonJS
		if((inputBuffer instanceof ArrayBuffer) === false)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputBuffer.byteLength === 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputBuffer has zero length";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputOffset < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputOffset less than zero";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputLength < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputLength less than zero";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if((inputBuffer.byteLength - inputOffset - inputLength) < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
			return false;
		}
		
		return true;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Convert number from 2^base to 2^10
	 * @param {Uint8Array} inputBuffer
	 * @param {number} inputBase
	 * @returns {number}
	 */
	function utilFromBase(inputBuffer, inputBase)
	{
		let result = 0;
		
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		if(inputBuffer.length === 1)
			return inputBuffer[0];
		
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		for(let i = (inputBuffer.length - 1); i >= 0; i--)
			result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
		
		return result;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Convert number from 2^10 to 2^base
	 * @param {!number} value The number to convert
	 * @param {!number} base The base for 2^base
	 * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by function itself)
	 * @returns {ArrayBuffer}
	 */
	function utilToBase(value, base, reserved = (-1))
	{
		const internalReserved = reserved;
		let internalValue = value;
		
		let result = 0;
		let biggest = Math.pow(2, base);
		
		// noinspection ConstantOnRightSideOfComparisonJS
		for(let i = 1; i < 8; i++)
		{
			if(value < biggest)
			{
				let retBuf;
				
				// noinspection ConstantOnRightSideOfComparisonJS
				if(internalReserved < 0)
				{
					retBuf = new ArrayBuffer(i);
					result = i;
				}
				else
				{
					// noinspection NonBlockStatementBodyJS
					if(internalReserved < i)
						return (new ArrayBuffer(0));
					
					retBuf = new ArrayBuffer(internalReserved);
					
					result = internalReserved;
				}
				
				const retView = new Uint8Array(retBuf);
				
				// noinspection ConstantOnRightSideOfComparisonJS
				for(let j = (i - 1); j >= 0; j--)
				{
					const basis = Math.pow(2, j * base);
					
					retView[result - j - 1] = Math.floor(internalValue / basis);
					internalValue -= (retView[result - j - 1]) * basis;
				}
				
				return retBuf;
			}
			
			biggest *= Math.pow(2, base);
		}
		
		return new ArrayBuffer(0);
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Concatenate two ArrayBuffers
	 * @param {...ArrayBuffer} buffers Set of ArrayBuffer
	 */
	function utilConcatBuf(...buffers)
	{
		//region Initial variables
		let outputLength = 0;
		let prevLength = 0;
		//endregion
		
		//region Calculate output length
		
		// noinspection NonBlockStatementBodyJS
		for(const buffer of buffers)
			outputLength += buffer.byteLength;
		//endregion
		
		const retBuf = new ArrayBuffer(outputLength);
		const retView = new Uint8Array(retBuf);
		
		for(const buffer of buffers)
		{
			// noinspection NestedFunctionCallJS
			retView.set(new Uint8Array(buffer), prevLength);
			prevLength += buffer.byteLength;
		}
		
		return retBuf;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Concatenate two Uint8Array
	 * @param {...Uint8Array} views Set of Uint8Array
	 */
	function utilConcatView(...views)
	{
		//region Initial variables
		let outputLength = 0;
		let prevLength = 0;
		//endregion
		
		//region Calculate output length
		// noinspection NonBlockStatementBodyJS
		for(const view of views)
			outputLength += view.length;
		//endregion
		
		const retBuf = new ArrayBuffer(outputLength);
		const retView = new Uint8Array(retBuf);
		
		for(const view of views)
		{
			retView.set(view, prevLength);
			prevLength += view.length;
		}
		
		return retView;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Decoding of "two complement" values
	 * The function must be called in scope of instance of "hexBlock" class ("valueHex" and "warnings" properties must be present)
	 * @returns {number}
	 */
	function utilDecodeTC()
	{
		const buf = new Uint8Array(this.valueHex);
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(this.valueHex.byteLength >= 2)
		{
			//noinspection JSBitwiseOperatorUsage, ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
			// noinspection ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
			
			// noinspection NonBlockStatementBodyJS
			if(condition1 || condition2)
				this.warnings.push("Needlessly long format");
		}
		
		//region Create big part of the integer
		const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
		const bigIntView = new Uint8Array(bigIntBuffer);
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < this.valueHex.byteLength; i++)
			bigIntView[i] = 0;
		
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		bigIntView[0] = (buf[0] & 0x80); // mask only the biggest bit
		
		const bigInt = utilFromBase(bigIntView, 8);
		//endregion
		
		//region Create small part of the integer
		const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
		const smallIntView = new Uint8Array(smallIntBuffer);
		// noinspection NonBlockStatementBodyJS
		for(let j = 0; j < this.valueHex.byteLength; j++)
			smallIntView[j] = buf[j];
		
		// noinspection MagicNumberJS
		smallIntView[0] &= 0x7F; // mask biggest bit
		
		const smallInt = utilFromBase(smallIntView, 8);
		//endregion
		
		return (smallInt - bigInt);
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Encode integer value to "two complement" format
	 * @param {number} value Value to encode
	 * @returns {ArrayBuffer}
	 */
	function utilEncodeTC(value)
	{
		// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS
		const modValue = (value < 0) ? (value * (-1)) : value;
		let bigInt = 128;
		
		// noinspection ConstantOnRightSideOfComparisonJS
		for(let i = 1; i < 8; i++)
		{
			if(modValue <= bigInt)
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(value < 0)
				{
					const smallInt = bigInt - modValue;
					
					const retBuf = utilToBase(smallInt, 8, i);
					const retView = new Uint8Array(retBuf);
					
					// noinspection MagicNumberJS
					retView[0] |= 0x80;
					
					return retBuf;
				}
				
				let retBuf = utilToBase(modValue, 8, i);
				let retView = new Uint8Array(retBuf);
				
				//noinspection JSBitwiseOperatorUsage, MagicNumberJS, NonShortCircuitBooleanExpressionJS
				if(retView[0] & 0x80)
				{
					//noinspection JSCheckFunctionSignatures
					const tempBuf = retBuf.slice(0);
					const tempView = new Uint8Array(tempBuf);
					
					retBuf = new ArrayBuffer(retBuf.byteLength + 1);
					// noinspection ReuseOfLocalVariableJS
					retView = new Uint8Array(retBuf);
					
					// noinspection NonBlockStatementBodyJS
					for(let k = 0; k < tempBuf.byteLength; k++)
						retView[k + 1] = tempView[k];
					
					// noinspection MagicNumberJS
					retView[0] = 0x00;
				}
				
				return retBuf;
			}
			
			bigInt *= Math.pow(2, 8);
		}
		
		return (new ArrayBuffer(0));
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS, ParameterNamingConventionJS
	/**
	 * Compare two array buffers
	 * @param {!ArrayBuffer} inputBuffer1
	 * @param {!ArrayBuffer} inputBuffer2
	 * @returns {boolean}
	 */
	function isEqualBuffer(inputBuffer1, inputBuffer2)
	{
		// noinspection NonBlockStatementBodyJS
		if(inputBuffer1.byteLength !== inputBuffer2.byteLength)
			return false;
		
		// noinspection LocalVariableNamingConventionJS
		const view1 = new Uint8Array(inputBuffer1);
		// noinspection LocalVariableNamingConventionJS
		const view2 = new Uint8Array(inputBuffer2);
		
		for(let i = 0; i < view1.length; i++)
		{
			// noinspection NonBlockStatementBodyJS
			if(view1[i] !== view2[i])
				return false;
		}
		
		return true;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Pad input number with leade "0" if needed
	 * @returns {string}
	 * @param {number} inputNumber
	 * @param {number} fullLength
	 */
	function padNumber(inputNumber, fullLength)
	{
		const str = inputNumber.toString(10);
		
		// noinspection NonBlockStatementBodyJS
		if(fullLength < str.length)
			return "";
		
		const dif = fullLength - str.length;
		
		const padding = new Array(dif);
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < dif; i++)
			padding[i] = "0";
		
		const paddingString = padding.join("");
		
		return paddingString.concat(str);
	}
	//**************************************************************************************
	function stringToArrayBuffer(str)
	{
		const stringLength = str.length;
		
		const resultBuffer = new ArrayBuffer(stringLength);
		const resultView = new Uint8Array(resultBuffer);
		
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < stringLength; i++)
			resultView[i] = str.charCodeAt(i);
		
		return resultBuffer;
	}
	//**************************************************************************************

	/* eslint-disable indent */
	//**************************************************************************************
	//region Declaration of global variables
	//**************************************************************************************
	const powers2 = [new Uint8Array([1])];
	const digitsString = "0123456789";
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration for "LocalBaseBlock" class
	//**************************************************************************************
	/**
	 * Class used as a base block for all remaining ASN.1 classes
	 * @typedef LocalBaseBlock
	 * @interface
	 * @property {number} blockLength
	 * @property {string} error
	 * @property {Array.<string>} warnings
	 * @property {ArrayBuffer} valueBeforeDecode
	 */
	class LocalBaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBaseBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueBeforeDecode]
		 */
		constructor(parameters = {})
		{
			/**
			 * @type {number} blockLength
			 */
			this.blockLength = getParametersValue(parameters, "blockLength", 0);
			/**
			 * @type {string} error
			 */
			this.error = getParametersValue(parameters, "error", "");
			/**
			 * @type {Array.<string>} warnings
			 */
			this.warnings = getParametersValue(parameters, "warnings", []);
			//noinspection JSCheckFunctionSignatures
			/**
			 * @type {ArrayBuffer} valueBeforeDecode
			 */
			if("valueBeforeDecode" in parameters)
				this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);
			else
				this.valueBeforeDecode = new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "baseBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			return {
				blockName: this.constructor.blockName(),
				blockLength: this.blockLength,
				error: this.error,
				warnings: this.warnings,
				valueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Description for "LocalHexBlock" class
	//**************************************************************************************
	/**
	 * Class used as a base block for all remaining ASN.1 classes
	 * @extends LocalBaseBlock
	 * @typedef LocalHexBlock
	 * @property {number} blockLength
	 * @property {string} error
	 * @property {Array.<string>} warnings
	 * @property {ArrayBuffer} valueBeforeDecode
	 * @property {boolean} isHexOnly
	 * @property {ArrayBuffer} valueHex
	 */
	//noinspection JSUnusedLocalSymbols
	const LocalHexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass
	{
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Constructor for "LocalHexBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			/**
			 * @type {boolean}
			 */
			this.isHexOnly = getParametersValue(parameters, "isHexOnly", false);
			/**
			 * @type {ArrayBuffer}
			 */
			if("valueHex" in parameters)
				this.valueHex = parameters.valueHex.slice(0);
			else
				this.valueHex = new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "hexBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Copy input buffer to internal buffer
			this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);
			//endregion

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			if(this.isHexOnly !== true)
			{
				this.error = "Flag \"isHexOnly\" is not set, abort";
				return new ArrayBuffer(0);
			}

			if(sizeOnly === true)
				return new ArrayBuffer(this.valueHex.byteLength);

			//noinspection JSCheckFunctionSignatures
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.blockName = this.constructor.blockName();
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	};
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of identification block class
	//**************************************************************************************
	class LocalIdentificationBlock extends LocalHexBlock(LocalBaseBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBaseBlock" class
		 * @param {Object} [parameters={}]
		 * @property {Object} [idBlock]
		 */
		constructor(parameters = {})
		{
			super();

			if("idBlock" in parameters)
			{
				//region Properties from hexBlock class
				this.isHexOnly = getParametersValue(parameters.idBlock, "isHexOnly", false);
				this.valueHex = getParametersValue(parameters.idBlock, "valueHex", new ArrayBuffer(0));
				//endregion

				this.tagClass = getParametersValue(parameters.idBlock, "tagClass", (-1));
				this.tagNumber = getParametersValue(parameters.idBlock, "tagNumber", (-1));
				this.isConstructed = getParametersValue(parameters.idBlock, "isConstructed", false);
			}
			else
			{
				this.tagClass = (-1);
				this.tagNumber = (-1);
				this.isConstructed = false;
			}
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "identificationBlock";
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Initial variables
			let firstOctet = 0;
			let retBuf;
			let retView;
			//endregion

			switch(this.tagClass)
			{
				case 1:
					firstOctet |= 0x00; // UNIVERSAL
					break;
				case 2:
					firstOctet |= 0x40; // APPLICATION
					break;
				case 3:
					firstOctet |= 0x80; // CONTEXT-SPECIFIC
					break;
				case 4:
					firstOctet |= 0xC0; // PRIVATE
					break;
				default:
					this.error = "Unknown tag class";
					return (new ArrayBuffer(0));
			}

			if(this.isConstructed)
				firstOctet |= 0x20;

			if((this.tagNumber < 31) && (!this.isHexOnly))
			{
				retBuf = new ArrayBuffer(1);
				retView = new Uint8Array(retBuf);

				if(!sizeOnly)
				{
					let number = this.tagNumber;
					number &= 0x1F;
					firstOctet |= number;

					retView[0] = firstOctet;
				}

				return retBuf;
			}

			if(this.isHexOnly === false)
			{
				const encodedBuf = utilToBase(this.tagNumber, 7);
				const encodedView = new Uint8Array(encodedBuf);
				const size = encodedBuf.byteLength;

				retBuf = new ArrayBuffer(size + 1);
				retView = new Uint8Array(retBuf);
				retView[0] = (firstOctet | 0x1F);

				if(!sizeOnly)
				{
					for(let i = 0; i < (size - 1); i++)
						retView[i + 1] = encodedView[i] | 0x80;

					retView[size] = encodedView[size - 1];
				}

				return retBuf;
			}

			retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
			retView = new Uint8Array(retBuf);

			retView[0] = (firstOctet | 0x1F);

			if(sizeOnly === false)
			{
				const curView = new Uint8Array(this.valueHex);

				for(let i = 0; i < (curView.length - 1); i++)
					retView[i + 1] = curView[i] | 0x80;

				retView[this.valueHex.byteLength] = curView[curView.length - 1];
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.error = "Zero buffer length";
				return (-1);
			}
			//endregion

			//region Find tag class
			const tagClassMask = intBuffer[0] & 0xC0;

			switch(tagClassMask)
			{
				case 0x00:
					this.tagClass = (1); // UNIVERSAL
					break;
				case 0x40:
					this.tagClass = (2); // APPLICATION
					break;
				case 0x80:
					this.tagClass = (3); // CONTEXT-SPECIFIC
					break;
				case 0xC0:
					this.tagClass = (4); // PRIVATE
					break;
				default:
					this.error = "Unknown tag class";
					return (-1);
			}
			//endregion

			//region Find it's constructed or not
			this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
			//endregion

			//region Find tag number
			this.isHexOnly = false;

			const tagNumberMask = intBuffer[0] & 0x1F;

			//region Simple case (tag number < 31)
			if(tagNumberMask !== 0x1F)
			{
				this.tagNumber = (tagNumberMask);
				this.blockLength = 1;
			}
			//endregion
			//region Tag number bigger or equal to 31
			else
			{
				let count = 1;

				this.valueHex = new ArrayBuffer(255);
				let tagNumberBufferMaxLength = 255;
				let intTagNumberBuffer = new Uint8Array(this.valueHex);

				//noinspection JSBitwiseOperatorUsage
				while(intBuffer[count] & 0x80)
				{
					intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
					count++;

					if(count >= intBuffer.length)
					{
						this.error = "End of input reached before message was fully decoded";
						return (-1);
					}

					//region In case if tag number length is greater than 255 bytes (rare but possible case)
					if(count === tagNumberBufferMaxLength)
					{
						tagNumberBufferMaxLength += 255;

						const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);
						const tempBufferView = new Uint8Array(tempBuffer);

						for(let i = 0; i < intTagNumberBuffer.length; i++)
							tempBufferView[i] = intTagNumberBuffer[i];

						this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);
						intTagNumberBuffer = new Uint8Array(this.valueHex);
					}
					//endregion
				}

				this.blockLength = (count + 1);
				intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer

				//region Cut buffer
				const tempBuffer = new ArrayBuffer(count);
				const tempBufferView = new Uint8Array(tempBuffer);

				for(let i = 0; i < count; i++)
					tempBufferView[i] = intTagNumberBuffer[i];

				this.valueHex = new ArrayBuffer(count);
				intTagNumberBuffer = new Uint8Array(this.valueHex);
				intTagNumberBuffer.set(tempBufferView);
				//endregion

				//region Try to convert long tag number to short form
				if(this.blockLength <= 9)
					this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
				else
				{
					this.isHexOnly = true;
					this.warnings.push("Tag too long, represented as hex-coded");
				}
				//endregion
			}
			//endregion
			//endregion

			//region Check if constructed encoding was using for primitive type
			if(((this.tagClass === 1)) &&
				(this.isConstructed))
			{
				switch(this.tagNumber)
				{
					case 1:  // Boolean
					case 2:  // REAL
					case 5:  // Null
					case 6:  // OBJECT IDENTIFIER
					case 9:  // REAL
					case 14: // Time
					case 23:
					case 24:
					case 31:
					case 32:
					case 33:
					case 34:
						this.error = "Constructed encoding used for primitive type";
						return (-1);
					default:
				}
			}
			//endregion

			return (inputOffset + this.blockLength); // Return current offset in input buffer
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName: string,
		 *  tagClass: number,
		 *  tagNumber: number,
		 *  isConstructed: boolean,
		 *  isHexOnly: boolean,
		 *  valueHex: ArrayBuffer,
		 *  blockLength: number,
		 *  error: string, warnings: Array.<string>,
		 *  valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.blockName = this.constructor.blockName();
			object.tagClass = this.tagClass;
			object.tagNumber = this.tagNumber;
			object.isConstructed = this.isConstructed;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of length block class
	//**************************************************************************************
	class LocalLengthBlock extends LocalBaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalLengthBlock" class
		 * @param {Object} [parameters={}]
		 * @property {Object} [lenBlock]
		 */
		constructor(parameters = {})
		{
			super();

			if("lenBlock" in parameters)
			{
				this.isIndefiniteForm = getParametersValue(parameters.lenBlock, "isIndefiniteForm", false);
				this.longFormUsed = getParametersValue(parameters.lenBlock, "longFormUsed", false);
				this.length = getParametersValue(parameters.lenBlock, "length", 0);
			}
			else
			{
				this.isIndefiniteForm = false;
				this.longFormUsed = false;
				this.length = 0;
			}
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "lengthBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.error = "Zero buffer length";
				return (-1);
			}

			if(intBuffer[0] === 0xFF)
			{
				this.error = "Length block 0xFF is reserved by standard";
				return (-1);
			}
			//endregion

			//region Check for length form type
			this.isIndefiniteForm = intBuffer[0] === 0x80;
			//endregion

			//region Stop working in case of indefinite length form
			if(this.isIndefiniteForm === true)
			{
				this.blockLength = 1;
				return (inputOffset + this.blockLength);
			}
			//endregion

			//region Check is long form of length encoding using
			this.longFormUsed = !!(intBuffer[0] & 0x80);
			//endregion

			//region Stop working in case of short form of length value
			if(this.longFormUsed === false)
			{
				this.length = (intBuffer[0]);
				this.blockLength = 1;
				return (inputOffset + this.blockLength);
			}
			//endregion

			//region Calculate length value in case of long form
			const count = intBuffer[0] & 0x7F;

			if(count > 8) // Too big length value
			{
				this.error = "Too big integer";
				return (-1);
			}

			if((count + 1) > intBuffer.length)
			{
				this.error = "End of input reached before message was fully decoded";
				return (-1);
			}

			const lengthBufferView = new Uint8Array(count);

			for(let i = 0; i < count; i++)
				lengthBufferView[i] = intBuffer[i + 1];

			if(lengthBufferView[count - 1] === 0x00)
				this.warnings.push("Needlessly long encoded length");

			this.length = utilFromBase(lengthBufferView, 8);

			if(this.longFormUsed && (this.length <= 127))
				this.warnings.push("Unneccesary usage of long length form");

			this.blockLength = count + 1;
			//endregion

			return (inputOffset + this.blockLength); // Return current offset in input buffer
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Initial variables
			let retBuf;
			let retView;
			//endregion

			if(this.length > 127)
				this.longFormUsed = true;

			if(this.isIndefiniteForm)
			{
				retBuf = new ArrayBuffer(1);

				if(sizeOnly === false)
				{
					retView = new Uint8Array(retBuf);
					retView[0] = 0x80;
				}

				return retBuf;
			}

			if(this.longFormUsed === true)
			{
				const encodedBuf = utilToBase(this.length, 8);

				if(encodedBuf.byteLength > 127)
				{
					this.error = "Too big length";
					return (new ArrayBuffer(0));
				}

				retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);

				if(sizeOnly === true)
					return retBuf;

				const encodedView = new Uint8Array(encodedBuf);
				retView = new Uint8Array(retBuf);

				retView[0] = encodedBuf.byteLength | 0x80;

				for(let i = 0; i < encodedBuf.byteLength; i++)
					retView[i + 1] = encodedView[i];

				return retBuf;
			}

			retBuf = new ArrayBuffer(1);

			if(sizeOnly === false)
			{
				retView = new Uint8Array(retBuf);

				retView[0] = this.length;
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.blockName = this.constructor.blockName();
			object.isIndefiniteForm = this.isIndefiniteForm;
			object.longFormUsed = this.longFormUsed;
			object.length = this.length;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of value block class
	//**************************************************************************************
	class LocalValueBlock extends LocalBaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "valueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Throw an exception for a function which needs to be specified in extended classes
			throw TypeError("User need to make a specific function in a class which extends \"LocalValueBlock\"");
			//endregion
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Throw an exception for a function which needs to be specified in extended classes
			throw TypeError("User need to make a specific function in a class which extends \"LocalValueBlock\"");
			//endregion
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic ASN.1 block class
	//**************************************************************************************
	class BaseBlock extends LocalBaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "BaseBlock" class
		 * @param {Object} [parameters={}]
		 * @property {Object} [primitiveSchema]
		 * @property {string} [name]
		 * @property {boolean} [optional]
		 * @param valueBlockType Type of value block
		 */
		constructor(parameters = {}, valueBlockType = LocalValueBlock)
		{
			super(parameters);

			if("name" in parameters)
				this.name = parameters.name;
			if("optional" in parameters)
				this.optional = parameters.optional;
			if("primitiveSchema" in parameters)
				this.primitiveSchema = parameters.primitiveSchema;

			this.idBlock = new LocalIdentificationBlock(parameters);
			this.lenBlock = new LocalLengthBlock(parameters);
			this.valueBlock = new valueBlockType(parameters);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BaseBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			let retBuf;

			const idBlockBuf = this.idBlock.toBER(sizeOnly);
			const valueBlockSizeBuf = this.valueBlock.toBER(true);

			this.lenBlock.length = valueBlockSizeBuf.byteLength;
			const lenBlockBuf = this.lenBlock.toBER(sizeOnly);

			retBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);

			let valueBlockBuf;

			if(sizeOnly === false)
				valueBlockBuf = this.valueBlock.toBER(sizeOnly);
			else
				valueBlockBuf = new ArrayBuffer(this.lenBlock.length);

			retBuf = utilConcatBuf(retBuf, valueBlockBuf);

			if(this.lenBlock.isIndefiniteForm === true)
			{
				const indefBuf = new ArrayBuffer(2);

				if(sizeOnly === false)
				{
					const indefView = new Uint8Array(indefBuf);

					indefView[0] = 0x00;
					indefView[1] = 0x00;
				}

				retBuf = utilConcatBuf(retBuf, indefBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.idBlock = this.idBlock.toJSON();
			object.lenBlock = this.lenBlock.toJSON();
			object.valueBlock = this.valueBlock.toJSON();

			if("name" in this)
				object.name = this.name;
			if("optional" in this)
				object.optional = this.optional;
			if("primitiveSchema" in this)
				object.primitiveSchema = this.primitiveSchema.toJSON();

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic block for all PRIMITIVE types
	//**************************************************************************************
	class LocalPrimitiveValueBlock extends LocalValueBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalPrimitiveValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueBeforeDecode]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			//region Variables from "hexBlock" class
			if("valueHex" in parameters)
				this.valueHex = parameters.valueHex.slice(0);
			else
				this.valueHex = new ArrayBuffer(0);

			this.isHexOnly = getParametersValue(parameters, "isHexOnly", true);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Copy input buffer into internal buffer
			this.valueHex = new ArrayBuffer(intBuffer.length);
			const valueHexView = new Uint8Array(this.valueHex);

			for(let i = 0; i < intBuffer.length; i++)
				valueHexView[i] = intBuffer[i];
			//endregion

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "PrimitiveValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
			object.isHexOnly = this.isHexOnly;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Primitive extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "Primitive" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalPrimitiveValueBlock);

			this.idBlock.isConstructed = false;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "PRIMITIVE";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic block for all CONSTRUCTED types
	//**************************************************************************************
	class LocalConstructedValueBlock extends LocalValueBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalConstructedValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.value = getParametersValue(parameters, "value", []);
			this.isIndefiniteForm = getParametersValue(parameters, "isIndefiniteForm", false);
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Store initial offset and length
			const initialOffset = inputOffset;
			const initialLength = inputLength;
			//endregion

			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Aux function
			function checkLen(indefiniteLength, length)
			{
				if(indefiniteLength === true)
					return 1;

				return length;
			}
			//endregion

			let currentOffset = inputOffset;

			while(checkLen(this.isIndefiniteForm, inputLength) > 0)
			{
				const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);
				if(returnObject.offset === (-1))
				{
					this.error = returnObject.result.error;
					this.warnings.concat(returnObject.result.warnings);
					return (-1);
				}

				currentOffset = returnObject.offset;

				this.blockLength += returnObject.result.blockLength;
				inputLength -= returnObject.result.blockLength;

				this.value.push(returnObject.result);

				if((this.isIndefiniteForm === true) && (returnObject.result.constructor.blockName() === EndOfContent.blockName()))
					break;
			}

			if(this.isIndefiniteForm === true)
			{
				if(this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName())
					this.value.pop();
				else
					this.warnings.push("No EndOfContent block encoded");
			}

			//region Copy "inputBuffer" to "valueBeforeDecode"
			this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);
			//endregion

			return currentOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			let retBuf = new ArrayBuffer(0);

			for(let i = 0; i < this.value.length; i++)
			{
				const valueBuf = this.value[i].toBER(sizeOnly);
				retBuf = utilConcatBuf(retBuf, valueBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "ConstructedValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.isIndefiniteForm = this.isIndefiniteForm;
			object.value = [];
			for(let i = 0; i < this.value.length; i++)
				object.value.push(this.value[i].toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Constructed extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "Constructed" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalConstructedValueBlock);

			this.idBlock.isConstructed = true;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "CONSTRUCTED";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 EndOfContent type class
	//**************************************************************************************
	class LocalEndOfContentValueBlock extends LocalValueBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalEndOfContentValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region There is no "value block" for EndOfContent type and we need to return the same offset
			return inputOffset;
			//endregion
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			return new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "EndOfContentValueBlock";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class EndOfContent extends BaseBlock
	{
		//**********************************************************************************
		constructor(paramaters = {})
		{
			super(paramaters, LocalEndOfContentValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 0; // EndOfContent
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "EndOfContent";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Boolean type class
	//**************************************************************************************
	class LocalBooleanValueBlock extends LocalValueBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBooleanValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);
			
			this.value = getParametersValue(parameters, "value", false);
			this.isHexOnly = getParametersValue(parameters, "isHexOnly", false);
			
			if("valueHex" in parameters)
				this.valueHex = parameters.valueHex.slice(0);
			else
			{
				this.valueHex = new ArrayBuffer(1);
				if(this.value === true)
				{
					const view = new Uint8Array(this.valueHex);
					view[0] = 0xFF;
				}
			}
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			if(inputLength > 1)
				this.warnings.push("Boolean value encoded in more then 1 octet");

			this.isHexOnly = true;

			//region Copy input buffer to internal array
			this.valueHex = new ArrayBuffer(intBuffer.length);
			const view = new Uint8Array(this.valueHex);

			for(let i = 0; i < intBuffer.length; i++)
				view[i] = intBuffer[i];
			//endregion
			
			if(utilDecodeTC.call(this) !== 0 )
				this.value = true;
			else
				this.value = false;

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			return this.valueHex;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BooleanValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Boolean extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "Boolean" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBooleanValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 1; // Boolean
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Boolean";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Sequence and Set type classes
	//**************************************************************************************
	class Sequence extends Constructed
	{
		//**********************************************************************************
		/**
		 * Constructor for "Sequence" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 16; // Sequence
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Sequence";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Set extends Constructed
	{
		//**********************************************************************************
		/**
		 * Constructor for "Set" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 17; // Set
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Set";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Null type class
	//**************************************************************************************
	class Null extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "Null" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBaseBlock); // We will not have a call to "Null value block" because of specified "fromBER" and "toBER" functions

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 5; // Null
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Null";
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			if(this.lenBlock.length > 0)
				this.warnings.push("Non-zero length of value block for Null type");

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;
			
			this.blockLength += inputLength;
			
			if((inputOffset + inputLength) > inputBuffer.byteLength)
			{
				this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
				return (-1);
			}
			
			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			const retBuf = new ArrayBuffer(2);

			if(sizeOnly === true)
				return retBuf;

			const retView = new Uint8Array(retBuf);
			retView[0] = 0x05;
			retView[1] = 0x00;

			return retBuf;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 OctetString type class
	//**************************************************************************************
	class LocalOctetStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalOctetStringValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isConstructed = getParametersValue(parameters, "isConstructed", false);
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			let resultOffset = 0;

			if(this.isConstructed === true)
			{
				this.isHexOnly = false;

				resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
				if(resultOffset === (-1))
					return resultOffset;

				for(let i = 0; i < this.value.length; i++)
				{
					const currentBlockName = this.value[i].constructor.blockName();

					if(currentBlockName === EndOfContent.blockName())
					{
						if(this.isIndefiniteForm === true)
							break;
						else
						{
							this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
							return (-1);
						}
					}

					if(currentBlockName !== OctetString.blockName())
					{
						this.error = "OCTET STRING may consists of OCTET STRINGs only";
						return (-1);
					}
				}
			}
			else
			{
				this.isHexOnly = true;

				resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
				this.blockLength = inputLength;
			}

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			if(this.isConstructed === true)
				return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);

			let retBuf = new ArrayBuffer(this.valueHex.byteLength);

			if(sizeOnly === true)
				return retBuf;

			if(this.valueHex.byteLength === 0)
				return retBuf;

			retBuf = this.valueHex.slice(0);

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "OctetStringValueBlock";
		}
		//**********************************************************************************
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.isConstructed = this.isConstructed;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class OctetString extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "OctetString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalOctetStringValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 4; // OctetString
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			this.valueBlock.isConstructed = this.idBlock.isConstructed;
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			//region Ability to encode empty OCTET STRING
			if(inputLength === 0)
			{
				if(this.idBlock.error.length === 0)
					this.blockLength += this.idBlock.blockLength;

				if(this.lenBlock.error.length === 0)
					this.blockLength += this.lenBlock.blockLength;

				return inputOffset;
			}
			//endregion

			return super.fromBER(inputBuffer, inputOffset, inputLength);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "OctetString";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Checking that two OCTETSTRINGs are equal
		 * @param {OctetString} octetString
		 */
		isEqual(octetString)
		{
			//region Check input type
			if((octetString instanceof OctetString) === false)
				return false;
			//endregion

			//region Compare two JSON strings
			if(JSON.stringify(this) !== JSON.stringify(octetString))
				return false;
			//endregion

			return true;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 BitString type class
	//**************************************************************************************
	class LocalBitStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBitStringValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.unusedBits = getParametersValue(parameters, "unusedBits", 0);
			this.isConstructed = getParametersValue(parameters, "isConstructed", false);
			this.blockLength = this.valueHex.byteLength;
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Ability to decode zero-length BitString value
			if(inputLength === 0)
				return inputOffset;
			//endregion

			let resultOffset = (-1);

			//region If the BISTRING supposed to be a constructed value
			if(this.isConstructed === true)
			{
				resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
				if(resultOffset === (-1))
					return resultOffset;

				for(let i = 0; i < this.value.length; i++)
				{
					const currentBlockName = this.value[i].constructor.blockName();

					if(currentBlockName === EndOfContent.blockName())
					{
						if(this.isIndefiniteForm === true)
							break;
						else
						{
							this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
							return (-1);
						}
					}

					if(currentBlockName !== BitString.blockName())
					{
						this.error = "BIT STRING may consists of BIT STRINGs only";
						return (-1);
					}

					if((this.unusedBits > 0) && (this.value[i].valueBlock.unusedBits > 0))
					{
						this.error = "Usign of \"unused bits\" inside constructive BIT STRING allowed for least one only";
						return (-1);
					}

					this.unusedBits = this.value[i].valueBlock.unusedBits;
					if(this.unusedBits > 7)
					{
						this.error = "Unused bits for BitString must be in range 0-7";
						return (-1);
					}
				}

				return resultOffset;
			}
			//endregion
			//region If the BitString supposed to be a primitive value
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

			this.unusedBits = intBuffer[0];
			
			if(this.unusedBits > 7)
			{
				this.error = "Unused bits for BitString must be in range 0-7";
				return (-1);
			}

			//region Copy input buffer to internal buffer
			this.valueHex = new ArrayBuffer(intBuffer.length - 1);
			const view = new Uint8Array(this.valueHex);
			for(let i = 0; i < (inputLength - 1); i++)
				view[i] = intBuffer[i + 1];
			//endregion

			this.blockLength = intBuffer.length;

			return (inputOffset + inputLength);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			if(this.isConstructed === true)
				return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);

			if(sizeOnly === true)
				return (new ArrayBuffer(this.valueHex.byteLength + 1));

			if(this.valueHex.byteLength === 0)
				return (new ArrayBuffer(0));

			const curView = new Uint8Array(this.valueHex);

			const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
			const retView = new Uint8Array(retBuf);

			retView[0] = this.unusedBits;

			for(let i = 0; i < this.valueHex.byteLength; i++)
				retView[i + 1] = curView[i];

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BitStringValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.unusedBits = this.unusedBits;
			object.isConstructed = this.isConstructed;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class BitString extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "BitString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBitStringValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 3; // BitString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BitString";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Ability to encode empty BitString
			if(inputLength === 0)
				return inputOffset;
			//endregion

			this.valueBlock.isConstructed = this.idBlock.isConstructed;
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			return super.fromBER(inputBuffer, inputOffset, inputLength);
		}
		//**********************************************************************************
		/**
		 * Checking that two BITSTRINGs are equal
		 * @param {BitString} bitString
		 */
		isEqual(bitString)
		{
			//region Check input type
			if((bitString instanceof BitString) === false)
				return false;
			//endregion

			//region Compare two JSON strings
			if(JSON.stringify(this) !== JSON.stringify(bitString))
				return false;
			//endregion

			return true;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Integer type class
	//**************************************************************************************
	/**
	 * @extends LocalValueBlock
	 */
	class LocalIntegerValueBlock extends LocalHexBlock(LocalValueBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalIntegerValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			if("value" in parameters)
				this.valueDec = parameters.value;
		}
		//**********************************************************************************
		/**
		 * Setter for "valueHex"
		 * @param {ArrayBuffer} _value
		 */
		set valueHex(_value)
		{
			this._valueHex = _value.slice(0);

			if(_value.byteLength >= 4)
			{
				this.warnings.push("Too big Integer for decoding, hex only");
				this.isHexOnly = true;
				this._valueDec = 0;
			}
			else
			{
				this.isHexOnly = false;

				if(_value.byteLength > 0)
					this._valueDec = utilDecodeTC.call(this);
			}
		}
		//**********************************************************************************
		/**
		 * Getter for "valueHex"
		 * @returns {ArrayBuffer}
		 */
		get valueHex()
		{
			return this._valueHex;
		}
		//**********************************************************************************
		/**
		 * Getter for "valueDec"
		 * @param {number} _value
		 */
		set valueDec(_value)
		{
			this._valueDec = _value;

			this.isHexOnly = false;
			this._valueHex = utilEncodeTC(_value);
		}
		//**********************************************************************************
		/**
		 * Getter for "valueDec"
		 * @returns {number}
		 */
		get valueDec()
		{
			return this._valueDec;
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from DER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @param {number} [expectedLength=0] Expected length of converted "valueHex" buffer
		 * @returns {number} Offset after least decoded byte
		 */
		fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0)
		{
			const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
			if(offset === (-1))
				return offset;

			const view = new Uint8Array(this._valueHex);

			if((view[0] === 0x00) && ((view[1] & 0x80) !== 0))
			{
				const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
				const updatedView = new Uint8Array(updatedValueHex);

				updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

				this._valueHex = updatedValueHex.slice(0);
			}
			else
			{
				if(expectedLength !== 0)
				{
					if(this._valueHex.byteLength < expectedLength)
					{
						if((expectedLength - this._valueHex.byteLength) > 1)
							expectedLength = this._valueHex.byteLength + 1;
						
						const updatedValueHex = new ArrayBuffer(expectedLength);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView.set(view, expectedLength - this._valueHex.byteLength);

						this._valueHex = updatedValueHex.slice(0);
					}
				}
			}

			return offset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toDER(sizeOnly = false)
		{
			const view = new Uint8Array(this._valueHex);

			switch(true)
			{
				case ((view[0] & 0x80) !== 0):
					{
						const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView[0] = 0x00;
						updatedView.set(view, 1);

						this._valueHex = updatedValueHex.slice(0);
					}
					break;
				case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):
					{
						const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

						this._valueHex = updatedValueHex.slice(0);
					}
					break;
				default:
			}

			return this.toBER(sizeOnly);
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
			if(resultOffset === (-1))
				return resultOffset;

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//noinspection JSCheckFunctionSignatures
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "IntegerValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.valueDec = this.valueDec;

			return object;
		}
		//**********************************************************************************
		/**
		 * Convert current value to decimal string representation
		 */
		toString()
		{
			//region Aux functions
			function viewAdd(first, second)
			{
				//region Initial variables
				const c = new Uint8Array([0]);
				
				let firstView = new Uint8Array(first);
				let secondView = new Uint8Array(second);
				
				let firstViewCopy = firstView.slice(0);
				const firstViewCopyLength = firstViewCopy.length - 1;
				let secondViewCopy = secondView.slice(0);
				const secondViewCopyLength = secondViewCopy.length - 1;
				
				let value = 0;
				
				const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;
				
				let counter = 0;
				//endregion
				
				for(let i = max; i >= 0; i--, counter++)
				{
					switch(true)
					{
						case (counter < secondViewCopy.length):
							value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
							break;
						default:
							value = firstViewCopy[firstViewCopyLength - counter] + c[0];
					}
					
					c[0] = value / 10;
					
					switch(true)
					{
						case (counter >= firstViewCopy.length):
							firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
							break;
						default:
							firstViewCopy[firstViewCopyLength - counter] = value % 10;
					}
				}
				
				if(c[0] > 0)
					firstViewCopy = utilConcatView(c, firstViewCopy);
				
				return firstViewCopy.slice(0);
			}
			
			function power2(n)
			{
				if(n >= powers2.length)
				{
					for(let p = powers2.length; p <= n; p++)
					{
						const c = new Uint8Array([0]);
						let digits = (powers2[p - 1]).slice(0);
						
						for(let i = (digits.length - 1); i >=0; i--)
						{
							const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
							c[0] = newValue[0] / 10;
							digits[i] = newValue[0] % 10;
						}
						
						if (c[0] > 0)
							digits = utilConcatView(c, digits);
						
						powers2.push(digits);
					}
				}
				
				return powers2[n];
			}
			
			function viewSub(first, second)
			{
				//region Initial variables
				let b = 0;
				
				let firstView = new Uint8Array(first);
				let secondView = new Uint8Array(second);
				
				let firstViewCopy = firstView.slice(0);
				const firstViewCopyLength = firstViewCopy.length - 1;
				let secondViewCopy = secondView.slice(0);
				const secondViewCopyLength = secondViewCopy.length - 1;
				
				let value;
				
				let counter = 0;
				//endregion
				
				for(let i = secondViewCopyLength; i >= 0; i--, counter++)
				{
					value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
					
					switch(true)
					{
						case (value < 0):
							b = 1;
							firstViewCopy[firstViewCopyLength - counter] = value + 10;
							break;
						default:
							b = 0;
							firstViewCopy[firstViewCopyLength - counter] = value;
					}
				}
				
				if(b > 0)
				{
					for(let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++)
					{
						value = firstViewCopy[firstViewCopyLength - counter] - b;
						
						if(value < 0)
						{
							b = 1;
							firstViewCopy[firstViewCopyLength - counter] = value + 10;
						}
						else
						{
							b = 0;
							firstViewCopy[firstViewCopyLength - counter] = value;
							break;
						}
					}
				}
				
				return firstViewCopy.slice();
			}
			//endregion
			
			//region Initial variables
			const firstBit = (this._valueHex.byteLength * 8) - 1;
			
			let digits = new Uint8Array((this._valueHex.byteLength * 8) / 3);
			let bitNumber = 0;
			let currentByte;
			
			const asn1View = new Uint8Array(this._valueHex);
			
			let result = "";
			
			let flag = false;
			//endregion
			
			//region Calculate number
			for(let byteNumber = (this._valueHex.byteLength - 1); byteNumber >= 0; byteNumber--)
			{
				currentByte = asn1View[byteNumber];
				
				for(let i = 0; i < 8; i++)
				{
					if((currentByte & 1) === 1)
					{
						switch(bitNumber)
						{
							case firstBit:
								digits = viewSub(power2(bitNumber), digits);
								result = "-";
								break;
							default:
								digits = viewAdd(digits, power2(bitNumber));
						}
					}
					
					bitNumber++;
					currentByte >>= 1;
				}
			}
			//endregion
			
			//region Print number
			for(let i = 0; i < digits.length; i++)
			{
				if(digits[i])
					flag = true;
				
				if(flag)
					result += digitsString.charAt(digits[i]);
			}
			
			if(flag === false)
				result += digitsString.charAt(0);
			//endregion
			
			return result;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Integer extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "Integer" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalIntegerValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 2; // Integer
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Integer";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Compare two Integer object, or Integer and ArrayBuffer objects
		 * @param {!Integer|ArrayBuffer} otherValue
		 * @returns {boolean}
		 */
		isEqual(otherValue)
		{
			if(otherValue instanceof Integer)
			{
				if(this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers
					return isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);

				if(this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly)
					return (this.valueBlock.valueDec === otherValue.valueBlock.valueDec);

				return false;
			}
			
			if(otherValue instanceof ArrayBuffer)
				return isEqualBuffer(this.valueBlock.valueHex, otherValue);

			return false;
		}
		//**********************************************************************************
		/**
		 * Convert current Integer value from BER into DER format
		 * @returns {Integer}
		 */
		convertToDER()
		{
			const integer = new Integer({ valueHex: this.valueBlock.valueHex });
			integer.valueBlock.toDER();

			return integer;
		}
		//**********************************************************************************
		/**
		 * Convert current Integer value from DER to BER format
		 * @returns {Integer}
		 */
		convertFromDER()
		{
			const expectedLength = (this.valueBlock.valueHex.byteLength % 2) ? (this.valueBlock.valueHex.byteLength + 1) : this.valueBlock.valueHex.byteLength;
			const integer = new Integer({ valueHex: this.valueBlock.valueHex });
			integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);
			
			return integer;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Enumerated type class
	//**************************************************************************************
	class Enumerated extends Integer
	{
		//**********************************************************************************
		/**
		 * Constructor for "Enumerated" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 10; // Enumerated
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Enumerated";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 ObjectIdentifier type class
	//**************************************************************************************
	class LocalSidValueBlock extends LocalHexBlock(LocalBaseBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalSidValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {number} [valueDec]
		 * @property {boolean} [isFirstSid]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.valueDec = getParametersValue(parameters, "valueDec", -1);
			this.isFirstSid = getParametersValue(parameters, "isFirstSid", false);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "sidBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			if(inputLength === 0)
				return inputOffset;

			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

			this.valueHex = new ArrayBuffer(inputLength);
			let view = new Uint8Array(this.valueHex);

			for(let i = 0; i < inputLength; i++)
			{
				view[i] = intBuffer[i] & 0x7F;

				this.blockLength++;

				if((intBuffer[i] & 0x80) === 0x00)
					break;
			}

			//region Ajust size of valueHex buffer
			const tempValueHex = new ArrayBuffer(this.blockLength);
			const tempView = new Uint8Array(tempValueHex);

			for(let i = 0; i < this.blockLength; i++)
				tempView[i] = view[i];

			//noinspection JSCheckFunctionSignatures
			this.valueHex = tempValueHex.slice(0);
			view = new Uint8Array(this.valueHex);
			//endregion

			if((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)
			{
				this.error = "End of input reached before message was fully decoded";
				return (-1);
			}

			if(view[0] === 0x00)
				this.warnings.push("Needlessly long format of SID encoding");

			if(this.blockLength <= 8)
				this.valueDec = utilFromBase(view, 7);
			else
			{
				this.isHexOnly = true;
				this.warnings.push("Too big SID for decoding, hex only");
			}

			return (inputOffset + this.blockLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Initial variables
			let retBuf;
			let retView;
			//endregion

			if(this.isHexOnly)
			{
				if(sizeOnly === true)
					return (new ArrayBuffer(this.valueHex.byteLength));

				const curView = new Uint8Array(this.valueHex);

				retBuf = new ArrayBuffer(this.blockLength);
				retView = new Uint8Array(retBuf);

				for(let i = 0; i < (this.blockLength - 1); i++)
					retView[i] = curView[i] | 0x80;

				retView[this.blockLength - 1] = curView[this.blockLength - 1];

				return retBuf;
			}

			const encodedBuf = utilToBase(this.valueDec, 7);
			if(encodedBuf.byteLength === 0)
			{
				this.error = "Error during encoding SID value";
				return (new ArrayBuffer(0));
			}

			retBuf = new ArrayBuffer(encodedBuf.byteLength);

			if(sizeOnly === false)
			{
				const encodedView = new Uint8Array(encodedBuf);
				retView = new Uint8Array(retBuf);

				for(let i = 0; i < (encodedBuf.byteLength - 1); i++)
					retView[i] = encodedView[i] | 0x80;

				retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Create string representation of current SID block
		 * @returns {string}
		 */
		toString()
		{
			let result = "";

			if(this.isHexOnly === true)
				result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
			else
			{
				if(this.isFirstSid)
				{
					let sidValue = this.valueDec;

					if(this.valueDec <= 39)
						result = "0.";
					else
					{
						if(this.valueDec <= 79)
						{
							result = "1.";
							sidValue -= 40;
						}
						else
						{
							result = "2.";
							sidValue -= 80;
						}
					}

					result += sidValue.toString();
				}
				else
					result = this.valueDec.toString();
			}

			return result;
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.valueDec = this.valueDec;
			object.isFirstSid = this.isFirstSid;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class LocalObjectIdentifierValueBlock extends LocalValueBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalObjectIdentifierValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.fromString(getParametersValue(parameters, "value", ""));
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			let resultOffset = inputOffset;

			while(inputLength > 0)
			{
				const sidBlock = new LocalSidValueBlock();
				resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
				if(resultOffset === (-1))
				{
					this.blockLength = 0;
					this.error = sidBlock.error;
					return resultOffset;
				}

				if(this.value.length === 0)
					sidBlock.isFirstSid = true;

				this.blockLength += sidBlock.blockLength;
				inputLength -= sidBlock.blockLength;

				this.value.push(sidBlock);
			}

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			let retBuf = new ArrayBuffer(0);

			for(let i = 0; i < this.value.length; i++)
			{
				const valueBuf = this.value[i].toBER(sizeOnly);
				if(valueBuf.byteLength === 0)
				{
					this.error = this.value[i].error;
					return (new ArrayBuffer(0));
				}

				retBuf = utilConcatBuf(retBuf, valueBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Create "LocalObjectIdentifierValueBlock" class from string
		 * @param {string} string Input string to convert from
		 * @returns {boolean}
		 */
		fromString(string)
		{
			this.value = []; // Clear existing SID values

			let pos1 = 0;
			let pos2 = 0;

			let sid = "";

			let flag = false;

			do
			{
				pos2 = string.indexOf(".", pos1);
				if(pos2 === (-1))
					sid = string.substr(pos1);
				else
					sid = string.substr(pos1, pos2 - pos1);

				pos1 = pos2 + 1;

				if(flag)
				{
					const sidBlock = this.value[0];

					let plus = 0;

					switch(sidBlock.valueDec)
					{
						case 0:
							break;
						case 1:
							plus = 40;
							break;
						case 2:
							plus = 80;
							break;
						default:
							this.value = []; // clear SID array
							return false; // ???
					}

					const parsedSID = parseInt(sid, 10);
					if(isNaN(parsedSID))
						return true;

					sidBlock.valueDec = parsedSID + plus;

					flag = false;
				}
				else
				{
					const sidBlock = new LocalSidValueBlock();
					sidBlock.valueDec = parseInt(sid, 10);
					if(isNaN(sidBlock.valueDec))
						return true;

					if(this.value.length === 0)
					{
						sidBlock.isFirstSid = true;
						flag = true;
					}

					this.value.push(sidBlock);
				}
			} while(pos2 !== (-1));

			return true;
		}
		//**********************************************************************************
		/**
		 * Converts "LocalObjectIdentifierValueBlock" class to string
		 * @returns {string}
		 */
		toString()
		{
			let result = "";
			let isHexOnly = false;

			for(let i = 0; i < this.value.length; i++)
			{
				isHexOnly = this.value[i].isHexOnly;

				let sidStr = this.value[i].toString();

				if(i !== 0)
					result = `${result}.`;

				if(isHexOnly)
				{
					sidStr = `{${sidStr}}`;

					if(this.value[i].isFirstSid)
						result = `2.{${sidStr} - 80}`;
					else
						result += sidStr;
				}
				else
					result += sidStr;
			}

			return result;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "ObjectIdentifierValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.toString();
			object.sidArray = [];
			for(let i = 0; i < this.value.length; i++)
				object.sidArray.push(this.value[i].toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class ObjectIdentifier extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "ObjectIdentifier" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalObjectIdentifierValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "ObjectIdentifier";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of all string's classes
	//**************************************************************************************
	class LocalUtf8StringValueBlock extends LocalHexBlock(LocalBaseBlock)
	{
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Constructor for "LocalUtf8StringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isHexOnly = true;
			this.value = ""; // String representation of decoded ArrayBuffer
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Utf8StringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class Utf8String extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "Utf8String" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalUtf8StringValueBlock);

			if("value" in parameters)
				this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 12; // Utf8String
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Utf8String";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));

			try
			{
				//noinspection JSDeprecatedSymbols
				this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));
			}
			catch(ex)
			{
				this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
			}
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			//noinspection JSDeprecatedSymbols
			const str = unescape(encodeURIComponent(inputString));
			const strLen = str.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLen);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLen; i++)
				view[i] = str.charCodeAt(i);

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalBaseBlock
	 * @extends LocalHexBlock
	 */
	class LocalBmpStringValueBlock extends LocalHexBlock(LocalBaseBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBmpStringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isHexOnly = true;
			this.value = "";
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BmpStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class BmpString extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "BmpString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBmpStringValueBlock);

			if("value" in parameters)
				this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 30; // BmpString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BmpString";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			//noinspection JSCheckFunctionSignatures
			const copyBuffer = inputBuffer.slice(0);
			const valueView = new Uint8Array(copyBuffer);

			for(let i = 0; i < valueView.length; i += 2)
			{
				const temp = valueView[i];

				valueView[i] = valueView[i + 1];
				valueView[i + 1] = temp;
			}

			this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			const strLength = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);
			const valueHexView = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLength; i++)
			{
				const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
				const codeView = new Uint8Array(codeBuf);
				if(codeView.length > 2)
					continue;

				const dif = 2 - codeView.length;

				for(let j = (codeView.length - 1); j >= 0; j--)
					valueHexView[i * 2 + j + dif] = codeView[j];
			}

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class LocalUniversalStringValueBlock extends LocalHexBlock(LocalBaseBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalUniversalStringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isHexOnly = true;
			this.value = "";
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "UniversalStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class UniversalString extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "UniversalString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalUniversalStringValueBlock);

			if("value" in parameters)
				this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 28; // UniversalString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "UniversalString";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			//noinspection JSCheckFunctionSignatures
			const copyBuffer = inputBuffer.slice(0);
			const valueView = new Uint8Array(copyBuffer);

			for(let i = 0; i < valueView.length; i += 4)
			{
				valueView[i] = valueView[i + 3];
				valueView[i + 1] = valueView[i + 2];
				valueView[i + 2] = 0x00;
				valueView[i + 3] = 0x00;
			}

			this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			const strLength = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);
			const valueHexView = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLength; i++)
			{
				const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
				const codeView = new Uint8Array(codeBuf);
				if(codeView.length > 4)
					continue;

				const dif = 4 - codeView.length;

				for(let j = (codeView.length - 1); j >= 0; j--)
					valueHexView[i * 4 + j + dif] = codeView[j];
			}

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class LocalSimpleStringValueBlock extends LocalHexBlock(LocalBaseBlock)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalSimpleStringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.value = "";
			this.isHexOnly = true;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "SimpleStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class LocalSimpleStringBlock extends BaseBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalSimpleStringBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalSimpleStringValueBlock);

			if("value" in parameters)
				this.fromString(parameters.value);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "SIMPLESTRING";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			const strLen = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLen);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLen; i++)
				view[i] = inputString.charCodeAt(i);

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class NumericString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "NumericString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 18; // NumericString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "NumericString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class PrintableString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "PrintableString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 19; // PrintableString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "PrintableString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class TeletexString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "TeletexString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 20; // TeletexString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "TeletexString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class VideotexString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "VideotexString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 21; // VideotexString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "VideotexString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class IA5String extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "IA5String" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 22; // IA5String
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "IA5String";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class GraphicString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "GraphicString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 25; // GraphicString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "GraphicString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class VisibleString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "VisibleString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 26; // VisibleString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "VisibleString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class GeneralString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "GeneralString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 27; // GeneralString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "GeneralString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class CharacterString extends LocalSimpleStringBlock
	{
		//**********************************************************************************
		/**
		 * Constructor for "CharacterString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 29; // CharacterString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "CharacterString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of all date and time classes
	//**************************************************************************************
	/**
	 * @extends VisibleString
	 */
	class UTCTime extends VisibleString
	{
		//**********************************************************************************
		/**
		 * Constructor for "UTCTime" class
		 * @param {Object} [parameters={}]
		 * @property {string} [value] String representatio of the date
		 * @property {Date} [valueDate] JavaScript "Date" object
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.year = 0;
			this.month = 0;
			this.day = 0;
			this.hour = 0;
			this.minute = 0;
			this.second = 0;

			//region Create UTCTime from ASN.1 UTC string value
			if("value" in parameters)
			{
				this.fromString(parameters.value);

				this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
				const view = new Uint8Array(this.valueBlock.valueHex);

				for(let i = 0; i < parameters.value.length; i++)
					view[i] = parameters.value.charCodeAt(i);
			}
			//endregion
			//region Create GeneralizedTime from JavaScript Date type
			if("valueDate" in parameters)
			{
				this.fromDate(parameters.valueDate);
				this.valueBlock.valueHex = this.toBuffer();
			}
			//endregion

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 23; // UTCTime
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal string into ArrayBuffer
		 * @returns {ArrayBuffer}
		 */
		toBuffer()
		{
			const str = this.toString();

			const buffer = new ArrayBuffer(str.length);
			const view = new Uint8Array(buffer);

			for(let i = 0; i < str.length; i++)
				view[i] = str.charCodeAt(i);

			return buffer;
		}
		//**********************************************************************************
		/**
		 * Function converting "Date" object into ASN.1 internal string
		 * @param {!Date} inputDate JavaScript "Date" object
		 */
		fromDate(inputDate)
		{
			this.year = inputDate.getUTCFullYear();
			this.month = inputDate.getUTCMonth() + 1;
			this.day = inputDate.getUTCDate();
			this.hour = inputDate.getUTCHours();
			this.minute = inputDate.getUTCMinutes();
			this.second = inputDate.getUTCSeconds();
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Function converting ASN.1 internal string into "Date" object
		 * @returns {Date}
		 */
		toDate()
		{
			return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			//region Parse input string
			const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
			const parserArray = parser.exec(inputString);
			if(parserArray === null)
			{
				this.error = "Wrong input string for convertion";
				return;
			}
			//endregion

			//region Store parsed values
			const year = parseInt(parserArray[1], 10);
			if(year >= 50)
				this.year = 1900 + year;
			else
				this.year = 2000 + year;

			this.month = parseInt(parserArray[2], 10);
			this.day = parseInt(parserArray[3], 10);
			this.hour = parseInt(parserArray[4], 10);
			this.minute = parseInt(parserArray[5], 10);
			this.second = parseInt(parserArray[6], 10);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal class into JavaScript string
		 * @returns {string}
		 */
		toString()
		{
			const outputArray = new Array(7);

			outputArray[0] = padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);
			outputArray[1] = padNumber(this.month, 2);
			outputArray[2] = padNumber(this.day, 2);
			outputArray[3] = padNumber(this.hour, 2);
			outputArray[4] = padNumber(this.minute, 2);
			outputArray[5] = padNumber(this.second, 2);
			outputArray[6] = "Z";

			return outputArray.join("");
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "UTCTime";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.year = this.year;
			object.month = this.month;
			object.day = this.day;
			object.hour = this.hour;
			object.minute = this.minute;
			object.second = this.second;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends VisibleString
	 */
	class GeneralizedTime extends VisibleString
	{
		//**********************************************************************************
		/**
		 * Constructor for "GeneralizedTime" class
		 * @param {Object} [parameters={}]
		 * @property {string} [value] String representatio of the date
		 * @property {Date} [valueDate] JavaScript "Date" object
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.year = 0;
			this.month = 0;
			this.day = 0;
			this.hour = 0;
			this.minute = 0;
			this.second = 0;
			this.millisecond = 0;

			//region Create UTCTime from ASN.1 UTC string value
			if("value" in parameters)
			{
				this.fromString(parameters.value);

				this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
				const view = new Uint8Array(this.valueBlock.valueHex);

				for(let i = 0; i < parameters.value.length; i++)
					view[i] = parameters.value.charCodeAt(i);
			}
			//endregion
			//region Create GeneralizedTime from JavaScript Date type
			if("valueDate" in parameters)
			{
				this.fromDate(parameters.valueDate);
				this.valueBlock.valueHex = this.toBuffer();
			}
			//endregion

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 24; // GeneralizedTime
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal string into ArrayBuffer
		 * @returns {ArrayBuffer}
		 */
		toBuffer()
		{
			const str = this.toString();

			const buffer = new ArrayBuffer(str.length);
			const view = new Uint8Array(buffer);

			for(let i = 0; i < str.length; i++)
				view[i] = str.charCodeAt(i);

			return buffer;
		}
		//**********************************************************************************
		/**
		 * Function converting "Date" object into ASN.1 internal string
		 * @param {!Date} inputDate JavaScript "Date" object
		 */
		fromDate(inputDate)
		{
			this.year = inputDate.getUTCFullYear();
			this.month = inputDate.getUTCMonth() + 1;
			this.day = inputDate.getUTCDate();
			this.hour = inputDate.getUTCHours();
			this.minute = inputDate.getUTCMinutes();
			this.second = inputDate.getUTCSeconds();
			this.millisecond = inputDate.getUTCMilliseconds();
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Function converting ASN.1 internal string into "Date" object
		 * @returns {Date}
		 */
		toDate()
		{
			return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			//region Initial variables
			let isUTC = false;

			let timeString = "";
			let dateTimeString = "";
			let fractionPart = 0;

			let parser;

			let hourDifference = 0;
			let minuteDifference = 0;
			//endregion

			//region Convert as UTC time
			if(inputString[inputString.length - 1] === "Z")
			{
				timeString = inputString.substr(0, inputString.length - 1);

				isUTC = true;
			}
			//endregion
			//region Convert as local time
			else
			{
				//noinspection JSPrimitiveTypeWrapperUsage
				const number = new Number(inputString[inputString.length - 1]);

				if(isNaN(number.valueOf()))
					throw new Error("Wrong input string for convertion");

				timeString = inputString;
			}
			//endregion

			//region Check that we do not have a "+" and "-" symbols inside UTC time
			if(isUTC)
			{
				if(timeString.indexOf("+") !== (-1))
					throw new Error("Wrong input string for convertion");

				if(timeString.indexOf("-") !== (-1))
					throw new Error("Wrong input string for convertion");
			}
			//endregion
			//region Get "UTC time difference" in case of local time
			else
			{
				let multiplier = 1;
				let differencePosition = timeString.indexOf("+");
				let differenceString = "";

				if(differencePosition === (-1))
				{
					differencePosition = timeString.indexOf("-");
					multiplier = (-1);
				}

				if(differencePosition !== (-1))
				{
					differenceString = timeString.substr(differencePosition + 1);
					timeString = timeString.substr(0, differencePosition);

					if((differenceString.length !== 2) && (differenceString.length !== 4))
						throw new Error("Wrong input string for convertion");

					//noinspection JSPrimitiveTypeWrapperUsage
					let number = new Number(differenceString.substr(0, 2));

					if(isNaN(number.valueOf()))
						throw new Error("Wrong input string for convertion");

					hourDifference = multiplier * number;

					if(differenceString.length === 4)
					{
						//noinspection JSPrimitiveTypeWrapperUsage
						number = new Number(differenceString.substr(2, 2));

						if(isNaN(number.valueOf()))
							throw new Error("Wrong input string for convertion");

						minuteDifference = multiplier * number;
					}
				}
			}
			//endregion

			//region Get position of fraction point
			let fractionPointPosition = timeString.indexOf("."); // Check for "full stop" symbol
			if(fractionPointPosition === (-1))
				fractionPointPosition = timeString.indexOf(","); // Check for "comma" symbol
			//endregion

			//region Get fraction part
			if(fractionPointPosition !== (-1))
			{
				//noinspection JSPrimitiveTypeWrapperUsage
				const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);

				if(isNaN(fractionPartCheck.valueOf()))
					throw new Error("Wrong input string for convertion");

				fractionPart = fractionPartCheck.valueOf();

				dateTimeString = timeString.substr(0, fractionPointPosition);
			}
			else
				dateTimeString = timeString;
			//endregion

			//region Parse internal date
			switch(true)
			{
				case (dateTimeString.length === 8): // "YYYYMMDD"
					parser = /(\d{4})(\d{2})(\d{2})/ig;
					if(fractionPointPosition !== (-1))
						throw new Error("Wrong input string for convertion"); // Here we should not have a "fraction point"
					break;
				case (dateTimeString.length === 10): // "YYYYMMDDHH"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;

					if(fractionPointPosition !== (-1))
					{
						let fractionResult = 60 * fractionPart;
						this.minute = Math.floor(fractionResult);

						fractionResult = 60 * (fractionResult - this.minute);
						this.second = Math.floor(fractionResult);

						fractionResult = 1000 * (fractionResult - this.second);
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				case (dateTimeString.length === 12): // "YYYYMMDDHHMM"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

					if(fractionPointPosition !== (-1))
					{
						let fractionResult = 60 * fractionPart;
						this.second = Math.floor(fractionResult);

						fractionResult = 1000 * (fractionResult - this.second);
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				case (dateTimeString.length === 14): // "YYYYMMDDHHMMSS"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

					if(fractionPointPosition !== (-1))
					{
						const fractionResult = 1000 * fractionPart;
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				default:
					throw new Error("Wrong input string for convertion");
			}
			//endregion

			//region Put parsed values at right places
			const parserArray = parser.exec(dateTimeString);
			if(parserArray === null)
				throw new Error("Wrong input string for convertion");

			for(let j = 1; j < parserArray.length; j++)
			{
				switch(j)
				{
					case 1:
						this.year = parseInt(parserArray[j], 10);
						break;
					case 2:
						this.month = parseInt(parserArray[j], 10);
						break;
					case 3:
						this.day = parseInt(parserArray[j], 10);
						break;
					case 4:
						this.hour = parseInt(parserArray[j], 10) + hourDifference;
						break;
					case 5:
						this.minute = parseInt(parserArray[j], 10) + minuteDifference;
						break;
					case 6:
						this.second = parseInt(parserArray[j], 10);
						break;
					default:
						throw new Error("Wrong input string for convertion");
				}
			}
			//endregion

			//region Get final date
			if(isUTC === false)
			{
				const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);

				this.year = tempDate.getUTCFullYear();
				this.month = tempDate.getUTCMonth();
				this.day = tempDate.getUTCDay();
				this.hour = tempDate.getUTCHours();
				this.minute = tempDate.getUTCMinutes();
				this.second = tempDate.getUTCSeconds();
				this.millisecond = tempDate.getUTCMilliseconds();
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal class into JavaScript string
		 * @returns {string}
		 */
		toString()
		{
			const outputArray = [];

			outputArray.push(padNumber(this.year, 4));
			outputArray.push(padNumber(this.month, 2));
			outputArray.push(padNumber(this.day, 2));
			outputArray.push(padNumber(this.hour, 2));
			outputArray.push(padNumber(this.minute, 2));
			outputArray.push(padNumber(this.second, 2));
			if(this.millisecond !== 0)
			{
				outputArray.push(".");
				outputArray.push(padNumber(this.millisecond, 3));
			}
			outputArray.push("Z");

			return outputArray.join("");
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "GeneralizedTime";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.year = this.year;
			object.month = this.month;
			object.day = this.day;
			object.hour = this.hour;
			object.minute = this.minute;
			object.second = this.second;
			object.millisecond = this.millisecond;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class DATE extends Utf8String
	{
		//**********************************************************************************
		/**
		 * Constructor for "DATE" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 31; // DATE
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "DATE";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class TimeOfDay extends Utf8String
	{
		//**********************************************************************************
		/**
		 * Constructor for "TimeOfDay" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 32; // TimeOfDay
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "TimeOfDay";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class DateTime extends Utf8String
	{
		//**********************************************************************************
		/**
		 * Constructor for "DateTime" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 33; // DateTime
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "DateTime";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class Duration extends Utf8String
	{
		//**********************************************************************************
		/**
		 * Constructor for "Duration" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 34; // Duration
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Duration";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class TIME extends Utf8String
	{
		//**********************************************************************************
		/**
		 * Constructor for "Time" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 14; // Time
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "TIME";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Major ASN.1 BER decoding function
	//**************************************************************************************
	/**
	 * Internal library function for decoding ASN.1 BER
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {{offset: number, result: Object}}
	 */
	function LocalFromBER(inputBuffer, inputOffset, inputLength)
	{
		const incomingOffset = inputOffset; // Need to store initial offset since "inputOffset" is changing in the function

		//region Local function changing a type for ASN.1 classes
		function localChangeType(inputObject, newType)
		{
			if(inputObject instanceof newType)
				return inputObject;

			const newObject = new newType();
			newObject.idBlock = inputObject.idBlock;
			newObject.lenBlock = inputObject.lenBlock;
			newObject.warnings = inputObject.warnings;
			//noinspection JSCheckFunctionSignatures
			newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);

			return newObject;
		}
		//endregion

		//region Create a basic ASN.1 type since we need to return errors and warnings from the function
		let returnObject = new BaseBlock({}, Object);
		//endregion

		//region Basic check for parameters
		if(checkBufferParams(new LocalBaseBlock(), inputBuffer, inputOffset, inputLength) === false)
		{
			returnObject.error = "Wrong input parameters";
			return {
				offset: (-1),
				result: returnObject
			};
		}
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if(intBuffer.length === 0)
		{
			this.error = "Zero buffer length";
			return {
				offset: (-1),
				result: returnObject
			};
		}
		//endregion

		//region Decode indentifcation block of ASN.1 BER structure
		let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
		returnObject.warnings.concat(returnObject.idBlock.warnings);
		if(resultOffset === (-1))
		{
			returnObject.error = returnObject.idBlock.error;
			return {
				offset: (-1),
				result: returnObject
			};
		}

		inputOffset = resultOffset;
		inputLength -= returnObject.idBlock.blockLength;
		//endregion

		//region Decode length block of ASN.1 BER structure
		resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
		returnObject.warnings.concat(returnObject.lenBlock.warnings);
		if(resultOffset === (-1))
		{
			returnObject.error = returnObject.lenBlock.error;
			return {
				offset: (-1),
				result: returnObject
			};
		}

		inputOffset = resultOffset;
		inputLength -= returnObject.lenBlock.blockLength;
		//endregion

		//region Check for usign indefinite length form in encoding for primitive types
		if((returnObject.idBlock.isConstructed === false) &&
			(returnObject.lenBlock.isIndefiniteForm === true))
		{
			returnObject.error = "Indefinite length form used for primitive encoding form";
			return {
				offset: (-1),
				result: returnObject
			};
		}
		//endregion

		//region Switch ASN.1 block type
		let newASN1Type = BaseBlock;

		switch(returnObject.idBlock.tagClass)
		{
			//region UNIVERSAL
			case 1:
				//region Check for reserved tag numbers
				if((returnObject.idBlock.tagNumber >= 37) &&
					(returnObject.idBlock.isHexOnly === false))
				{
					returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
					return {
						offset: (-1),
						result: returnObject
					};
				}
				//endregion

				switch(returnObject.idBlock.tagNumber)
				{
					//region EndOfContent type
					case 0:
						//region Check for EndOfContent type
						if((returnObject.idBlock.isConstructed === true) &&
							(returnObject.lenBlock.length > 0))
						{
							returnObject.error = "Type [UNIVERSAL 0] is reserved";
							return {
								offset: (-1),
								result: returnObject
							};
						}
						//endregion

						newASN1Type = EndOfContent;

						break;
					//endregion
					//region Boolean type
					case 1:
						newASN1Type = Boolean;
						break;
					//endregion
					//region Integer type
					case 2:
						newASN1Type = Integer;
						break;
					//endregion
					//region BitString type
					case 3:
						newASN1Type = BitString;
						break;
					//endregion
					//region OctetString type
					case 4:
						newASN1Type = OctetString;
						break;
					//endregion
					//region Null type
					case 5:
						newASN1Type = Null;
						break;
					//endregion
					//region OBJECT IDENTIFIER type
					case 6:
						newASN1Type = ObjectIdentifier;
						break;
					//endregion
					//region Enumerated type
					case 10:
						newASN1Type = Enumerated;
						break;
					//endregion
					//region Utf8String type
					case 12:
						newASN1Type = Utf8String;
						break;
					//endregion
					//region Time type
					case 14:
						newASN1Type = TIME;
						break;
					//endregion
					//region ASN.1 reserved type
					case 15:
						returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
						return {
							offset: (-1),
							result: returnObject
						};
					//endregion
					//region Sequence type
					case 16:
						newASN1Type = Sequence;
						break;
					//endregion
					//region Set type
					case 17:
						newASN1Type = Set;
						break;
					//endregion
					//region NumericString type
					case 18:
						newASN1Type = NumericString;
						break;
					//endregion
					//region PrintableString type
					case 19:
						newASN1Type = PrintableString;
						break;
					//endregion
					//region TeletexString type
					case 20:
						newASN1Type = TeletexString;
						break;
					//endregion
					//region VideotexString type
					case 21:
						newASN1Type = VideotexString;
						break;
					//endregion
					//region IA5String type
					case 22:
						newASN1Type = IA5String;
						break;
					//endregion
					//region UTCTime type
					case 23:
						newASN1Type = UTCTime;
						break;
					//endregion
					//region GeneralizedTime type
					case 24:
						newASN1Type = GeneralizedTime;
						break;
					//endregion
					//region GraphicString type
					case 25:
						newASN1Type = GraphicString;
						break;
					//endregion
					//region VisibleString type
					case 26:
						newASN1Type = VisibleString;
						break;
					//endregion
					//region GeneralString type
					case 27:
						newASN1Type = GeneralString;
						break;
					//endregion
					//region UniversalString type
					case 28:
						newASN1Type = UniversalString;
						break;
					//endregion
					//region CharacterString type
					case 29:
						newASN1Type = CharacterString;
						break;
					//endregion
					//region BmpString type
					case 30:
						newASN1Type = BmpString;
						break;
					//endregion
					//region DATE type
					case 31:
						newASN1Type = DATE;
						break;
					//endregion
					//region TimeOfDay type
					case 32:
						newASN1Type = TimeOfDay;
						break;
					//endregion
					//region Date-Time type
					case 33:
						newASN1Type = DateTime;
						break;
					//endregion
					//region Duration type
					case 34:
						newASN1Type = Duration;
						break;
					//endregion
					//region default
					default:
						{
							let newObject;

							if(returnObject.idBlock.isConstructed === true)
								newObject = new Constructed();
							else
								newObject = new Primitive();

							newObject.idBlock = returnObject.idBlock;
							newObject.lenBlock = returnObject.lenBlock;
							newObject.warnings = returnObject.warnings;

							returnObject = newObject;

							resultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);
						}
					//endregion
				}
				break;
			//endregion
			//region All other tag classes
			case 2: // APPLICATION
			case 3: // CONTEXT-SPECIFIC
			case 4: // PRIVATE
			default:
				{
					if(returnObject.idBlock.isConstructed === true)
						newASN1Type = Constructed;
					else
						newASN1Type = Primitive;
				}
			//endregion
		}
		//endregion

		//region Change type and perform BER decoding
		returnObject = localChangeType(returnObject, newASN1Type);
		resultOffset = returnObject.fromBER(inputBuffer, inputOffset, (returnObject.lenBlock.isIndefiniteForm === true) ? inputLength : returnObject.lenBlock.length);
		//endregion

		//region Coping incoming buffer for entire ASN.1 block
		returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);
		//endregion

		return {
			offset: resultOffset,
			result: returnObject
		};
	}
	//**************************************************************************************
	/**
	 * Major function for decoding ASN.1 BER array into internal library structuries
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes
	 */
	function fromBER(inputBuffer)
	{
		if(inputBuffer.byteLength === 0)
		{
			const result = new BaseBlock({}, Object);
			result.error = "Input buffer has zero length";

			return {
				offset: (-1),
				result
			};
		}

		return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************

	class Debug {
	    static get enabled() {
	        return typeof self !== "undefined" && self.PV_WEBCRYPTO_LINER_LOG;
	    }
	    static log(message, ...optionalParams) {
	        if (this.enabled) {
	            console.log.apply(console, arguments);
	        }
	    }
	    static error(message, ...optionalParams) {
	        if (this.enabled) {
	            console.error.apply(console, arguments);
	        }
	    }
	    static info(message, ...optionalParams) {
	        if (this.enabled) {
	            console.info.apply(console, arguments);
	        }
	    }
	    static warn(message, ...optionalParams) {
	        if (this.enabled) {
	            console.warn.apply(console, arguments);
	        }
	    }
	    static trace(message, ...optionalParams) {
	        if (this.enabled) {
	            console.trace.apply(console, arguments);
	        }
	    }
	}

	let window$1;
	if (typeof self === "undefined") {
	    const crypto = require("crypto");
	    window$1 = {
	        crypto: {
	            subtle: {},
	            getRandomValues: (array) => {
	                const buf = array.buffer;
	                const uint8buf = new Uint8Array(buf);
	                const rnd = crypto.randomBytes(uint8buf.length);
	                rnd.forEach((octet, index) => uint8buf[index] = octet);
	                return array;
	            },
	        },
	    };
	}
	else {
	    window$1 = self;
	}
	const nativeCrypto = window$1.msCrypto
	    || window$1.crypto
	    || {};
	let nativeSubtle = null;
	try {
	    nativeSubtle = nativeCrypto.subtle || nativeCrypto.webkitSubtle;
	}
	catch (err) {
	    console.warn("Cannot get subtle from crypto", err);
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	function __decorate(decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function __awaiter(thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function PrepareBuffer(buffer) {
	    if (typeof Buffer !== "undefined") {
	        return new Uint8Array(buffer);
	    }
	    else {
	        return new Uint8Array(buffer instanceof ArrayBuffer ? buffer : buffer.buffer);
	    }
	}
	class Convert {
	    static ToString(buffer, enc = "utf8") {
	        const buf = PrepareBuffer(buffer);
	        switch (enc.toLowerCase()) {
	            case "utf8":
	                return this.ToUtf8String(buf);
	            case "binary":
	                return this.ToBinary(buf);
	            case "hex":
	                return this.ToHex(buf);
	            case "base64":
	                return this.ToBase64(buf);
	            case "base64url":
	                return this.ToBase64Url(buf);
	            default:
	                throw new Error(`Unknown type of encoding '${enc}'`);
	        }
	    }
	    static FromString(str, enc = "utf8") {
	        switch (enc.toLowerCase()) {
	            case "utf8":
	                return this.FromUtf8String(str);
	            case "binary":
	                return this.FromBinary(str);
	            case "hex":
	                return this.FromHex(str);
	            case "base64":
	                return this.FromBase64(str);
	            case "base64url":
	                return this.FromBase64Url(str);
	            default:
	                throw new Error(`Unknown type of encoding '${enc}'`);
	        }
	    }
	    static ToBase64(buffer) {
	        const buf = PrepareBuffer(buffer);
	        if (typeof btoa !== "undefined") {
	            const binary = this.ToString(buf, "binary");
	            return btoa(binary);
	        }
	        else {
	            return Buffer.from(buf).toString("base64");
	        }
	    }
	    static FromBase64(base64Text) {
	        base64Text = base64Text.replace(/\n/g, "").replace(/\r/g, "").replace(/\t/g, "").replace(/\s/g, "");
	        if (typeof atob !== "undefined") {
	            return this.FromBinary(atob(base64Text));
	        }
	        else {
	            return new Uint8Array(Buffer.from(base64Text, "base64")).buffer;
	        }
	    }
	    static FromBase64Url(base64url) {
	        return this.FromBase64(this.Base64Padding(base64url.replace(/\-/g, "+").replace(/\_/g, "/")));
	    }
	    static ToBase64Url(data) {
	        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
	    }
	    static FromUtf8String(text) {
	        const s = unescape(encodeURIComponent(text));
	        const uintArray = new Uint8Array(s.length);
	        for (let i = 0; i < s.length; i++) {
	            uintArray[i] = s.charCodeAt(i);
	        }
	        return uintArray.buffer;
	    }
	    static ToUtf8String(buffer) {
	        const buf = PrepareBuffer(buffer);
	        const encodedString = String.fromCharCode.apply(null, buf);
	        const decodedString = decodeURIComponent(escape(encodedString));
	        return decodedString;
	    }
	    static FromBinary(text) {
	        const stringLength = text.length;
	        const resultView = new Uint8Array(stringLength);
	        for (let i = 0; i < stringLength; i++) {
	            resultView[i] = text.charCodeAt(i);
	        }
	        return resultView.buffer;
	    }
	    static ToBinary(buffer) {
	        const buf = PrepareBuffer(buffer);
	        let resultString = "";
	        const len = buf.length;
	        for (let i = 0; i < len; i++) {
	            resultString = resultString + String.fromCharCode(buf[i]);
	        }
	        return resultString;
	    }
	    static ToHex(buffer) {
	        const buf = PrepareBuffer(buffer);
	        const splitter = "";
	        const res = [];
	        const len = buf.length;
	        for (let i = 0; i < len; i++) {
	            const char = buf[i].toString(16);
	            res.push(char.length === 1 ? "0" + char : char);
	        }
	        return res.join(splitter);
	    }
	    static FromHex(hexString) {
	        const res = new Uint8Array(hexString.length / 2);
	        for (let i = 0; i < hexString.length; i = i + 2) {
	            const c = hexString.slice(i, i + 2);
	            res[i / 2] = parseInt(c, 16);
	        }
	        return res.buffer;
	    }
	    static Base64Padding(base64) {
	        const padCount = 4 - (base64.length % 4);
	        if (padCount < 4) {
	            for (let i = 0; i < padCount; i++) {
	                base64 += "=";
	            }
	        }
	        return base64;
	    }
	}

	/**
	 * Copyright (c) 2019, Peculiar Ventures, All rights reserved.
	 */

	class CryptoError extends Error {
	}

	class AlgorithmError extends CryptoError {
	}

	class UnsupportedOperationError extends CryptoError {
	    constructor(methodName) {
	        super(`Unsupported operation: ${methodName ? `${methodName}` : ""}`);
	    }
	}

	class OperationError extends CryptoError {
	}

	class RequiredPropertyError extends CryptoError {
	    constructor(propName) {
	        super(`${propName}: Missing required property`);
	    }
	}

	class BufferSourceConverter {
	    static toArrayBuffer(data) {
	        if (data instanceof ArrayBuffer) {
	            return data;
	        }
	        if (typeof Buffer !== "undefined" && Buffer.isBuffer(data)) {
	            return new Uint8Array(data);
	        }
	        if (ArrayBuffer.isView(data)) {
	            return data.buffer;
	        }
	        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
	    }
	    static toUint8Array(data) {
	        return new Uint8Array(this.toArrayBuffer(data));
	    }
	    static isBufferSource(data) {
	        return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;
	    }
	}

	function isJWK(data) {
	    return typeof data === "object" && "kty" in data;
	}

	class ProviderCrypto {
	    digest(algorithm, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkDigest.apply(this, arguments);
	            return this.onDigest.apply(this, arguments);
	        });
	    }
	    checkDigest(algorithm, data) {
	        this.checkAlgorithmName(algorithm);
	    }
	    onDigest(algorithm, data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("digest");
	        });
	    }
	    generateKey(algorithm, extractable, keyUsages) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkGenerateKey.apply(this, arguments);
	            return this.onGenerateKey.apply(this, arguments);
	        });
	    }
	    checkGenerateKey(algorithm, extractable, keyUsages) {
	        this.checkAlgorithmName(algorithm);
	        this.checkGenerateKeyParams(algorithm);
	        if (!(keyUsages && keyUsages.length)) {
	            throw new TypeError(`Usages cannot be empty when creating a key.`);
	        }
	        let allowedUsages;
	        if (Array.isArray(this.usages)) {
	            allowedUsages = this.usages;
	        }
	        else {
	            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);
	        }
	        this.checkKeyUsages(keyUsages, allowedUsages);
	    }
	    checkGenerateKeyParams(algorithm) {
	    }
	    onGenerateKey(algorithm, extractable, keyUsages) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("generateKey");
	        });
	    }
	    sign(algorithm, key, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkSign.apply(this, arguments);
	            return this.onSign.apply(this, arguments);
	        });
	    }
	    checkSign(algorithm, key, data) {
	        this.checkAlgorithmName(algorithm);
	        this.checkAlgorithmParams(algorithm);
	        this.checkCryptoKey(key, "sign");
	    }
	    onSign(algorithm, key, data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("sign");
	        });
	    }
	    verify(algorithm, key, signature, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkVerify.apply(this, arguments);
	            return this.onVerify.apply(this, arguments);
	        });
	    }
	    checkVerify(algorithm, key, signature, data) {
	        this.checkAlgorithmName(algorithm);
	        this.checkAlgorithmParams(algorithm);
	        this.checkCryptoKey(key, "verify");
	    }
	    onVerify(algorithm, key, signature, data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("verify");
	        });
	    }
	    encrypt(algorithm, key, data, options) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkEncrypt.apply(this, arguments);
	            return this.onEncrypt.apply(this, arguments);
	        });
	    }
	    checkEncrypt(algorithm, key, data, options = {}) {
	        this.checkAlgorithmName(algorithm);
	        this.checkAlgorithmParams(algorithm);
	        this.checkCryptoKey(key, options.keyUsage ? "encrypt" : void 0);
	    }
	    onEncrypt(algorithm, key, data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("encrypt");
	        });
	    }
	    decrypt(algorithm, key, data, options) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkDecrypt.apply(this, arguments);
	            return this.onDecrypt.apply(this, arguments);
	        });
	    }
	    checkDecrypt(algorithm, key, data, options = {}) {
	        this.checkAlgorithmName(algorithm);
	        this.checkAlgorithmParams(algorithm);
	        this.checkCryptoKey(key, options.keyUsage ? "decrypt" : void 0);
	    }
	    onDecrypt(algorithm, key, data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("decrypt");
	        });
	    }
	    deriveBits(algorithm, baseKey, length, options) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkDeriveBits.apply(this, arguments);
	            return this.onDeriveBits.apply(this, arguments);
	        });
	    }
	    checkDeriveBits(algorithm, baseKey, length, options = {}) {
	        this.checkAlgorithmName(algorithm);
	        this.checkAlgorithmParams(algorithm);
	        this.checkCryptoKey(baseKey, options.keyUsage ? "deriveBits" : void 0);
	        if (length % 8 !== 0) {
	            throw new OperationError("length: Is not multiple of 8");
	        }
	    }
	    onDeriveBits(algorithm, baseKey, length) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("deriveBits");
	        });
	    }
	    exportKey(format, key) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkExportKey.apply(this, arguments);
	            return this.onExportKey.apply(this, arguments);
	        });
	    }
	    checkExportKey(format, key) {
	        this.checkKeyFormat(format);
	        this.checkCryptoKey(key);
	        if (!key.extractable) {
	            throw new CryptoError("key: Is not extractable");
	        }
	    }
	    onExportKey(format, key) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("exportKey");
	        });
	    }
	    importKey(format, keyData, algorithm, extractable, keyUsages) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkImportKey.apply(this, arguments);
	            return this.onImportKey.apply(this, arguments);
	        });
	    }
	    checkImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        this.checkKeyFormat(format);
	        this.checkKeyData(format, keyData);
	        this.checkAlgorithmName(algorithm);
	        this.checkImportParams(algorithm);
	        if (Array.isArray(this.usages)) {
	            this.checkKeyUsages(keyUsages, this.usages);
	        }
	    }
	    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new UnsupportedOperationError("importKey");
	        });
	    }
	    checkAlgorithmName(algorithm) {
	        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {
	            throw new AlgorithmError("Unrecognized name");
	        }
	    }
	    checkAlgorithmParams(algorithm) {
	    }
	    checkDerivedKeyParams(algorithm) {
	    }
	    checkKeyUsages(usages, allowed) {
	        for (const usage of usages) {
	            if (allowed.indexOf(usage) === -1) {
	                throw new TypeError("Cannot create a key using the specified key usages");
	            }
	        }
	    }
	    checkCryptoKey(key, keyUsage) {
	        this.checkAlgorithmName(key.algorithm);
	        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {
	            throw new CryptoError(`key does not match that of operation`);
	        }
	    }
	    checkRequiredProperty(data, propName) {
	        if (!(propName in data)) {
	            throw new RequiredPropertyError(propName);
	        }
	    }
	    checkHashAlgorithm(algorithm, hashAlgorithms) {
	        for (const item of hashAlgorithms) {
	            if (item.toLowerCase() === algorithm.name.toLowerCase()) {
	                return;
	            }
	        }
	        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(", ")}`);
	    }
	    checkImportParams(algorithm) {
	    }
	    checkKeyFormat(format) {
	        switch (format) {
	            case "raw":
	            case "pkcs8":
	            case "spki":
	            case "jwk":
	                break;
	            default:
	                throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'");
	        }
	    }
	    checkKeyData(format, keyData) {
	        if (!keyData) {
	            throw new TypeError("keyData: Cannot be empty on empty on key importing");
	        }
	        if (format === "jwk") {
	            if (!isJWK(keyData)) {
	                throw new TypeError("keyData: Is not JsonWebToken");
	            }
	        }
	        else if (!BufferSourceConverter.isBufferSource(keyData)) {
	            throw new TypeError("keyData: Is not ArrayBufferView or ArrrayBuffer");
	        }
	    }
	    prepareData(data) {
	        return BufferSourceConverter.toArrayBuffer(data);
	    }
	}

	class AesProvider extends ProviderCrypto {
	    checkGenerateKeyParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "length");
	        if (typeof algorithm.length !== "number") {
	            throw new TypeError("length: Is not of type Number");
	        }
	        switch (algorithm.length) {
	            case 128:
	            case 192:
	            case 256:
	                break;
	            default:
	                throw new TypeError("length: Must be 128, 192, or 256");
	        }
	    }
	    checkDerivedKeyParams(algorithm) {
	        this.checkGenerateKeyParams(algorithm);
	    }
	}

	class AesCbcProvider extends AesProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "AES-CBC";
	        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
	    }
	    checkAlgorithmParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "iv");
	        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
	            throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
	        }
	        if (algorithm.iv.byteLength !== 16) {
	            throw new TypeError("iv: Must have length 16 bytes");
	        }
	    }
	}

	class AesCtrProvider extends AesProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "AES-CTR";
	        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
	    }
	    checkAlgorithmParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "counter");
	        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {
	            throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");
	        }
	        if (algorithm.counter.byteLength !== 16) {
	            throw new TypeError("iv: Must have length 16 bytes");
	        }
	        this.checkRequiredProperty(algorithm, "length");
	        if (typeof algorithm.length !== "number") {
	            throw new TypeError("length: Is not a Number");
	        }
	        if (algorithm.length < 1) {
	            throw new OperationError("length: Must be more than 0");
	        }
	    }
	}

	class AesEcbProvider extends AesProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "AES-ECB";
	        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
	    }
	}

	class AesGcmProvider extends AesProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "AES-GCM";
	        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
	    }
	    checkAlgorithmParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "iv");
	        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
	            throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
	        }
	        if (algorithm.iv.byteLength < 1) {
	            throw new OperationError("iv: Must have length more than 0 and less than 2^64 - 1");
	        }
	        if (!("tagLength" in algorithm)) {
	            algorithm.tagLength = 128;
	        }
	        switch (algorithm.tagLength) {
	            case 32:
	            case 64:
	            case 96:
	            case 104:
	            case 112:
	            case 120:
	            case 128:
	                break;
	            default:
	                throw new OperationError("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128");
	        }
	    }
	}

	class AesKwProvider extends AesProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "AES-KW";
	        this.usages = ["wrapKey", "unwrapKey"];
	    }
	}

	class DesProvider extends ProviderCrypto {
	    constructor() {
	        super(...arguments);
	        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
	    }
	    checkAlgorithmParams(algorithm) {
	        if (this.ivSize) {
	            this.checkRequiredProperty(algorithm, "iv");
	            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
	                throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
	            }
	            if (algorithm.iv.byteLength !== this.ivSize) {
	                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);
	            }
	        }
	    }
	    checkGenerateKeyParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "length");
	        if (typeof algorithm.length !== "number") {
	            throw new TypeError("length: Is not of type Number");
	        }
	        if (algorithm.length !== this.keySizeBits) {
	            throw new OperationError(`algorith.length: Must be ${this.keySizeBits}`);
	        }
	    }
	    checkDerivedKeyParams(algorithm) {
	        this.checkGenerateKeyParams(algorithm);
	    }
	}

	class RsaProvider extends ProviderCrypto {
	    constructor() {
	        super(...arguments);
	        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
	    }
	    checkGenerateKeyParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "hash");
	        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
	        this.checkRequiredProperty(algorithm, "publicExponent");
	        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {
	            throw new TypeError("publicExponent: Missing or not a Uint8Array");
	        }
	        const publicExponent = Convert.ToBase64(algorithm.publicExponent);
	        if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {
	            throw new TypeError("publicExponent: Must be [3] or [1,0,1]");
	        }
	        this.checkRequiredProperty(algorithm, "modulusLength");
	        switch (algorithm.modulusLength) {
	            case 1024:
	            case 2048:
	            case 4096:
	                break;
	            default:
	                throw new TypeError("modulusLength: Must be 1024, 2048, or 4096");
	        }
	    }
	    checkImportParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "hash");
	        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
	    }
	}

	class RsaSsaProvider extends RsaProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "RSASSA-PKCS1-v1_5";
	        this.usages = {
	            privateKey: ["sign"],
	            publicKey: ["verify"],
	        };
	    }
	}

	class RsaPssProvider extends RsaProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "RSA-PSS";
	        this.usages = {
	            privateKey: ["sign"],
	            publicKey: ["verify"],
	        };
	    }
	    checkAlgorithmParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "saltLength");
	        if (typeof algorithm.saltLength !== "number") {
	            throw new TypeError("saltLength: Is not a Number");
	        }
	        if (algorithm.saltLength < 1) {
	            throw new RangeError("saltLength: Must be more than 0");
	        }
	    }
	}

	class RsaOaepProvider extends RsaProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "RSA-OAEP";
	        this.usages = {
	            privateKey: ["decrypt", "unwrapKey"],
	            publicKey: ["encrypt", "wrapKey"],
	        };
	    }
	    checkAlgorithmParams(algorithm) {
	        if (algorithm.label
	            && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {
	            throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'");
	        }
	    }
	}

	class EllipticProvider extends ProviderCrypto {
	    checkGenerateKeyParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "namedCurve");
	        this.checkNamedCurve(algorithm.namedCurve);
	    }
	    checkNamedCurve(namedCurve) {
	        for (const item of this.namedCurves) {
	            if (item.toLowerCase() === namedCurve.toLowerCase()) {
	                return;
	            }
	        }
	        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`);
	    }
	}

	class EcdsaProvider extends EllipticProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "ECDSA";
	        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
	        this.usages = {
	            privateKey: ["sign"],
	            publicKey: ["verify"],
	        };
	        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
	    }
	    checkAlgorithmParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "hash");
	        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
	    }
	}

	const KEY_TYPES = ["secret", "private", "public"];
	class CryptoKey {
	    static create(algorithm, type, extractable, usages) {
	        const key = new this();
	        key.algorithm = algorithm;
	        key.type = type;
	        key.extractable = extractable;
	        key.usages = usages;
	        return key;
	    }
	    static isKeyType(data) {
	        return KEY_TYPES.indexOf(data) !== -1;
	    }
	}

	class EcdhProvider extends EllipticProvider {
	    constructor() {
	        super(...arguments);
	        this.name = "ECDH";
	        this.usages = {
	            privateKey: ["deriveBits", "deriveKey"],
	            publicKey: [],
	        };
	        this.namedCurves = ["P-256", "P-384", "P-521"];
	    }
	    checkAlgorithmParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "public");
	        if (!(algorithm.public instanceof CryptoKey)) {
	            throw new TypeError("public: Is not a CryptoKey");
	        }
	        if (algorithm.public.type !== "public") {
	            throw new OperationError("public: Is not a public key");
	        }
	        if (algorithm.public.algorithm.name !== this.name) {
	            throw new OperationError(`public: Is not ${this.name} key`);
	        }
	    }
	}

	class Pbkdf2Provider extends ProviderCrypto {
	    constructor() {
	        super(...arguments);
	        this.name = "PBKDF2";
	        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
	        this.usages = ["deriveBits", "deriveKey"];
	    }
	    checkAlgorithmParams(algorithm) {
	        this.checkRequiredProperty(algorithm, "hash");
	        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
	        this.checkRequiredProperty(algorithm, "salt");
	        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {
	            throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
	        }
	        this.checkRequiredProperty(algorithm, "iterations");
	        if (typeof algorithm.iterations !== "number") {
	            throw new TypeError("iterations: Is not a Number");
	        }
	        if (algorithm.iterations < 1) {
	            throw new TypeError("iterations: Is less than 1");
	        }
	    }
	    checkImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);
	        if (extractable) {
	            throw new SyntaxError("extractable: Must be False");
	        }
	    }
	}

	class Crypto {
	}

	class ProviderStorage {
	    constructor() {
	        this.items = {};
	    }
	    get(algorithmName) {
	        return this.items[algorithmName.toLowerCase()] || null;
	    }
	    set(provider) {
	        this.items[provider.name.toLowerCase()] = provider;
	    }
	    removeAt(algorithmName) {
	        const provider = this.get(algorithmName.toLowerCase());
	        if (provider) {
	            delete this.items[algorithmName];
	        }
	        return provider;
	    }
	    has(name) {
	        return !!this.get(name);
	    }
	    get length() {
	        return Object.keys(this.items).length;
	    }
	    get algorithms() {
	        const algorithms = [];
	        for (const key in this.items) {
	            const provider = this.items[key];
	            algorithms.push(provider.name);
	        }
	        return algorithms.sort();
	    }
	}

	class SubtleCrypto {
	    constructor() {
	        this.providers = new ProviderStorage();
	    }
	    static isHashedAlgorithm(data) {
	        return data instanceof Object
	            && "name" in data
	            && "hash" in data;
	    }
	    digest(algorithm, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 2, "digest");
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const preparedData = BufferSourceConverter.toArrayBuffer(data);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            const result = yield provider.digest(preparedAlgorithm, preparedData);
	            return result;
	        });
	    }
	    generateKey(algorithm, extractable, keyUsages) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 3, "generateKey");
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            const result = yield provider.generateKey(Object.assign({}, preparedAlgorithm, { name: provider.name }), extractable, keyUsages);
	            return result;
	        });
	    }
	    sign(algorithm, key, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 3, "sign");
	            this.checkCryptoKey(key);
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const preparedData = BufferSourceConverter.toArrayBuffer(data);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            const result = yield provider.sign(Object.assign({}, preparedAlgorithm, { name: provider.name }), key, preparedData);
	            return result;
	        });
	    }
	    verify(algorithm, key, signature, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 4, "verify");
	            this.checkCryptoKey(key);
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const preparedData = BufferSourceConverter.toArrayBuffer(data);
	            const preparedSignature = BufferSourceConverter.toArrayBuffer(signature);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            const result = yield provider.verify(Object.assign({}, preparedAlgorithm, { name: provider.name }), key, preparedSignature, preparedData);
	            return result;
	        });
	    }
	    encrypt(algorithm, key, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 3, "encrypt");
	            this.checkCryptoKey(key);
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const preparedData = BufferSourceConverter.toArrayBuffer(data);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            const result = yield provider.encrypt(Object.assign({}, preparedAlgorithm, { name: provider.name }), key, preparedData, { keyUsage: true });
	            return result;
	        });
	    }
	    decrypt(algorithm, key, data) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 3, "decrypt");
	            this.checkCryptoKey(key);
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const preparedData = BufferSourceConverter.toArrayBuffer(data);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            const result = yield provider.decrypt(Object.assign({}, preparedAlgorithm, { name: provider.name }), key, preparedData, { keyUsage: true });
	            return result;
	        });
	    }
	    deriveBits(algorithm, baseKey, length) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 3, "deriveBits");
	            this.checkCryptoKey(baseKey);
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            const result = yield provider.deriveBits(Object.assign({}, preparedAlgorithm, { name: provider.name }), baseKey, length, { keyUsage: true });
	            return result;
	        });
	    }
	    deriveKey(algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 5, "deriveKey");
	            const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);
	            const importProvider = this.getProvider(preparedDerivedKeyType.name);
	            importProvider.checkDerivedKeyParams(preparedDerivedKeyType);
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            provider.checkCryptoKey(baseKey, "deriveKey");
	            const derivedBits = yield provider.deriveBits(Object.assign({}, preparedAlgorithm, { name: provider.name }), baseKey, derivedKeyType.length, { keyUsage: false });
	            return this.importKey("raw", derivedBits, derivedKeyType, extractable, keyUsages);
	        });
	    }
	    exportKey(format, key) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 2, "exportKey");
	            this.checkCryptoKey(key);
	            const provider = this.getProvider(key.algorithm.name);
	            const result = yield provider.exportKey(format, key);
	            return result;
	        });
	    }
	    importKey(format, keyData, algorithm, extractable, keyUsages) {
	        return __awaiter(this, arguments, void 0, function* () {
	            this.checkRequiredArguments(arguments, 5, "importKey");
	            const preparedAlgorithm = this.prepareAlgorithm(algorithm);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            if (["pkcs8", "spki", "raw"].indexOf(format) !== -1) {
	                const preparedData = BufferSourceConverter.toArrayBuffer(keyData);
	                return provider.importKey(format, preparedData, Object.assign({}, preparedAlgorithm, { name: provider.name }), extractable, keyUsages);
	            }
	            else {
	                if (!keyData.kty) {
	                    throw new TypeError("keyData: Is not JSON");
	                }
	            }
	            return provider.importKey(format, keyData, Object.assign({}, preparedAlgorithm, { name: provider.name }), extractable, keyUsages);
	        });
	    }
	    wrapKey(format, key, wrappingKey, wrapAlgorithm) {
	        return __awaiter(this, void 0, void 0, function* () {
	            let keyData = yield this.exportKey(format, key);
	            if (format === "jwk") {
	                const json = JSON.stringify(keyData);
	                keyData = Convert.FromUtf8String(json);
	            }
	            const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);
	            const preparedData = BufferSourceConverter.toArrayBuffer(keyData);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            return provider.encrypt(Object.assign({}, preparedAlgorithm, { name: provider.name }), wrappingKey, preparedData, { keyUsage: false });
	        });
	    }
	    unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);
	            const preparedData = BufferSourceConverter.toArrayBuffer(wrappedKey);
	            const provider = this.getProvider(preparedAlgorithm.name);
	            let keyData = yield provider.decrypt(Object.assign({}, preparedAlgorithm, { name: provider.name }), unwrappingKey, preparedData, { keyUsage: false });
	            if (format === "jwk") {
	                try {
	                    keyData = JSON.parse(Convert.ToUtf8String(keyData));
	                }
	                catch (e) {
	                    const error = new TypeError("wrappedKey: Is not a JSON");
	                    error.internal = e;
	                    throw error;
	                }
	            }
	            return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages);
	        });
	    }
	    checkRequiredArguments(args, size, methodName) {
	        if (args.length !== size) {
	            throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);
	        }
	    }
	    prepareAlgorithm(algorithm) {
	        if (typeof algorithm === "string") {
	            return {
	                name: algorithm,
	            };
	        }
	        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {
	            const preparedAlgorithm = Object.assign({}, algorithm);
	            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);
	            return preparedAlgorithm;
	        }
	        return Object.assign({}, algorithm);
	    }
	    getProvider(name) {
	        const provider = this.providers.get(name);
	        if (!provider) {
	            throw new AlgorithmError("Unrecognized name");
	        }
	        return provider;
	    }
	    checkCryptoKey(key) {
	        if (!(key instanceof CryptoKey)) {
	            throw new TypeError(`Key is not of type 'CryptoKey'`);
	        }
	    }
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	//**************************************************************************************
	/**
	 * Making UTC date from local date
	 * @param {Date} date Date to convert from
	 * @returns {Date}
	 */
	function getUTCDate(date)
	{
		// noinspection NestedFunctionCallJS, MagicNumberJS
		return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Get value for input parameters, or set a default value
	 * @param {Object} parameters
	 * @param {string} name
	 * @param defaultValue
	 */
	function getParametersValue$1(parameters, name, defaultValue)
	{
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		if((parameters instanceof Object) === false)
			return defaultValue;
		
		// noinspection NonBlockStatementBodyJS
		if(name in parameters)
			return parameters[name];
		
		return defaultValue;
	}
	//**************************************************************************************
	/**
	 * Converts "ArrayBuffer" into a hexdecimal string
	 * @param {ArrayBuffer} inputBuffer
	 * @param {number} [inputOffset=0]
	 * @param {number} [inputLength=inputBuffer.byteLength]
	 * @param {boolean} [insertSpace=false]
	 * @returns {string}
	 */
	function bufferToHexCodes$1(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false)
	{
		let result = "";
		
		for(const item of (new Uint8Array(inputBuffer, inputOffset, inputLength)))
		{
			// noinspection ChainedFunctionCallJS
			const str = item.toString(16).toUpperCase();
			
			// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
			if(str.length === 1)
				result += "0";
			
			result += str;
			
			// noinspection NonBlockStatementBodyJS
			if(insertSpace)
				result += " ";
		}
		
		return result.trim();
	}
	//**************************************************************************************
	// noinspection JSValidateJSDoc, FunctionWithMultipleReturnPointsJS
	/**
	 * Check input "ArrayBuffer" for common functions
	 * @param {LocalBaseBlock} baseBlock
	 * @param {ArrayBuffer} inputBuffer
	 * @param {number} inputOffset
	 * @param {number} inputLength
	 * @returns {boolean}
	 */
	function checkBufferParams$1(baseBlock, inputBuffer, inputOffset, inputLength)
	{
		// noinspection ConstantOnRightSideOfComparisonJS
		if((inputBuffer instanceof ArrayBuffer) === false)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputBuffer.byteLength === 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputBuffer has zero length";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputOffset < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputOffset less than zero";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputLength < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputLength less than zero";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if((inputBuffer.byteLength - inputOffset - inputLength) < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
			return false;
		}
		
		return true;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Convert number from 2^base to 2^10
	 * @param {Uint8Array} inputBuffer
	 * @param {number} inputBase
	 * @returns {number}
	 */
	function utilFromBase$1(inputBuffer, inputBase)
	{
		let result = 0;
		
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		if(inputBuffer.length === 1)
			return inputBuffer[0];
		
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		for(let i = (inputBuffer.length - 1); i >= 0; i--)
			result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
		
		return result;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Convert number from 2^10 to 2^base
	 * @param {!number} value The number to convert
	 * @param {!number} base The base for 2^base
	 * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by function itself)
	 * @returns {ArrayBuffer}
	 */
	function utilToBase$1(value, base, reserved = (-1))
	{
		const internalReserved = reserved;
		let internalValue = value;
		
		let result = 0;
		let biggest = Math.pow(2, base);
		
		// noinspection ConstantOnRightSideOfComparisonJS
		for(let i = 1; i < 8; i++)
		{
			if(value < biggest)
			{
				let retBuf;
				
				// noinspection ConstantOnRightSideOfComparisonJS
				if(internalReserved < 0)
				{
					retBuf = new ArrayBuffer(i);
					result = i;
				}
				else
				{
					// noinspection NonBlockStatementBodyJS
					if(internalReserved < i)
						return (new ArrayBuffer(0));
					
					retBuf = new ArrayBuffer(internalReserved);
					
					result = internalReserved;
				}
				
				const retView = new Uint8Array(retBuf);
				
				// noinspection ConstantOnRightSideOfComparisonJS
				for(let j = (i - 1); j >= 0; j--)
				{
					const basis = Math.pow(2, j * base);
					
					retView[result - j - 1] = Math.floor(internalValue / basis);
					internalValue -= (retView[result - j - 1]) * basis;
				}
				
				return retBuf;
			}
			
			biggest *= Math.pow(2, base);
		}
		
		return new ArrayBuffer(0);
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Concatenate two ArrayBuffers
	 * @param {...ArrayBuffer} buffers Set of ArrayBuffer
	 */
	function utilConcatBuf$1(...buffers)
	{
		//region Initial variables
		let outputLength = 0;
		let prevLength = 0;
		//endregion
		
		//region Calculate output length
		
		// noinspection NonBlockStatementBodyJS
		for(const buffer of buffers)
			outputLength += buffer.byteLength;
		//endregion
		
		const retBuf = new ArrayBuffer(outputLength);
		const retView = new Uint8Array(retBuf);
		
		for(const buffer of buffers)
		{
			// noinspection NestedFunctionCallJS
			retView.set(new Uint8Array(buffer), prevLength);
			prevLength += buffer.byteLength;
		}
		
		return retBuf;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Concatenate two Uint8Array
	 * @param {...Uint8Array} views Set of Uint8Array
	 */
	function utilConcatView$1(...views)
	{
		//region Initial variables
		let outputLength = 0;
		let prevLength = 0;
		//endregion
		
		//region Calculate output length
		// noinspection NonBlockStatementBodyJS
		for(const view of views)
			outputLength += view.length;
		//endregion
		
		const retBuf = new ArrayBuffer(outputLength);
		const retView = new Uint8Array(retBuf);
		
		for(const view of views)
		{
			retView.set(view, prevLength);
			prevLength += view.length;
		}
		
		return retView;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Decoding of "two complement" values
	 * The function must be called in scope of instance of "hexBlock" class ("valueHex" and "warnings" properties must be present)
	 * @returns {number}
	 */
	function utilDecodeTC$1()
	{
		const buf = new Uint8Array(this.valueHex);
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(this.valueHex.byteLength >= 2)
		{
			//noinspection JSBitwiseOperatorUsage, ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
			// noinspection ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
			
			// noinspection NonBlockStatementBodyJS
			if(condition1 || condition2)
				this.warnings.push("Needlessly long format");
		}
		
		//region Create big part of the integer
		const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
		const bigIntView = new Uint8Array(bigIntBuffer);
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < this.valueHex.byteLength; i++)
			bigIntView[i] = 0;
		
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		bigIntView[0] = (buf[0] & 0x80); // mask only the biggest bit
		
		const bigInt = utilFromBase$1(bigIntView, 8);
		//endregion
		
		//region Create small part of the integer
		const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
		const smallIntView = new Uint8Array(smallIntBuffer);
		// noinspection NonBlockStatementBodyJS
		for(let j = 0; j < this.valueHex.byteLength; j++)
			smallIntView[j] = buf[j];
		
		// noinspection MagicNumberJS
		smallIntView[0] &= 0x7F; // mask biggest bit
		
		const smallInt = utilFromBase$1(smallIntView, 8);
		//endregion
		
		return (smallInt - bigInt);
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Encode integer value to "two complement" format
	 * @param {number} value Value to encode
	 * @returns {ArrayBuffer}
	 */
	function utilEncodeTC$1(value)
	{
		// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS
		const modValue = (value < 0) ? (value * (-1)) : value;
		let bigInt = 128;
		
		// noinspection ConstantOnRightSideOfComparisonJS
		for(let i = 1; i < 8; i++)
		{
			if(modValue <= bigInt)
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(value < 0)
				{
					const smallInt = bigInt - modValue;
					
					const retBuf = utilToBase$1(smallInt, 8, i);
					const retView = new Uint8Array(retBuf);
					
					// noinspection MagicNumberJS
					retView[0] |= 0x80;
					
					return retBuf;
				}
				
				let retBuf = utilToBase$1(modValue, 8, i);
				let retView = new Uint8Array(retBuf);
				
				//noinspection JSBitwiseOperatorUsage, MagicNumberJS, NonShortCircuitBooleanExpressionJS
				if(retView[0] & 0x80)
				{
					//noinspection JSCheckFunctionSignatures
					const tempBuf = retBuf.slice(0);
					const tempView = new Uint8Array(tempBuf);
					
					retBuf = new ArrayBuffer(retBuf.byteLength + 1);
					// noinspection ReuseOfLocalVariableJS
					retView = new Uint8Array(retBuf);
					
					// noinspection NonBlockStatementBodyJS
					for(let k = 0; k < tempBuf.byteLength; k++)
						retView[k + 1] = tempView[k];
					
					// noinspection MagicNumberJS
					retView[0] = 0x00;
				}
				
				return retBuf;
			}
			
			bigInt *= Math.pow(2, 8);
		}
		
		return (new ArrayBuffer(0));
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS, ParameterNamingConventionJS
	/**
	 * Compare two array buffers
	 * @param {!ArrayBuffer} inputBuffer1
	 * @param {!ArrayBuffer} inputBuffer2
	 * @returns {boolean}
	 */
	function isEqualBuffer$1(inputBuffer1, inputBuffer2)
	{
		// noinspection NonBlockStatementBodyJS
		if(inputBuffer1.byteLength !== inputBuffer2.byteLength)
			return false;
		
		// noinspection LocalVariableNamingConventionJS
		const view1 = new Uint8Array(inputBuffer1);
		// noinspection LocalVariableNamingConventionJS
		const view2 = new Uint8Array(inputBuffer2);
		
		for(let i = 0; i < view1.length; i++)
		{
			// noinspection NonBlockStatementBodyJS
			if(view1[i] !== view2[i])
				return false;
		}
		
		return true;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Pad input number with leade "0" if needed
	 * @returns {string}
	 * @param {number} inputNumber
	 * @param {number} fullLength
	 */
	function padNumber$1(inputNumber, fullLength)
	{
		const str = inputNumber.toString(10);
		
		// noinspection NonBlockStatementBodyJS
		if(fullLength < str.length)
			return "";
		
		const dif = fullLength - str.length;
		
		const padding = new Array(dif);
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < dif; i++)
			padding[i] = "0";
		
		const paddingString = padding.join("");
		
		return paddingString.concat(str);
	}
	//**************************************************************************************
	const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS, FunctionNamingConventionJS
	/**
	 * Encode string into BASE64 (or "base64url")
	 * @param {string} input
	 * @param {boolean} useUrlTemplate If "true" then output would be encoded using "base64url"
	 * @param {boolean} skipPadding Skip BASE-64 padding or not
	 * @param {boolean} skipLeadingZeros Skip leading zeros in input data or not
	 * @returns {string}
	 */
	function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false)
	{
		let i = 0;
		
		// noinspection LocalVariableNamingConventionJS
		let flag1 = 0;
		// noinspection LocalVariableNamingConventionJS
		let flag2 = 0;
		
		let output = "";
		
		// noinspection ConditionalExpressionJS
		const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
		
		if(skipLeadingZeros)
		{
			let nonZeroPosition = 0;
			
			for(let i = 0; i < input.length; i++)
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(input.charCodeAt(i) !== 0)
				{
					nonZeroPosition = i;
					// noinspection BreakStatementJS
					break;
				}
			}
			
			// noinspection AssignmentToFunctionParameterJS
			input = input.slice(nonZeroPosition);
		}
		
		while(i < input.length)
		{
			// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const chr1 = input.charCodeAt(i++);
			// noinspection NonBlockStatementBodyJS
			if(i >= input.length)
				flag1 = 1;
			// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const chr2 = input.charCodeAt(i++);
			// noinspection NonBlockStatementBodyJS
			if(i >= input.length)
				flag2 = 1;
			// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const chr3 = input.charCodeAt(i++);
			
			// noinspection LocalVariableNamingConventionJS
			const enc1 = chr1 >> 2;
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			let enc4 = chr3 & 0x3F;
			
			// noinspection ConstantOnRightSideOfComparisonJS
			if(flag1 === 1)
			{
				// noinspection NestedAssignmentJS, AssignmentResultUsedJS, MagicNumberJS
				enc3 = enc4 = 64;
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(flag2 === 1)
				{
					// noinspection MagicNumberJS
					enc4 = 64;
				}
			}
			
			// noinspection NonBlockStatementBodyJS
			if(skipPadding)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
				if(enc3 === 64)
					output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
				else
				{
					// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
					if(enc4 === 64)
						output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
					else
						output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
				}
			}
			else
				output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
		}
		
		return output;
	}
	//**************************************************************************************
	// noinspection FunctionWithMoreThanThreeNegationsJS, FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionNamingConventionJS
	/**
	 * Decode string from BASE64 (or "base64url")
	 * @param {string} input
	 * @param {boolean} [useUrlTemplate=false] If "true" then output would be encoded using "base64url"
	 * @param {boolean} [cutTailZeros=false] If "true" then cut tailing zeroz from function result
	 * @returns {string}
	 */
	function fromBase64(input, useUrlTemplate = false, cutTailZeros = false)
	{
		// noinspection ConditionalExpressionJS
		const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
		
		//region Aux functions
		// noinspection FunctionWithMultipleReturnPointsJS, NestedFunctionJS
		function indexof(toSearch)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, MagicNumberJS
			for(let i = 0; i < 64; i++)
			{
				// noinspection NonBlockStatementBodyJS
				if(template.charAt(i) === toSearch)
					return i;
			}
			
			// noinspection MagicNumberJS
			return 64;
		}
		
		// noinspection NestedFunctionJS
		function test(incoming)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS, MagicNumberJS
			return ((incoming === 64) ? 0x00 : incoming);
		}
		//endregion
		
		let i = 0;
		
		let output = "";
		
		while(i < input.length)
		{
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const enc1 = indexof(input.charAt(i++));
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS
			const enc2 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS
			const enc3 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS
			const enc4 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));
			
			// noinspection LocalVariableNamingConventionJS, NonShortCircuitBooleanExpressionJS
			const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);
			
			output += String.fromCharCode(chr1);
			
			// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
			if(enc3 !== 64)
				output += String.fromCharCode(chr2);
			
			// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
			if(enc4 !== 64)
				output += String.fromCharCode(chr3);
		}
		
		if(cutTailZeros)
		{
			const outputLength = output.length;
			let nonZeroStart = (-1);
			
			// noinspection ConstantOnRightSideOfComparisonJS
			for(let i = (outputLength - 1); i >= 0; i--)
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(output.charCodeAt(i) !== 0)
				{
					nonZeroStart = i;
					// noinspection BreakStatementJS
					break;
				}
			}
			
			// noinspection NonBlockStatementBodyJS, NegatedIfStatementJS
			if(nonZeroStart !== (-1))
				output = output.slice(0, nonZeroStart + 1);
			else
				output = "";
		}
		
		return output;
	}
	//**************************************************************************************
	function arrayBufferToString(buffer)
	{
		let resultString = "";
		const view = new Uint8Array(buffer);
		
		// noinspection NonBlockStatementBodyJS
		for(const element of view)
			resultString += String.fromCharCode(element);
		
		return resultString;
	}
	//**************************************************************************************
	function stringToArrayBuffer$1(str)
	{
		const stringLength = str.length;
		
		const resultBuffer = new ArrayBuffer(stringLength);
		const resultView = new Uint8Array(resultBuffer);
		
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < stringLength; i++)
			resultView[i] = str.charCodeAt(i);
		
		return resultBuffer;
	}
	//**************************************************************************************
	const log2 = Math.log(2);
	//**************************************************************************************
	// noinspection FunctionNamingConventionJS
	/**
	 * Get nearest to input length power of 2
	 * @param {number} length Current length of existing array
	 * @returns {number}
	 */
	function nearestPowerOf2(length)
	{
		const base = (Math.log(length) / log2);
		
		const floor = Math.floor(base);
		const round = Math.round(base);
		
		// noinspection ConditionalExpressionJS
		return ((floor === round) ? floor : round);
	}
	//**************************************************************************************
	/**
	 * Delete properties by name from specified object
	 * @param {Object} object Object to delete properties from
	 * @param {Array.<string>} propsArray Array of properties names
	 */
	function clearProps(object, propsArray)
	{
		for(const prop of propsArray)
			delete object[prop];
	}
	//**************************************************************************************

	var utils = /*#__PURE__*/Object.freeze({
	  getUTCDate: getUTCDate,
	  getParametersValue: getParametersValue$1,
	  bufferToHexCodes: bufferToHexCodes$1,
	  checkBufferParams: checkBufferParams$1,
	  utilFromBase: utilFromBase$1,
	  utilToBase: utilToBase$1,
	  utilConcatBuf: utilConcatBuf$1,
	  utilConcatView: utilConcatView$1,
	  utilDecodeTC: utilDecodeTC$1,
	  utilEncodeTC: utilEncodeTC$1,
	  isEqualBuffer: isEqualBuffer$1,
	  padNumber: padNumber$1,
	  toBase64: toBase64,
	  fromBase64: fromBase64,
	  arrayBufferToString: arrayBufferToString,
	  stringToArrayBuffer: stringToArrayBuffer$1,
	  nearestPowerOf2: nearestPowerOf2,
	  clearProps: clearProps
	});

	var asn1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.RawData = exports.Repeated = exports.Any = exports.Choice = exports.TIME = exports.Duration = exports.DateTime = exports.TimeOfDay = exports.DATE = exports.GeneralizedTime = exports.UTCTime = exports.CharacterString = exports.GeneralString = exports.VisibleString = exports.GraphicString = exports.IA5String = exports.VideotexString = exports.TeletexString = exports.PrintableString = exports.NumericString = exports.UniversalString = exports.BmpString = exports.Utf8String = exports.ObjectIdentifier = exports.Enumerated = exports.Integer = exports.BitString = exports.OctetString = exports.Null = exports.Set = exports.Sequence = exports.Boolean = exports.EndOfContent = exports.Constructed = exports.Primitive = exports.BaseBlock = undefined;
	exports.fromBER = fromBER;
	exports.compareSchema = compareSchema;
	exports.verifySchema = verifySchema;
	exports.fromJSON = fromJSON;



	//**************************************************************************************
	//region Declaration of global variables
	//**************************************************************************************
	const powers2 = [new Uint8Array([1])]; /* eslint-disable indent */
	/*
	 * Copyright (c) 2016-2018, Peculiar Ventures
	 * All rights reserved.
	 *
	 * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 *    this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of the copyright holder nor the names of its contributors
	 *    may be used to endorse or promote products derived from this software without
	 *    specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
	 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
	 * OF SUCH DAMAGE.
	 *
	 */
	//**************************************************************************************

	const digitsString = "0123456789";
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration for "LocalBaseBlock" class
	//**************************************************************************************
	/**
	 * Class used as a base block for all remaining ASN.1 classes
	 * @typedef LocalBaseBlock
	 * @interface
	 * @property {number} blockLength
	 * @property {string} error
	 * @property {Array.<string>} warnings
	 * @property {ArrayBuffer} valueBeforeDecode
	 */
	class LocalBaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalBaseBlock" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueBeforeDecode]
	  */
		constructor(parameters = {}) {
			/**
	   * @type {number} blockLength
	   */
			this.blockLength = (0, utils.getParametersValue)(parameters, "blockLength", 0);
			/**
	   * @type {string} error
	   */
			this.error = (0, utils.getParametersValue)(parameters, "error", "");
			/**
	   * @type {Array.<string>} warnings
	   */
			this.warnings = (0, utils.getParametersValue)(parameters, "warnings", []);
			//noinspection JSCheckFunctionSignatures
			/**
	   * @type {ArrayBuffer} valueBeforeDecode
	   */
			if ("valueBeforeDecode" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "baseBlock";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	  */
		toJSON() {
			return {
				blockName: this.constructor.blockName(),
				blockLength: this.blockLength,
				error: this.error,
				warnings: this.warnings,
				valueBeforeDecode: (0, utils.bufferToHexCodes)(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Description for "LocalHexBlock" class
	//**************************************************************************************
	/**
	 * Class used as a base block for all remaining ASN.1 classes
	 * @extends LocalBaseBlock
	 * @typedef LocalHexBlock
	 * @property {number} blockLength
	 * @property {string} error
	 * @property {Array.<string>} warnings
	 * @property {ArrayBuffer} valueBeforeDecode
	 * @property {boolean} isHexOnly
	 * @property {ArrayBuffer} valueHex
	 */
	//noinspection JSUnusedLocalSymbols
	const LocalHexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Constructor for "LocalHexBlock" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters);

			/**
	   * @type {boolean}
	   */
			this.isHexOnly = (0, utils.getParametersValue)(parameters, "isHexOnly", false);
			/**
	   * @type {ArrayBuffer}
	   */
			if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "hexBlock";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if (intBuffer.length === 0) {
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Copy input buffer to internal buffer
			this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);
			//endregion

			this.blockLength = inputLength;

			return inputOffset + inputLength;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			if (this.isHexOnly !== true) {
				this.error = "Flag \"isHexOnly\" is not set, abort";
				return new ArrayBuffer(0);
			}

			if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);

			//noinspection JSCheckFunctionSignatures
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.blockName = this.constructor.blockName();
			object.isHexOnly = this.isHexOnly;
			object.valueHex = (0, utils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	};
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of identification block class
	//**************************************************************************************
	class LocalIdentificationBlock extends LocalHexBlock(LocalBaseBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalBaseBlock" class
	  * @param {Object} [parameters={}]
	  * @property {Object} [idBlock]
	  */
		constructor(parameters = {}) {
			super();

			if ("idBlock" in parameters) {
				//region Properties from hexBlock class
				this.isHexOnly = (0, utils.getParametersValue)(parameters.idBlock, "isHexOnly", false);
				this.valueHex = (0, utils.getParametersValue)(parameters.idBlock, "valueHex", new ArrayBuffer(0));
				//endregion

				this.tagClass = (0, utils.getParametersValue)(parameters.idBlock, "tagClass", -1);
				this.tagNumber = (0, utils.getParametersValue)(parameters.idBlock, "tagNumber", -1);
				this.isConstructed = (0, utils.getParametersValue)(parameters.idBlock, "isConstructed", false);
			} else {
				this.tagClass = -1;
				this.tagNumber = -1;
				this.isConstructed = false;
			}
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "identificationBlock";
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			//region Initial variables
			let firstOctet = 0;
			let retBuf;
			let retView;
			//endregion

			switch (this.tagClass) {
				case 1:
					firstOctet |= 0x00; // UNIVERSAL
					break;
				case 2:
					firstOctet |= 0x40; // APPLICATION
					break;
				case 3:
					firstOctet |= 0x80; // CONTEXT-SPECIFIC
					break;
				case 4:
					firstOctet |= 0xC0; // PRIVATE
					break;
				default:
					this.error = "Unknown tag class";
					return new ArrayBuffer(0);
			}

			if (this.isConstructed) firstOctet |= 0x20;

			if (this.tagNumber < 31 && !this.isHexOnly) {
				retBuf = new ArrayBuffer(1);
				retView = new Uint8Array(retBuf);

				if (!sizeOnly) {
					let number = this.tagNumber;
					number &= 0x1F;
					firstOctet |= number;

					retView[0] = firstOctet;
				}

				return retBuf;
			}

			if (this.isHexOnly === false) {
				const encodedBuf = (0, utils.utilToBase)(this.tagNumber, 7);
				const encodedView = new Uint8Array(encodedBuf);
				const size = encodedBuf.byteLength;

				retBuf = new ArrayBuffer(size + 1);
				retView = new Uint8Array(retBuf);
				retView[0] = firstOctet | 0x1F;

				if (!sizeOnly) {
					for (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;

					retView[size] = encodedView[size - 1];
				}

				return retBuf;
			}

			retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
			retView = new Uint8Array(retBuf);

			retView[0] = firstOctet | 0x1F;

			if (sizeOnly === false) {
				const curView = new Uint8Array(this.valueHex);

				for (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;

				retView[this.valueHex.byteLength] = curView[curView.length - 1];
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if (intBuffer.length === 0) {
				this.error = "Zero buffer length";
				return -1;
			}
			//endregion

			//region Find tag class
			const tagClassMask = intBuffer[0] & 0xC0;

			switch (tagClassMask) {
				case 0x00:
					this.tagClass = 1; // UNIVERSAL
					break;
				case 0x40:
					this.tagClass = 2; // APPLICATION
					break;
				case 0x80:
					this.tagClass = 3; // CONTEXT-SPECIFIC
					break;
				case 0xC0:
					this.tagClass = 4; // PRIVATE
					break;
				default:
					this.error = "Unknown tag class";
					return -1;
			}
			//endregion

			//region Find it's constructed or not
			this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
			//endregion

			//region Find tag number
			this.isHexOnly = false;

			const tagNumberMask = intBuffer[0] & 0x1F;

			//region Simple case (tag number < 31)
			if (tagNumberMask !== 0x1F) {
				this.tagNumber = tagNumberMask;
				this.blockLength = 1;
			}
			//endregion
			//region Tag number bigger or equal to 31
			else {
					let count = 1;

					this.valueHex = new ArrayBuffer(255);
					let tagNumberBufferMaxLength = 255;
					let intTagNumberBuffer = new Uint8Array(this.valueHex);

					//noinspection JSBitwiseOperatorUsage
					while (intBuffer[count] & 0x80) {
						intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
						count++;

						if (count >= intBuffer.length) {
							this.error = "End of input reached before message was fully decoded";
							return -1;
						}

						//region In case if tag number length is greater than 255 bytes (rare but possible case)
						if (count === tagNumberBufferMaxLength) {
							tagNumberBufferMaxLength += 255;

							const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);
							const tempBufferView = new Uint8Array(tempBuffer);

							for (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];

							this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);
							intTagNumberBuffer = new Uint8Array(this.valueHex);
						}
						//endregion
					}

					this.blockLength = count + 1;
					intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer

					//region Cut buffer
					const tempBuffer = new ArrayBuffer(count);
					const tempBufferView = new Uint8Array(tempBuffer);

					for (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];

					this.valueHex = new ArrayBuffer(count);
					intTagNumberBuffer = new Uint8Array(this.valueHex);
					intTagNumberBuffer.set(tempBufferView);
					//endregion

					//region Try to convert long tag number to short form
					if (this.blockLength <= 9) this.tagNumber = (0, utils.utilFromBase)(intTagNumberBuffer, 7);else {
						this.isHexOnly = true;
						this.warnings.push("Tag too long, represented as hex-coded");
					}
					//endregion
				}
			//endregion
			//endregion

			//region Check if constructed encoding was using for primitive type
			if (this.tagClass === 1 && this.isConstructed) {
				switch (this.tagNumber) {
					case 1: // Boolean
					case 2: // REAL
					case 5: // Null
					case 6: // OBJECT IDENTIFIER
					case 9: // REAL
					case 14: // Time
					case 23:
					case 24:
					case 31:
					case 32:
					case 33:
					case 34:
						this.error = "Constructed encoding used for primitive type";
						return -1;
					default:
				}
			}
			//endregion

			return inputOffset + this.blockLength; // Return current offset in input buffer
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName: string,
	  *  tagClass: number,
	  *  tagNumber: number,
	  *  isConstructed: boolean,
	  *  isHexOnly: boolean,
	  *  valueHex: ArrayBuffer,
	  *  blockLength: number,
	  *  error: string, warnings: Array.<string>,
	  *  valueBeforeDecode: string}}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.blockName = this.constructor.blockName();
			object.tagClass = this.tagClass;
			object.tagNumber = this.tagNumber;
			object.isConstructed = this.isConstructed;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of length block class
	//**************************************************************************************
	class LocalLengthBlock extends LocalBaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalLengthBlock" class
	  * @param {Object} [parameters={}]
	  * @property {Object} [lenBlock]
	  */
		constructor(parameters = {}) {
			super();

			if ("lenBlock" in parameters) {
				this.isIndefiniteForm = (0, utils.getParametersValue)(parameters.lenBlock, "isIndefiniteForm", false);
				this.longFormUsed = (0, utils.getParametersValue)(parameters.lenBlock, "longFormUsed", false);
				this.length = (0, utils.getParametersValue)(parameters.lenBlock, "length", 0);
			} else {
				this.isIndefiniteForm = false;
				this.longFormUsed = false;
				this.length = 0;
			}
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "lengthBlock";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if (intBuffer.length === 0) {
				this.error = "Zero buffer length";
				return -1;
			}

			if (intBuffer[0] === 0xFF) {
				this.error = "Length block 0xFF is reserved by standard";
				return -1;
			}
			//endregion

			//region Check for length form type
			this.isIndefiniteForm = intBuffer[0] === 0x80;
			//endregion

			//region Stop working in case of indefinite length form
			if (this.isIndefiniteForm === true) {
				this.blockLength = 1;
				return inputOffset + this.blockLength;
			}
			//endregion

			//region Check is long form of length encoding using
			this.longFormUsed = !!(intBuffer[0] & 0x80);
			//endregion

			//region Stop working in case of short form of length value
			if (this.longFormUsed === false) {
				this.length = intBuffer[0];
				this.blockLength = 1;
				return inputOffset + this.blockLength;
			}
			//endregion

			//region Calculate length value in case of long form
			const count = intBuffer[0] & 0x7F;

			if (count > 8) // Too big length value
				{
					this.error = "Too big integer";
					return -1;
				}

			if (count + 1 > intBuffer.length) {
				this.error = "End of input reached before message was fully decoded";
				return -1;
			}

			const lengthBufferView = new Uint8Array(count);

			for (let i = 0; i < count; i++) lengthBufferView[i] = intBuffer[i + 1];

			if (lengthBufferView[count - 1] === 0x00) this.warnings.push("Needlessly long encoded length");

			this.length = (0, utils.utilFromBase)(lengthBufferView, 8);

			if (this.longFormUsed && this.length <= 127) this.warnings.push("Unneccesary usage of long length form");

			this.blockLength = count + 1;
			//endregion

			return inputOffset + this.blockLength; // Return current offset in input buffer
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			//region Initial variables
			let retBuf;
			let retView;
			//endregion

			if (this.length > 127) this.longFormUsed = true;

			if (this.isIndefiniteForm) {
				retBuf = new ArrayBuffer(1);

				if (sizeOnly === false) {
					retView = new Uint8Array(retBuf);
					retView[0] = 0x80;
				}

				return retBuf;
			}

			if (this.longFormUsed === true) {
				const encodedBuf = (0, utils.utilToBase)(this.length, 8);

				if (encodedBuf.byteLength > 127) {
					this.error = "Too big length";
					return new ArrayBuffer(0);
				}

				retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);

				if (sizeOnly === true) return retBuf;

				const encodedView = new Uint8Array(encodedBuf);
				retView = new Uint8Array(retBuf);

				retView[0] = encodedBuf.byteLength | 0x80;

				for (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];

				return retBuf;
			}

			retBuf = new ArrayBuffer(1);

			if (sizeOnly === false) {
				retView = new Uint8Array(retBuf);

				retView[0] = this.length;
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.blockName = this.constructor.blockName();
			object.isIndefiniteForm = this.isIndefiniteForm;
			object.longFormUsed = this.longFormUsed;
			object.length = this.length;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of value block class
	//**************************************************************************************
	class LocalValueBlock extends LocalBaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "valueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Throw an exception for a function which needs to be specified in extended classes
			throw TypeError("User need to make a specific function in a class which extends \"LocalValueBlock\"");
			//endregion
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			//region Throw an exception for a function which needs to be specified in extended classes
			throw TypeError("User need to make a specific function in a class which extends \"LocalValueBlock\"");
			//endregion
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic ASN.1 block class
	//**************************************************************************************
	class BaseBlock extends LocalBaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "BaseBlock" class
	  * @param {Object} [parameters={}]
	  * @property {Object} [primitiveSchema]
	  * @property {string} [name]
	  * @property {boolean} [optional]
	  * @param valueBlockType Type of value block
	  */
		constructor(parameters = {}, valueBlockType = LocalValueBlock) {
			super(parameters);

			if ("name" in parameters) this.name = parameters.name;
			if ("optional" in parameters) this.optional = parameters.optional;
			if ("primitiveSchema" in parameters) this.primitiveSchema = parameters.primitiveSchema;

			this.idBlock = new LocalIdentificationBlock(parameters);
			this.lenBlock = new LocalLengthBlock(parameters);
			this.valueBlock = new valueBlockType(parameters);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "BaseBlock";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			let retBuf;

			const idBlockBuf = this.idBlock.toBER(sizeOnly);
			const valueBlockSizeBuf = this.valueBlock.toBER(true);

			this.lenBlock.length = valueBlockSizeBuf.byteLength;
			const lenBlockBuf = this.lenBlock.toBER(sizeOnly);

			retBuf = (0, utils.utilConcatBuf)(idBlockBuf, lenBlockBuf);

			let valueBlockBuf;

			if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);

			retBuf = (0, utils.utilConcatBuf)(retBuf, valueBlockBuf);

			if (this.lenBlock.isIndefiniteForm === true) {
				const indefBuf = new ArrayBuffer(2);

				if (sizeOnly === false) {
					const indefView = new Uint8Array(indefBuf);

					indefView[0] = 0x00;
					indefView[1] = 0x00;
				}

				retBuf = (0, utils.utilConcatBuf)(retBuf, indefBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.idBlock = this.idBlock.toJSON();
			object.lenBlock = this.lenBlock.toJSON();
			object.valueBlock = this.valueBlock.toJSON();

			if ("name" in this) object.name = this.name;
			if ("optional" in this) object.optional = this.optional;
			if ("primitiveSchema" in this) object.primitiveSchema = this.primitiveSchema.toJSON();

			return object;
		}
		//**********************************************************************************
	}
	exports.BaseBlock = BaseBlock; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic block for all PRIMITIVE types
	//**************************************************************************************

	class LocalPrimitiveValueBlock extends LocalValueBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalPrimitiveValueBlock" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueBeforeDecode]
	  */
		constructor(parameters = {}) {
			super(parameters);

			//region Variables from "hexBlock" class
			if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);

			this.isHexOnly = (0, utils.getParametersValue)(parameters, "isHexOnly", true);
			//endregion
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if (intBuffer.length === 0) {
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Copy input buffer into internal buffer
			this.valueHex = new ArrayBuffer(intBuffer.length);
			const valueHexView = new Uint8Array(this.valueHex);

			for (let i = 0; i < intBuffer.length; i++) valueHexView[i] = intBuffer[i];
			//endregion

			this.blockLength = inputLength;

			return inputOffset + inputLength;
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "PrimitiveValueBlock";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.valueHex = (0, utils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);
			object.isHexOnly = this.isHexOnly;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Primitive extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "Primitive" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalPrimitiveValueBlock);

			this.idBlock.isConstructed = false;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "PRIMITIVE";
		}
		//**********************************************************************************
	}
	exports.Primitive = Primitive; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic block for all CONSTRUCTED types
	//**************************************************************************************

	class LocalConstructedValueBlock extends LocalValueBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalConstructedValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.value = (0, utils.getParametersValue)(parameters, "value", []);
			this.isIndefiniteForm = (0, utils.getParametersValue)(parameters, "isIndefiniteForm", false);
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Store initial offset and length
			const initialOffset = inputOffset;
			const initialLength = inputLength;
			//endregion

			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if (intBuffer.length === 0) {
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Aux function
			function checkLen(indefiniteLength, length) {
				if (indefiniteLength === true) return 1;

				return length;
			}
			//endregion

			let currentOffset = inputOffset;

			while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
				const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);
				if (returnObject.offset === -1) {
					this.error = returnObject.result.error;
					this.warnings.concat(returnObject.result.warnings);
					return -1;
				}

				currentOffset = returnObject.offset;

				this.blockLength += returnObject.result.blockLength;
				inputLength -= returnObject.result.blockLength;

				this.value.push(returnObject.result);

				if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;
			}

			if (this.isIndefiniteForm === true) {
				if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push("No EndOfContent block encoded");
			}

			//region Copy "inputBuffer" to "valueBeforeDecode"
			this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);
			//endregion

			return currentOffset;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			let retBuf = new ArrayBuffer(0);

			for (let i = 0; i < this.value.length; i++) {
				const valueBuf = this.value[i].toBER(sizeOnly);
				retBuf = (0, utils.utilConcatBuf)(retBuf, valueBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "ConstructedValueBlock";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.isIndefiniteForm = this.isIndefiniteForm;
			object.value = [];
			for (let i = 0; i < this.value.length; i++) object.value.push(this.value[i].toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Constructed extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "Constructed" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalConstructedValueBlock);

			this.idBlock.isConstructed = true;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "CONSTRUCTED";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
	}
	exports.Constructed = Constructed; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 EndOfContent type class
	//**************************************************************************************

	class LocalEndOfContentValueBlock extends LocalValueBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalEndOfContentValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number}
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region There is no "value block" for EndOfContent type and we need to return the same offset
			return inputOffset;
			//endregion
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			return new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "EndOfContentValueBlock";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class EndOfContent extends BaseBlock {
		//**********************************************************************************
		constructor(paramaters = {}) {
			super(paramaters, LocalEndOfContentValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 0; // EndOfContent
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "EndOfContent";
		}
		//**********************************************************************************
	}
	exports.EndOfContent = EndOfContent; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Boolean type class
	//**************************************************************************************

	class LocalBooleanValueBlock extends LocalValueBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalBooleanValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.value = (0, utils.getParametersValue)(parameters, "value", false);
			this.isHexOnly = (0, utils.getParametersValue)(parameters, "isHexOnly", false);

			if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);else {
				this.valueHex = new ArrayBuffer(1);
				if (this.value === true) {
					const view = new Uint8Array(this.valueHex);
					view[0] = 0xFF;
				}
			}
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			if (inputLength > 1) this.warnings.push("Boolean value encoded in more then 1 octet");

			this.isHexOnly = true;

			//region Copy input buffer to internal array
			this.valueHex = new ArrayBuffer(intBuffer.length);
			const view = new Uint8Array(this.valueHex);

			for (let i = 0; i < intBuffer.length; i++) view[i] = intBuffer[i];
			//endregion

			if (utils.utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;

			this.blockLength = inputLength;

			return inputOffset + inputLength;
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			return this.valueHex;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "BooleanValueBlock";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.value = this.value;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = (0, utils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Boolean extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "Boolean" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalBooleanValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 1; // Boolean
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Boolean";
		}
		//**********************************************************************************
	}
	exports.Boolean = Boolean; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Sequence and Set type classes
	//**************************************************************************************

	class Sequence extends Constructed {
		//**********************************************************************************
		/**
	  * Constructor for "Sequence" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 16; // Sequence
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Sequence";
		}
		//**********************************************************************************
	}
	exports.Sequence = Sequence; //**************************************************************************************

	class Set extends Constructed {
		//**********************************************************************************
		/**
	  * Constructor for "Set" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 17; // Set
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Set";
		}
		//**********************************************************************************
	}
	exports.Set = Set; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Null type class
	//**************************************************************************************

	class Null extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "Null" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalBaseBlock); // We will not have a call to "Null value block" because of specified "fromBER" and "toBER" functions

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 5; // Null
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Null";
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			if (this.lenBlock.length > 0) this.warnings.push("Non-zero length of value block for Null type");

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			this.blockLength += inputLength;

			if (inputOffset + inputLength > inputBuffer.byteLength) {
				this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
				return -1;
			}

			return inputOffset + inputLength;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			const retBuf = new ArrayBuffer(2);

			if (sizeOnly === true) return retBuf;

			const retView = new Uint8Array(retBuf);
			retView[0] = 0x05;
			retView[1] = 0x00;

			return retBuf;
		}
		//**********************************************************************************
	}
	exports.Null = Null; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 OctetString type class
	//**************************************************************************************

	class LocalOctetStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalOctetStringValueBlock" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.isConstructed = (0, utils.getParametersValue)(parameters, "isConstructed", false);
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			let resultOffset = 0;

			if (this.isConstructed === true) {
				this.isHexOnly = false;

				resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
				if (resultOffset === -1) return resultOffset;

				for (let i = 0; i < this.value.length; i++) {
					const currentBlockName = this.value[i].constructor.blockName();

					if (currentBlockName === EndOfContent.blockName()) {
						if (this.isIndefiniteForm === true) break;else {
							this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
							return -1;
						}
					}

					if (currentBlockName !== OctetString.blockName()) {
						this.error = "OCTET STRING may consists of OCTET STRINGs only";
						return -1;
					}
				}
			} else {
				this.isHexOnly = true;

				resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
				this.blockLength = inputLength;
			}

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);

			let retBuf = new ArrayBuffer(this.valueHex.byteLength);

			if (sizeOnly === true) return retBuf;

			if (this.valueHex.byteLength === 0) return retBuf;

			retBuf = this.valueHex.slice(0);

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "OctetStringValueBlock";
		}
		//**********************************************************************************
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.isConstructed = this.isConstructed;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = (0, utils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class OctetString extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "OctetString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalOctetStringValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 4; // OctetString
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			this.valueBlock.isConstructed = this.idBlock.isConstructed;
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			//region Ability to encode empty OCTET STRING
			if (inputLength === 0) {
				if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

				if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

				return inputOffset;
			}
			//endregion

			return super.fromBER(inputBuffer, inputOffset, inputLength);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "OctetString";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Checking that two OCTETSTRINGs are equal
	  * @param {OctetString} octetString
	  */
		isEqual(octetString) {
			//region Check input type
			if (octetString instanceof OctetString === false) return false;
			//endregion

			//region Compare two JSON strings
			if (JSON.stringify(this) !== JSON.stringify(octetString)) return false;
			//endregion

			return true;
		}
		//**********************************************************************************
	}
	exports.OctetString = OctetString; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 BitString type class
	//**************************************************************************************

	class LocalBitStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalBitStringValueBlock" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.unusedBits = (0, utils.getParametersValue)(parameters, "unusedBits", 0);
			this.isConstructed = (0, utils.getParametersValue)(parameters, "isConstructed", false);
			this.blockLength = this.valueHex.byteLength;
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Ability to decode zero-length BitString value
			if (inputLength === 0) return inputOffset;
			//endregion

			let resultOffset = -1;

			//region If the BISTRING supposed to be a constructed value
			if (this.isConstructed === true) {
				resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
				if (resultOffset === -1) return resultOffset;

				for (let i = 0; i < this.value.length; i++) {
					const currentBlockName = this.value[i].constructor.blockName();

					if (currentBlockName === EndOfContent.blockName()) {
						if (this.isIndefiniteForm === true) break;else {
							this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
							return -1;
						}
					}

					if (currentBlockName !== BitString.blockName()) {
						this.error = "BIT STRING may consists of BIT STRINGs only";
						return -1;
					}

					if (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {
						this.error = "Usign of \"unused bits\" inside constructive BIT STRING allowed for least one only";
						return -1;
					}

					this.unusedBits = this.value[i].valueBlock.unusedBits;
					if (this.unusedBits > 7) {
						this.error = "Unused bits for BitString must be in range 0-7";
						return -1;
					}
				}

				return resultOffset;
			}
			//endregion
			//region If the BitString supposed to be a primitive value
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

			this.unusedBits = intBuffer[0];

			if (this.unusedBits > 7) {
				this.error = "Unused bits for BitString must be in range 0-7";
				return -1;
			}

			//region Copy input buffer to internal buffer
			this.valueHex = new ArrayBuffer(intBuffer.length - 1);
			const view = new Uint8Array(this.valueHex);
			for (let i = 0; i < inputLength - 1; i++) view[i] = intBuffer[i + 1];
			//endregion

			this.blockLength = intBuffer.length;

			return inputOffset + inputLength;
			//endregion
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);

			if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);

			if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);

			const curView = new Uint8Array(this.valueHex);

			const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
			const retView = new Uint8Array(retBuf);

			retView[0] = this.unusedBits;

			for (let i = 0; i < this.valueHex.byteLength; i++) retView[i + 1] = curView[i];

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "BitStringValueBlock";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.unusedBits = this.unusedBits;
			object.isConstructed = this.isConstructed;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = (0, utils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class BitString extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "BitString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalBitStringValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 3; // BitString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "BitString";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			//region Ability to encode empty BitString
			if (inputLength === 0) return inputOffset;
			//endregion

			this.valueBlock.isConstructed = this.idBlock.isConstructed;
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			return super.fromBER(inputBuffer, inputOffset, inputLength);
		}
		//**********************************************************************************
		/**
	  * Checking that two BITSTRINGs are equal
	  * @param {BitString} bitString
	  */
		isEqual(bitString) {
			//region Check input type
			if (bitString instanceof BitString === false) return false;
			//endregion

			//region Compare two JSON strings
			if (JSON.stringify(this) !== JSON.stringify(bitString)) return false;
			//endregion

			return true;
		}
		//**********************************************************************************
	}
	exports.BitString = BitString; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Integer type class
	//**************************************************************************************
	/**
	 * @extends LocalValueBlock
	 */

	class LocalIntegerValueBlock extends LocalHexBlock(LocalValueBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalIntegerValueBlock" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters);

			if ("value" in parameters) this.valueDec = parameters.value;
		}
		//**********************************************************************************
		/**
	  * Setter for "valueHex"
	  * @param {ArrayBuffer} _value
	  */
		set valueHex(_value) {
			this._valueHex = _value.slice(0);

			if (_value.byteLength >= 4) {
				this.warnings.push("Too big Integer for decoding, hex only");
				this.isHexOnly = true;
				this._valueDec = 0;
			} else {
				this.isHexOnly = false;

				if (_value.byteLength > 0) this._valueDec = utils.utilDecodeTC.call(this);
			}
		}
		//**********************************************************************************
		/**
	  * Getter for "valueHex"
	  * @returns {ArrayBuffer}
	  */
		get valueHex() {
			return this._valueHex;
		}
		//**********************************************************************************
		/**
	  * Getter for "valueDec"
	  * @param {number} _value
	  */
		set valueDec(_value) {
			this._valueDec = _value;

			this.isHexOnly = false;
			this._valueHex = (0, utils.utilEncodeTC)(_value);
		}
		//**********************************************************************************
		/**
	  * Getter for "valueDec"
	  * @returns {number}
	  */
		get valueDec() {
			return this._valueDec;
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from DER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @param {number} [expectedLength=0] Expected length of converted "valueHex" buffer
	  * @returns {number} Offset after least decoded byte
	  */
		fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
			const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
			if (offset === -1) return offset;

			const view = new Uint8Array(this._valueHex);

			if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {
				const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
				const updatedView = new Uint8Array(updatedValueHex);

				updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

				this._valueHex = updatedValueHex.slice(0);
			} else {
				if (expectedLength !== 0) {
					if (this._valueHex.byteLength < expectedLength) {
						if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;

						const updatedValueHex = new ArrayBuffer(expectedLength);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView.set(view, expectedLength - this._valueHex.byteLength);

						this._valueHex = updatedValueHex.slice(0);
					}
				}
			}

			return offset;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toDER(sizeOnly = false) {
			const view = new Uint8Array(this._valueHex);

			switch (true) {
				case (view[0] & 0x80) !== 0:
					{
						const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView[0] = 0x00;
						updatedView.set(view, 1);

						this._valueHex = updatedValueHex.slice(0);
					}
					break;
				case view[0] === 0x00 && (view[1] & 0x80) === 0:
					{
						const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

						this._valueHex = updatedValueHex.slice(0);
					}
					break;
				default:
			}

			return this.toBER(sizeOnly);
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
			if (resultOffset === -1) return resultOffset;

			this.blockLength = inputLength;

			return inputOffset + inputLength;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			//noinspection JSCheckFunctionSignatures
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "IntegerValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.valueDec = this.valueDec;

			return object;
		}
		//**********************************************************************************
		/**
	  * Convert current value to decimal string representation
	  */
		toString() {
			//region Aux functions
			function viewAdd(first, second) {
				//region Initial variables
				const c = new Uint8Array([0]);

				let firstView = new Uint8Array(first);
				let secondView = new Uint8Array(second);

				let firstViewCopy = firstView.slice(0);
				const firstViewCopyLength = firstViewCopy.length - 1;
				let secondViewCopy = secondView.slice(0);
				const secondViewCopyLength = secondViewCopy.length - 1;

				let value = 0;

				const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;

				let counter = 0;
				//endregion

				for (let i = max; i >= 0; i--, counter++) {
					switch (true) {
						case counter < secondViewCopy.length:
							value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
							break;
						default:
							value = firstViewCopy[firstViewCopyLength - counter] + c[0];
					}

					c[0] = value / 10;

					switch (true) {
						case counter >= firstViewCopy.length:
							firstViewCopy = (0, utils.utilConcatView)(new Uint8Array([value % 10]), firstViewCopy);
							break;
						default:
							firstViewCopy[firstViewCopyLength - counter] = value % 10;
					}
				}

				if (c[0] > 0) firstViewCopy = (0, utils.utilConcatView)(c, firstViewCopy);

				return firstViewCopy.slice(0);
			}

			function power2(n) {
				if (n >= powers2.length) {
					for (let p = powers2.length; p <= n; p++) {
						const c = new Uint8Array([0]);
						let digits = powers2[p - 1].slice(0);

						for (let i = digits.length - 1; i >= 0; i--) {
							const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
							c[0] = newValue[0] / 10;
							digits[i] = newValue[0] % 10;
						}

						if (c[0] > 0) digits = (0, utils.utilConcatView)(c, digits);

						powers2.push(digits);
					}
				}

				return powers2[n];
			}

			function viewSub(first, second) {
				//region Initial variables
				let b = 0;

				let firstView = new Uint8Array(first);
				let secondView = new Uint8Array(second);

				let firstViewCopy = firstView.slice(0);
				const firstViewCopyLength = firstViewCopy.length - 1;
				let secondViewCopy = secondView.slice(0);
				const secondViewCopyLength = secondViewCopy.length - 1;

				let value;

				let counter = 0;
				//endregion

				for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
					value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;

					switch (true) {
						case value < 0:
							b = 1;
							firstViewCopy[firstViewCopyLength - counter] = value + 10;
							break;
						default:
							b = 0;
							firstViewCopy[firstViewCopyLength - counter] = value;
					}
				}

				if (b > 0) {
					for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {
						value = firstViewCopy[firstViewCopyLength - counter] - b;

						if (value < 0) {
							b = 1;
							firstViewCopy[firstViewCopyLength - counter] = value + 10;
						} else {
							b = 0;
							firstViewCopy[firstViewCopyLength - counter] = value;
							break;
						}
					}
				}

				return firstViewCopy.slice();
			}
			//endregion

			//region Initial variables
			const firstBit = this._valueHex.byteLength * 8 - 1;

			let digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);
			let bitNumber = 0;
			let currentByte;

			const asn1View = new Uint8Array(this._valueHex);

			let result = "";

			let flag = false;
			//endregion

			//region Calculate number
			for (let byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {
				currentByte = asn1View[byteNumber];

				for (let i = 0; i < 8; i++) {
					if ((currentByte & 1) === 1) {
						switch (bitNumber) {
							case firstBit:
								digits = viewSub(power2(bitNumber), digits);
								result = "-";
								break;
							default:
								digits = viewAdd(digits, power2(bitNumber));
						}
					}

					bitNumber++;
					currentByte >>= 1;
				}
			}
			//endregion

			//region Print number
			for (let i = 0; i < digits.length; i++) {
				if (digits[i]) flag = true;

				if (flag) result += digitsString.charAt(digits[i]);
			}

			if (flag === false) result += digitsString.charAt(0);
			//endregion

			return result;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Integer extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "Integer" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalIntegerValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 2; // Integer
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Integer";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Compare two Integer object, or Integer and ArrayBuffer objects
	  * @param {!Integer|ArrayBuffer} otherValue
	  * @returns {boolean}
	  */
		isEqual(otherValue) {
			if (otherValue instanceof Integer) {
				if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers
					return (0, utils.isEqualBuffer)(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);

				if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;

				return false;
			}

			if (otherValue instanceof ArrayBuffer) return (0, utils.isEqualBuffer)(this.valueBlock.valueHex, otherValue);

			return false;
		}
		//**********************************************************************************
		/**
	  * Convert current Integer value from BER into DER format
	  * @returns {Integer}
	  */
		convertToDER() {
			const integer = new Integer({ valueHex: this.valueBlock.valueHex });
			integer.valueBlock.toDER();

			return integer;
		}
		//**********************************************************************************
		/**
	  * Convert current Integer value from DER to BER format
	  * @returns {Integer}
	  */
		convertFromDER() {
			const expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;
			const integer = new Integer({ valueHex: this.valueBlock.valueHex });
			integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);

			return integer;
		}
		//**********************************************************************************
	}
	exports.Integer = Integer; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Enumerated type class
	//**************************************************************************************

	class Enumerated extends Integer {
		//**********************************************************************************
		/**
	  * Constructor for "Enumerated" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 10; // Enumerated
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Enumerated";
		}
		//**********************************************************************************
	}
	exports.Enumerated = Enumerated; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 ObjectIdentifier type class
	//**************************************************************************************

	class LocalSidValueBlock extends LocalHexBlock(LocalBaseBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalSidValueBlock" class
	  * @param {Object} [parameters={}]
	  * @property {number} [valueDec]
	  * @property {boolean} [isFirstSid]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.valueDec = (0, utils.getParametersValue)(parameters, "valueDec", -1);
			this.isFirstSid = (0, utils.getParametersValue)(parameters, "isFirstSid", false);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "sidBlock";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			if (inputLength === 0) return inputOffset;

			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if ((0, utils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1;
			//endregion

			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

			this.valueHex = new ArrayBuffer(inputLength);
			let view = new Uint8Array(this.valueHex);

			for (let i = 0; i < inputLength; i++) {
				view[i] = intBuffer[i] & 0x7F;

				this.blockLength++;

				if ((intBuffer[i] & 0x80) === 0x00) break;
			}

			//region Ajust size of valueHex buffer
			const tempValueHex = new ArrayBuffer(this.blockLength);
			const tempView = new Uint8Array(tempValueHex);

			for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i];

			//noinspection JSCheckFunctionSignatures
			this.valueHex = tempValueHex.slice(0);
			view = new Uint8Array(this.valueHex);
			//endregion

			if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
				this.error = "End of input reached before message was fully decoded";
				return -1;
			}

			if (view[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");

			if (this.blockLength <= 8) this.valueDec = (0, utils.utilFromBase)(view, 7);else {
				this.isHexOnly = true;
				this.warnings.push("Too big SID for decoding, hex only");
			}

			return inputOffset + this.blockLength;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			//region Initial variables
			let retBuf;
			let retView;
			//endregion

			if (this.isHexOnly) {
				if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);

				const curView = new Uint8Array(this.valueHex);

				retBuf = new ArrayBuffer(this.blockLength);
				retView = new Uint8Array(retBuf);

				for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;

				retView[this.blockLength - 1] = curView[this.blockLength - 1];

				return retBuf;
			}

			const encodedBuf = (0, utils.utilToBase)(this.valueDec, 7);
			if (encodedBuf.byteLength === 0) {
				this.error = "Error during encoding SID value";
				return new ArrayBuffer(0);
			}

			retBuf = new ArrayBuffer(encodedBuf.byteLength);

			if (sizeOnly === false) {
				const encodedView = new Uint8Array(encodedBuf);
				retView = new Uint8Array(retBuf);

				for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;

				retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Create string representation of current SID block
	  * @returns {string}
	  */
		toString() {
			let result = "";

			if (this.isHexOnly === true) result = (0, utils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {
				if (this.isFirstSid) {
					let sidValue = this.valueDec;

					if (this.valueDec <= 39) result = "0.";else {
						if (this.valueDec <= 79) {
							result = "1.";
							sidValue -= 40;
						} else {
							result = "2.";
							sidValue -= 80;
						}
					}

					result += sidValue.toString();
				} else result = this.valueDec.toString();
			}

			return result;
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.valueDec = this.valueDec;
			object.isFirstSid = this.isFirstSid;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class LocalObjectIdentifierValueBlock extends LocalValueBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalObjectIdentifierValueBlock" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.fromString((0, utils.getParametersValue)(parameters, "value", ""));
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			let resultOffset = inputOffset;

			while (inputLength > 0) {
				const sidBlock = new LocalSidValueBlock();
				resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
				if (resultOffset === -1) {
					this.blockLength = 0;
					this.error = sidBlock.error;
					return resultOffset;
				}

				if (this.value.length === 0) sidBlock.isFirstSid = true;

				this.blockLength += sidBlock.blockLength;
				inputLength -= sidBlock.blockLength;

				this.value.push(sidBlock);
			}

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			let retBuf = new ArrayBuffer(0);

			for (let i = 0; i < this.value.length; i++) {
				const valueBuf = this.value[i].toBER(sizeOnly);
				if (valueBuf.byteLength === 0) {
					this.error = this.value[i].error;
					return new ArrayBuffer(0);
				}

				retBuf = (0, utils.utilConcatBuf)(retBuf, valueBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
	  * Create "LocalObjectIdentifierValueBlock" class from string
	  * @param {string} string Input string to convert from
	  * @returns {boolean}
	  */
		fromString(string) {
			this.value = []; // Clear existing SID values

			let pos1 = 0;
			let pos2 = 0;

			let sid = "";

			let flag = false;

			do {
				pos2 = string.indexOf(".", pos1);
				if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);

				pos1 = pos2 + 1;

				if (flag) {
					const sidBlock = this.value[0];

					let plus = 0;

					switch (sidBlock.valueDec) {
						case 0:
							break;
						case 1:
							plus = 40;
							break;
						case 2:
							plus = 80;
							break;
						default:
							this.value = []; // clear SID array
							return false; // ???
					}

					const parsedSID = parseInt(sid, 10);
					if (isNaN(parsedSID)) return true;

					sidBlock.valueDec = parsedSID + plus;

					flag = false;
				} else {
					const sidBlock = new LocalSidValueBlock();
					sidBlock.valueDec = parseInt(sid, 10);
					if (isNaN(sidBlock.valueDec)) return true;

					if (this.value.length === 0) {
						sidBlock.isFirstSid = true;
						flag = true;
					}

					this.value.push(sidBlock);
				}
			} while (pos2 !== -1);

			return true;
		}
		//**********************************************************************************
		/**
	  * Converts "LocalObjectIdentifierValueBlock" class to string
	  * @returns {string}
	  */
		toString() {
			let result = "";
			let isHexOnly = false;

			for (let i = 0; i < this.value.length; i++) {
				isHexOnly = this.value[i].isHexOnly;

				let sidStr = this.value[i].toString();

				if (i !== 0) result = `${result}.`;

				if (isHexOnly) {
					sidStr = `{${sidStr}}`;

					if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;
				} else result += sidStr;
			}

			return result;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "ObjectIdentifierValueBlock";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.value = this.toString();
			object.sidArray = [];
			for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class ObjectIdentifier extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "ObjectIdentifier" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalObjectIdentifierValueBlock);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "ObjectIdentifier";
		}
		//**********************************************************************************
	}
	exports.ObjectIdentifier = ObjectIdentifier; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of all string's classes
	//**************************************************************************************

	class LocalUtf8StringValueBlock extends LocalHexBlock(LocalBaseBlock) {
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Constructor for "LocalUtf8StringValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.isHexOnly = true;
			this.value = ""; // String representation of decoded ArrayBuffer
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Utf8StringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class Utf8String extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "Utf8String" class
	  * @param {Object} [parameters={}]
	  * @property {ArrayBuffer} [valueHex]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalUtf8StringValueBlock);

			if ("value" in parameters) this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 12; // Utf8String
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Utf8String";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Function converting ArrayBuffer into ASN.1 internal string
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  */
		fromBuffer(inputBuffer) {
			this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));

			try {
				//noinspection JSDeprecatedSymbols
				this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));
			} catch (ex) {
				this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
			}
		}
		//**********************************************************************************
		/**
	  * Function converting JavaScript string into ASN.1 internal class
	  * @param {!string} inputString ASN.1 BER encoded array
	  */
		fromString(inputString) {
			//noinspection JSDeprecatedSymbols
			const str = unescape(encodeURIComponent(inputString));
			const strLen = str.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLen);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for (let i = 0; i < strLen; i++) view[i] = str.charCodeAt(i);

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	exports.Utf8String = Utf8String; //**************************************************************************************
	/**
	 * @extends LocalBaseBlock
	 * @extends LocalHexBlock
	 */

	class LocalBmpStringValueBlock extends LocalHexBlock(LocalBaseBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalBmpStringValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.isHexOnly = true;
			this.value = "";
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "BmpStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class BmpString extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "BmpString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalBmpStringValueBlock);

			if ("value" in parameters) this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 30; // BmpString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "BmpString";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Function converting ArrayBuffer into ASN.1 internal string
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  */
		fromBuffer(inputBuffer) {
			//noinspection JSCheckFunctionSignatures
			const copyBuffer = inputBuffer.slice(0);
			const valueView = new Uint8Array(copyBuffer);

			for (let i = 0; i < valueView.length; i += 2) {
				const temp = valueView[i];

				valueView[i] = valueView[i + 1];
				valueView[i + 1] = temp;
			}

			this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));
		}
		//**********************************************************************************
		/**
	  * Function converting JavaScript string into ASN.1 internal class
	  * @param {!string} inputString ASN.1 BER encoded array
	  */
		fromString(inputString) {
			const strLength = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);
			const valueHexView = new Uint8Array(this.valueBlock.valueHex);

			for (let i = 0; i < strLength; i++) {
				const codeBuf = (0, utils.utilToBase)(inputString.charCodeAt(i), 8);
				const codeView = new Uint8Array(codeBuf);
				if (codeView.length > 2) continue;

				const dif = 2 - codeView.length;

				for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 2 + j + dif] = codeView[j];
			}

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	exports.BmpString = BmpString; //**************************************************************************************

	class LocalUniversalStringValueBlock extends LocalHexBlock(LocalBaseBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalUniversalStringValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.isHexOnly = true;
			this.value = "";
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "UniversalStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class UniversalString extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "UniversalString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalUniversalStringValueBlock);

			if ("value" in parameters) this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 28; // UniversalString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "UniversalString";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Function converting ArrayBuffer into ASN.1 internal string
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  */
		fromBuffer(inputBuffer) {
			//noinspection JSCheckFunctionSignatures
			const copyBuffer = inputBuffer.slice(0);
			const valueView = new Uint8Array(copyBuffer);

			for (let i = 0; i < valueView.length; i += 4) {
				valueView[i] = valueView[i + 3];
				valueView[i + 1] = valueView[i + 2];
				valueView[i + 2] = 0x00;
				valueView[i + 3] = 0x00;
			}

			this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
		}
		//**********************************************************************************
		/**
	  * Function converting JavaScript string into ASN.1 internal class
	  * @param {!string} inputString ASN.1 BER encoded array
	  */
		fromString(inputString) {
			const strLength = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);
			const valueHexView = new Uint8Array(this.valueBlock.valueHex);

			for (let i = 0; i < strLength; i++) {
				const codeBuf = (0, utils.utilToBase)(inputString.charCodeAt(i), 8);
				const codeView = new Uint8Array(codeBuf);
				if (codeView.length > 4) continue;

				const dif = 4 - codeView.length;

				for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];
			}

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	exports.UniversalString = UniversalString; //**************************************************************************************

	class LocalSimpleStringValueBlock extends LocalHexBlock(LocalBaseBlock) {
		//**********************************************************************************
		/**
	  * Constructor for "LocalSimpleStringValueBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.value = "";
			this.isHexOnly = true;
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "SimpleStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class LocalSimpleStringBlock extends BaseBlock {
		//**********************************************************************************
		/**
	  * Constructor for "LocalSimpleStringBlock" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters, LocalSimpleStringValueBlock);

			if ("value" in parameters) this.fromString(parameters.value);
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "SIMPLESTRING";
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Function converting ArrayBuffer into ASN.1 internal string
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  */
		fromBuffer(inputBuffer) {
			this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
		}
		//**********************************************************************************
		/**
	  * Function converting JavaScript string into ASN.1 internal class
	  * @param {!string} inputString ASN.1 BER encoded array
	  */
		fromString(inputString) {
			const strLen = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLen);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class NumericString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "NumericString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 18; // NumericString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "NumericString";
		}
		//**********************************************************************************
	}
	exports.NumericString = NumericString; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class PrintableString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "PrintableString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 19; // PrintableString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "PrintableString";
		}
		//**********************************************************************************
	}
	exports.PrintableString = PrintableString; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class TeletexString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "TeletexString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 20; // TeletexString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "TeletexString";
		}
		//**********************************************************************************
	}
	exports.TeletexString = TeletexString; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class VideotexString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "VideotexString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 21; // VideotexString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "VideotexString";
		}
		//**********************************************************************************
	}
	exports.VideotexString = VideotexString; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class IA5String extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "IA5String" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 22; // IA5String
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "IA5String";
		}
		//**********************************************************************************
	}
	exports.IA5String = IA5String; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class GraphicString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "GraphicString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 25; // GraphicString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "GraphicString";
		}
		//**********************************************************************************
	}
	exports.GraphicString = GraphicString; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class VisibleString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "VisibleString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 26; // VisibleString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "VisibleString";
		}
		//**********************************************************************************
	}
	exports.VisibleString = VisibleString; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class GeneralString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "GeneralString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 27; // GeneralString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "GeneralString";
		}
		//**********************************************************************************
	}
	exports.GeneralString = GeneralString; //**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */

	class CharacterString extends LocalSimpleStringBlock {
		//**********************************************************************************
		/**
	  * Constructor for "CharacterString" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 29; // CharacterString
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "CharacterString";
		}
		//**********************************************************************************
	}
	exports.CharacterString = CharacterString; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of all date and time classes
	//**************************************************************************************
	/**
	 * @extends VisibleString
	 */

	class UTCTime extends VisibleString {
		//**********************************************************************************
		/**
	  * Constructor for "UTCTime" class
	  * @param {Object} [parameters={}]
	  * @property {string} [value] String representatio of the date
	  * @property {Date} [valueDate] JavaScript "Date" object
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.year = 0;
			this.month = 0;
			this.day = 0;
			this.hour = 0;
			this.minute = 0;
			this.second = 0;

			//region Create UTCTime from ASN.1 UTC string value
			if ("value" in parameters) {
				this.fromString(parameters.value);

				this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
				const view = new Uint8Array(this.valueBlock.valueHex);

				for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);
			}
			//endregion
			//region Create GeneralizedTime from JavaScript Date type
			if ("valueDate" in parameters) {
				this.fromDate(parameters.valueDate);
				this.valueBlock.valueHex = this.toBuffer();
			}
			//endregion

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 23; // UTCTime
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Function converting ArrayBuffer into ASN.1 internal string
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  */
		fromBuffer(inputBuffer) {
			this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
		}
		//**********************************************************************************
		/**
	  * Function converting ASN.1 internal string into ArrayBuffer
	  * @returns {ArrayBuffer}
	  */
		toBuffer() {
			const str = this.toString();

			const buffer = new ArrayBuffer(str.length);
			const view = new Uint8Array(buffer);

			for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);

			return buffer;
		}
		//**********************************************************************************
		/**
	  * Function converting "Date" object into ASN.1 internal string
	  * @param {!Date} inputDate JavaScript "Date" object
	  */
		fromDate(inputDate) {
			this.year = inputDate.getUTCFullYear();
			this.month = inputDate.getUTCMonth() + 1;
			this.day = inputDate.getUTCDate();
			this.hour = inputDate.getUTCHours();
			this.minute = inputDate.getUTCMinutes();
			this.second = inputDate.getUTCSeconds();
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Function converting ASN.1 internal string into "Date" object
	  * @returns {Date}
	  */
		toDate() {
			return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
		}
		//**********************************************************************************
		/**
	  * Function converting JavaScript string into ASN.1 internal class
	  * @param {!string} inputString ASN.1 BER encoded array
	  */
		fromString(inputString) {
			//region Parse input string
			const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
			const parserArray = parser.exec(inputString);
			if (parserArray === null) {
				this.error = "Wrong input string for convertion";
				return;
			}
			//endregion

			//region Store parsed values
			const year = parseInt(parserArray[1], 10);
			if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;

			this.month = parseInt(parserArray[2], 10);
			this.day = parseInt(parserArray[3], 10);
			this.hour = parseInt(parserArray[4], 10);
			this.minute = parseInt(parserArray[5], 10);
			this.second = parseInt(parserArray[6], 10);
			//endregion
		}
		//**********************************************************************************
		/**
	  * Function converting ASN.1 internal class into JavaScript string
	  * @returns {string}
	  */
		toString() {
			const outputArray = new Array(7);

			outputArray[0] = (0, utils.padNumber)(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
			outputArray[1] = (0, utils.padNumber)(this.month, 2);
			outputArray[2] = (0, utils.padNumber)(this.day, 2);
			outputArray[3] = (0, utils.padNumber)(this.hour, 2);
			outputArray[4] = (0, utils.padNumber)(this.minute, 2);
			outputArray[5] = (0, utils.padNumber)(this.second, 2);
			outputArray[6] = "Z";

			return outputArray.join("");
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "UTCTime";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.year = this.year;
			object.month = this.month;
			object.day = this.day;
			object.hour = this.hour;
			object.minute = this.minute;
			object.second = this.second;

			return object;
		}
		//**********************************************************************************
	}
	exports.UTCTime = UTCTime; //**************************************************************************************
	/**
	 * @extends VisibleString
	 */

	class GeneralizedTime extends VisibleString {
		//**********************************************************************************
		/**
	  * Constructor for "GeneralizedTime" class
	  * @param {Object} [parameters={}]
	  * @property {string} [value] String representatio of the date
	  * @property {Date} [valueDate] JavaScript "Date" object
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.year = 0;
			this.month = 0;
			this.day = 0;
			this.hour = 0;
			this.minute = 0;
			this.second = 0;
			this.millisecond = 0;

			//region Create UTCTime from ASN.1 UTC string value
			if ("value" in parameters) {
				this.fromString(parameters.value);

				this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
				const view = new Uint8Array(this.valueBlock.valueHex);

				for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);
			}
			//endregion
			//region Create GeneralizedTime from JavaScript Date type
			if ("valueDate" in parameters) {
				this.fromDate(parameters.valueDate);
				this.valueBlock.valueHex = this.toBuffer();
			}
			//endregion

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 24; // GeneralizedTime
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
			if (resultOffset === -1) {
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;

			if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;

			if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
	  * Function converting ArrayBuffer into ASN.1 internal string
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  */
		fromBuffer(inputBuffer) {
			this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
		}
		//**********************************************************************************
		/**
	  * Function converting ASN.1 internal string into ArrayBuffer
	  * @returns {ArrayBuffer}
	  */
		toBuffer() {
			const str = this.toString();

			const buffer = new ArrayBuffer(str.length);
			const view = new Uint8Array(buffer);

			for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);

			return buffer;
		}
		//**********************************************************************************
		/**
	  * Function converting "Date" object into ASN.1 internal string
	  * @param {!Date} inputDate JavaScript "Date" object
	  */
		fromDate(inputDate) {
			this.year = inputDate.getUTCFullYear();
			this.month = inputDate.getUTCMonth() + 1;
			this.day = inputDate.getUTCDate();
			this.hour = inputDate.getUTCHours();
			this.minute = inputDate.getUTCMinutes();
			this.second = inputDate.getUTCSeconds();
			this.millisecond = inputDate.getUTCMilliseconds();
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
	  * Function converting ASN.1 internal string into "Date" object
	  * @returns {Date}
	  */
		toDate() {
			return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
		}
		//**********************************************************************************
		/**
	  * Function converting JavaScript string into ASN.1 internal class
	  * @param {!string} inputString ASN.1 BER encoded array
	  */
		fromString(inputString) {
			//region Initial variables
			let isUTC = false;

			let timeString = "";
			let dateTimeString = "";
			let fractionPart = 0;

			let parser;

			let hourDifference = 0;
			let minuteDifference = 0;
			//endregion

			//region Convert as UTC time
			if (inputString[inputString.length - 1] === "Z") {
				timeString = inputString.substr(0, inputString.length - 1);

				isUTC = true;
			}
			//endregion
			//region Convert as local time
			else {
					//noinspection JSPrimitiveTypeWrapperUsage
					const number = new Number(inputString[inputString.length - 1]);

					if (isNaN(number.valueOf())) throw new Error("Wrong input string for convertion");

					timeString = inputString;
				}
			//endregion

			//region Check that we do not have a "+" and "-" symbols inside UTC time
			if (isUTC) {
				if (timeString.indexOf("+") !== -1) throw new Error("Wrong input string for convertion");

				if (timeString.indexOf("-") !== -1) throw new Error("Wrong input string for convertion");
			}
			//endregion
			//region Get "UTC time difference" in case of local time
			else {
					let multiplier = 1;
					let differencePosition = timeString.indexOf("+");
					let differenceString = "";

					if (differencePosition === -1) {
						differencePosition = timeString.indexOf("-");
						multiplier = -1;
					}

					if (differencePosition !== -1) {
						differenceString = timeString.substr(differencePosition + 1);
						timeString = timeString.substr(0, differencePosition);

						if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error("Wrong input string for convertion");

						//noinspection JSPrimitiveTypeWrapperUsage
						let number = new Number(differenceString.substr(0, 2));

						if (isNaN(number.valueOf())) throw new Error("Wrong input string for convertion");

						hourDifference = multiplier * number;

						if (differenceString.length === 4) {
							//noinspection JSPrimitiveTypeWrapperUsage
							number = new Number(differenceString.substr(2, 2));

							if (isNaN(number.valueOf())) throw new Error("Wrong input string for convertion");

							minuteDifference = multiplier * number;
						}
					}
				}
			//endregion

			//region Get position of fraction point
			let fractionPointPosition = timeString.indexOf("."); // Check for "full stop" symbol
			if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(","); // Check for "comma" symbol
			//endregion

			//region Get fraction part
			if (fractionPointPosition !== -1) {
				//noinspection JSPrimitiveTypeWrapperUsage
				const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);

				if (isNaN(fractionPartCheck.valueOf())) throw new Error("Wrong input string for convertion");

				fractionPart = fractionPartCheck.valueOf();

				dateTimeString = timeString.substr(0, fractionPointPosition);
			} else dateTimeString = timeString;
			//endregion

			//region Parse internal date
			switch (true) {
				case dateTimeString.length === 8:
					// "YYYYMMDD"
					parser = /(\d{4})(\d{2})(\d{2})/ig;
					if (fractionPointPosition !== -1) throw new Error("Wrong input string for convertion"); // Here we should not have a "fraction point"
					break;
				case dateTimeString.length === 10:
					// "YYYYMMDDHH"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;

					if (fractionPointPosition !== -1) {
						let fractionResult = 60 * fractionPart;
						this.minute = Math.floor(fractionResult);

						fractionResult = 60 * (fractionResult - this.minute);
						this.second = Math.floor(fractionResult);

						fractionResult = 1000 * (fractionResult - this.second);
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				case dateTimeString.length === 12:
					// "YYYYMMDDHHMM"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

					if (fractionPointPosition !== -1) {
						let fractionResult = 60 * fractionPart;
						this.second = Math.floor(fractionResult);

						fractionResult = 1000 * (fractionResult - this.second);
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				case dateTimeString.length === 14:
					// "YYYYMMDDHHMMSS"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

					if (fractionPointPosition !== -1) {
						const fractionResult = 1000 * fractionPart;
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				default:
					throw new Error("Wrong input string for convertion");
			}
			//endregion

			//region Put parsed values at right places
			const parserArray = parser.exec(dateTimeString);
			if (parserArray === null) throw new Error("Wrong input string for convertion");

			for (let j = 1; j < parserArray.length; j++) {
				switch (j) {
					case 1:
						this.year = parseInt(parserArray[j], 10);
						break;
					case 2:
						this.month = parseInt(parserArray[j], 10);
						break;
					case 3:
						this.day = parseInt(parserArray[j], 10);
						break;
					case 4:
						this.hour = parseInt(parserArray[j], 10) + hourDifference;
						break;
					case 5:
						this.minute = parseInt(parserArray[j], 10) + minuteDifference;
						break;
					case 6:
						this.second = parseInt(parserArray[j], 10);
						break;
					default:
						throw new Error("Wrong input string for convertion");
				}
			}
			//endregion

			//region Get final date
			if (isUTC === false) {
				const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);

				this.year = tempDate.getUTCFullYear();
				this.month = tempDate.getUTCMonth();
				this.day = tempDate.getUTCDay();
				this.hour = tempDate.getUTCHours();
				this.minute = tempDate.getUTCMinutes();
				this.second = tempDate.getUTCSeconds();
				this.millisecond = tempDate.getUTCMilliseconds();
			}
			//endregion
		}
		//**********************************************************************************
		/**
	  * Function converting ASN.1 internal class into JavaScript string
	  * @returns {string}
	  */
		toString() {
			const outputArray = [];

			outputArray.push((0, utils.padNumber)(this.year, 4));
			outputArray.push((0, utils.padNumber)(this.month, 2));
			outputArray.push((0, utils.padNumber)(this.day, 2));
			outputArray.push((0, utils.padNumber)(this.hour, 2));
			outputArray.push((0, utils.padNumber)(this.minute, 2));
			outputArray.push((0, utils.padNumber)(this.second, 2));
			if (this.millisecond !== 0) {
				outputArray.push(".");
				outputArray.push((0, utils.padNumber)(this.millisecond, 3));
			}
			outputArray.push("Z");

			return outputArray.join("");
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "GeneralizedTime";
		}
		//**********************************************************************************
		/**
	  * Convertion for the block to JSON object
	  * @returns {Object}
	  */
		toJSON() {
			let object = {};

			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try {
				object = super.toJSON();
			} catch (ex) {}
			//endregion

			object.year = this.year;
			object.month = this.month;
			object.day = this.day;
			object.hour = this.hour;
			object.minute = this.minute;
			object.second = this.second;
			object.millisecond = this.millisecond;

			return object;
		}
		//**********************************************************************************
	}
	exports.GeneralizedTime = GeneralizedTime; //**************************************************************************************
	/**
	 * @extends Utf8String
	 */

	class DATE extends Utf8String {
		//**********************************************************************************
		/**
	  * Constructor for "DATE" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 31; // DATE
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "DATE";
		}
		//**********************************************************************************
	}
	exports.DATE = DATE; //**************************************************************************************
	/**
	 * @extends Utf8String
	 */

	class TimeOfDay extends Utf8String {
		//**********************************************************************************
		/**
	  * Constructor for "TimeOfDay" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 32; // TimeOfDay
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "TimeOfDay";
		}
		//**********************************************************************************
	}
	exports.TimeOfDay = TimeOfDay; //**************************************************************************************
	/**
	 * @extends Utf8String
	 */

	class DateTime extends Utf8String {
		//**********************************************************************************
		/**
	  * Constructor for "DateTime" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 33; // DateTime
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "DateTime";
		}
		//**********************************************************************************
	}
	exports.DateTime = DateTime; //**************************************************************************************
	/**
	 * @extends Utf8String
	 */

	class Duration extends Utf8String {
		//**********************************************************************************
		/**
	  * Constructor for "Duration" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 34; // Duration
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "Duration";
		}
		//**********************************************************************************
	}
	exports.Duration = Duration; //**************************************************************************************
	/**
	 * @extends Utf8String
	 */

	class TIME extends Utf8String {
		//**********************************************************************************
		/**
	  * Constructor for "Time" class
	  * @param {Object} [parameters={}]
	  */
		constructor(parameters = {}) {
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 14; // Time
		}
		//**********************************************************************************
		/**
	  * Aux function, need to get a block name. Need to have it here for inhiritence
	  * @returns {string}
	  */
		static blockName() {
			return "TIME";
		}
		//**********************************************************************************
	}
	exports.TIME = TIME; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type Choice
	//**************************************************************************************

	class Choice {
		//**********************************************************************************
		/**
	  * Constructor for "Choice" class
	  * @param {Object} [parameters={}]
	  * @property {Array} [value] Array of ASN.1 types for make a choice from
	  * @property {boolean} [optional]
	  */
		constructor(parameters = {}) {
			this.value = (0, utils.getParametersValue)(parameters, "value", []);
			this.optional = (0, utils.getParametersValue)(parameters, "optional", false);
		}
		//**********************************************************************************
	}
	exports.Choice = Choice; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type Any
	//**************************************************************************************

	class Any {
		//**********************************************************************************
		/**
	  * Constructor for "Any" class
	  * @param {Object} [parameters={}]
	  * @property {string} [name]
	  * @property {boolean} [optional]
	  */
		constructor(parameters = {}) {
			this.name = (0, utils.getParametersValue)(parameters, "name", "");
			this.optional = (0, utils.getParametersValue)(parameters, "optional", false);
		}
		//**********************************************************************************
	}
	exports.Any = Any; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type Repeated
	//**************************************************************************************

	class Repeated {
		//**********************************************************************************
		/**
	  * Constructor for "Repeated" class
	  * @param {Object} [parameters={}]
	  * @property {string} [name]
	  * @property {boolean} [optional]
	  */
		constructor(parameters = {}) {
			this.name = (0, utils.getParametersValue)(parameters, "name", "");
			this.optional = (0, utils.getParametersValue)(parameters, "optional", false);
			this.value = (0, utils.getParametersValue)(parameters, "value", new Any());
			this.local = (0, utils.getParametersValue)(parameters, "local", false); // Could local or global array to store elements
		}
		//**********************************************************************************
	}
	exports.Repeated = Repeated; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type RawData
	//**************************************************************************************
	/**
	 * @description Special class providing ability to have "toBER/fromBER" for raw ArrayBuffer
	 */

	class RawData {
		//**********************************************************************************
		/**
	  * Constructor for "Repeated" class
	  * @param {Object} [parameters={}]
	  * @property {string} [name]
	  * @property {boolean} [optional]
	  */
		constructor(parameters = {}) {
			this.data = (0, utils.getParametersValue)(parameters, "data", new ArrayBuffer(0));
		}
		//**********************************************************************************
		/**
	  * Base function for converting block from BER encoded array of bytes
	  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	  * @returns {number} Offset after least decoded byte
	  */
		fromBER(inputBuffer, inputOffset, inputLength) {
			this.data = inputBuffer.slice(inputOffset, inputLength);
			return inputOffset + inputLength;
		}
		//**********************************************************************************
		/**
	  * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	  * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	  * @returns {ArrayBuffer}
	  */
		toBER(sizeOnly = false) {
			return this.data;
		}
		//**********************************************************************************
	}
	exports.RawData = RawData; //**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Major ASN.1 BER decoding function
	//**************************************************************************************
	/**
	 * Internal library function for decoding ASN.1 BER
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {{offset: number, result: Object}}
	 */

	function LocalFromBER(inputBuffer, inputOffset, inputLength) {
		const incomingOffset = inputOffset; // Need to store initial offset since "inputOffset" is changing in the function

		//region Local function changing a type for ASN.1 classes
		function localChangeType(inputObject, newType) {
			if (inputObject instanceof newType) return inputObject;

			const newObject = new newType();
			newObject.idBlock = inputObject.idBlock;
			newObject.lenBlock = inputObject.lenBlock;
			newObject.warnings = inputObject.warnings;
			//noinspection JSCheckFunctionSignatures
			newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);

			return newObject;
		}
		//endregion

		//region Create a basic ASN.1 type since we need to return errors and warnings from the function
		let returnObject = new BaseBlock({}, Object);
		//endregion

		//region Basic check for parameters
		if ((0, utils.checkBufferParams)(new LocalBaseBlock(), inputBuffer, inputOffset, inputLength) === false) {
			returnObject.error = "Wrong input parameters";
			return {
				offset: -1,
				result: returnObject
			};
		}
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if (intBuffer.length === 0) {
			this.error = "Zero buffer length";
			return {
				offset: -1,
				result: returnObject
			};
		}
		//endregion

		//region Decode indentifcation block of ASN.1 BER structure
		let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
		returnObject.warnings.concat(returnObject.idBlock.warnings);
		if (resultOffset === -1) {
			returnObject.error = returnObject.idBlock.error;
			return {
				offset: -1,
				result: returnObject
			};
		}

		inputOffset = resultOffset;
		inputLength -= returnObject.idBlock.blockLength;
		//endregion

		//region Decode length block of ASN.1 BER structure
		resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
		returnObject.warnings.concat(returnObject.lenBlock.warnings);
		if (resultOffset === -1) {
			returnObject.error = returnObject.lenBlock.error;
			return {
				offset: -1,
				result: returnObject
			};
		}

		inputOffset = resultOffset;
		inputLength -= returnObject.lenBlock.blockLength;
		//endregion

		//region Check for usign indefinite length form in encoding for primitive types
		if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {
			returnObject.error = "Indefinite length form used for primitive encoding form";
			return {
				offset: -1,
				result: returnObject
			};
		}
		//endregion

		//region Switch ASN.1 block type
		let newASN1Type = BaseBlock;

		switch (returnObject.idBlock.tagClass) {
			//region UNIVERSAL
			case 1:
				//region Check for reserved tag numbers
				if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
					returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
					return {
						offset: -1,
						result: returnObject
					};
				}
				//endregion

				switch (returnObject.idBlock.tagNumber) {
					//region EndOfContent type
					case 0:
						//region Check for EndOfContent type
						if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {
							returnObject.error = "Type [UNIVERSAL 0] is reserved";
							return {
								offset: -1,
								result: returnObject
							};
						}
						//endregion

						newASN1Type = EndOfContent;

						break;
					//endregion
					//region Boolean type
					case 1:
						newASN1Type = Boolean;
						break;
					//endregion
					//region Integer type
					case 2:
						newASN1Type = Integer;
						break;
					//endregion
					//region BitString type
					case 3:
						newASN1Type = BitString;
						break;
					//endregion
					//region OctetString type
					case 4:
						newASN1Type = OctetString;
						break;
					//endregion
					//region Null type
					case 5:
						newASN1Type = Null;
						break;
					//endregion
					//region OBJECT IDENTIFIER type
					case 6:
						newASN1Type = ObjectIdentifier;
						break;
					//endregion
					//region Enumerated type
					case 10:
						newASN1Type = Enumerated;
						break;
					//endregion
					//region Utf8String type
					case 12:
						newASN1Type = Utf8String;
						break;
					//endregion
					//region Time type
					case 14:
						newASN1Type = TIME;
						break;
					//endregion
					//region ASN.1 reserved type
					case 15:
						returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
						return {
							offset: -1,
							result: returnObject
						};
					//endregion
					//region Sequence type
					case 16:
						newASN1Type = Sequence;
						break;
					//endregion
					//region Set type
					case 17:
						newASN1Type = Set;
						break;
					//endregion
					//region NumericString type
					case 18:
						newASN1Type = NumericString;
						break;
					//endregion
					//region PrintableString type
					case 19:
						newASN1Type = PrintableString;
						break;
					//endregion
					//region TeletexString type
					case 20:
						newASN1Type = TeletexString;
						break;
					//endregion
					//region VideotexString type
					case 21:
						newASN1Type = VideotexString;
						break;
					//endregion
					//region IA5String type
					case 22:
						newASN1Type = IA5String;
						break;
					//endregion
					//region UTCTime type
					case 23:
						newASN1Type = UTCTime;
						break;
					//endregion
					//region GeneralizedTime type
					case 24:
						newASN1Type = GeneralizedTime;
						break;
					//endregion
					//region GraphicString type
					case 25:
						newASN1Type = GraphicString;
						break;
					//endregion
					//region VisibleString type
					case 26:
						newASN1Type = VisibleString;
						break;
					//endregion
					//region GeneralString type
					case 27:
						newASN1Type = GeneralString;
						break;
					//endregion
					//region UniversalString type
					case 28:
						newASN1Type = UniversalString;
						break;
					//endregion
					//region CharacterString type
					case 29:
						newASN1Type = CharacterString;
						break;
					//endregion
					//region BmpString type
					case 30:
						newASN1Type = BmpString;
						break;
					//endregion
					//region DATE type
					case 31:
						newASN1Type = DATE;
						break;
					//endregion
					//region TimeOfDay type
					case 32:
						newASN1Type = TimeOfDay;
						break;
					//endregion
					//region Date-Time type
					case 33:
						newASN1Type = DateTime;
						break;
					//endregion
					//region Duration type
					case 34:
						newASN1Type = Duration;
						break;
					//endregion
					//region default
					default:
						{
							let newObject;

							if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();

							newObject.idBlock = returnObject.idBlock;
							newObject.lenBlock = returnObject.lenBlock;
							newObject.warnings = returnObject.warnings;

							returnObject = newObject;

							resultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);
						}
					//endregion
				}
				break;
			//endregion
			//region All other tag classes
			case 2: // APPLICATION
			case 3: // CONTEXT-SPECIFIC
			case 4: // PRIVATE
			default:
				{
					if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;
				}
			//endregion
		}
		//endregion

		//region Change type and perform BER decoding
		returnObject = localChangeType(returnObject, newASN1Type);
		resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length);
		//endregion

		//region Coping incoming buffer for entire ASN.1 block
		returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);
		//endregion

		return {
			offset: resultOffset,
			result: returnObject
		};
	}
	//**************************************************************************************
	/**
	 * Major function for decoding ASN.1 BER array into internal library structuries
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes
	 */
	function fromBER(inputBuffer) {
		if (inputBuffer.byteLength === 0) {
			const result = new BaseBlock({}, Object);
			result.error = "Input buffer has zero length";

			return {
				offset: -1,
				result
			};
		}

		return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Major scheme verification function
	//**************************************************************************************
	/**
	 * Compare of two ASN.1 object trees
	 * @param {!Object} root Root of input ASN.1 object tree
	 * @param {!Object} inputData Input ASN.1 object tree
	 * @param {!Object} inputSchema Input ASN.1 schema to compare with
	 * @return {{verified: boolean}|{verified:boolean, result: Object}}
	 */
	function compareSchema(root, inputData, inputSchema) {
		//region Special case for Choice schema element type
		if (inputSchema instanceof Choice) {

			for (let j = 0; j < inputSchema.value.length; j++) {
				const result = compareSchema(root, inputData, inputSchema.value[j]);
				if (result.verified === true) {
					return {
						verified: true,
						result: root
					};
				}
			}

			{
				const _result = {
					verified: false,
					result: {
						error: "Wrong values for Choice type"
					}
				};

				if (inputSchema.hasOwnProperty("name")) _result.name = inputSchema.name;

				return _result;
			}
		}
		//endregion

		//region Special case for Any schema element type
		if (inputSchema instanceof Any) {
			//region Add named component of ASN.1 schema
			if (inputSchema.hasOwnProperty("name")) root[inputSchema.name] = inputData;
			//endregion

			return {
				verified: true,
				result: root
			};
		}
		//endregion

		//region Initial check
		if (root instanceof Object === false) {
			return {
				verified: false,
				result: { error: "Wrong root object" }
			};
		}

		if (inputData instanceof Object === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 data" }
			};
		}

		if (inputSchema instanceof Object === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if ("idBlock" in inputSchema === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}
		//endregion

		//region Comparing idBlock properties in ASN.1 data and ASN.1 schema
		//region Encode and decode ASN.1 schema idBlock
		/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>
		if ("fromBER" in inputSchema.idBlock === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if ("toBER" in inputSchema.idBlock === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		const encodedId = inputSchema.idBlock.toBER(false);
		if (encodedId.byteLength === 0) {
			return {
				verified: false,
				result: { error: "Error encoding idBlock for ASN.1 schema" }
			};
		}

		const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
		if (decodedOffset === -1) {
			return {
				verified: false,
				result: { error: "Error decoding idBlock for ASN.1 schema" }
			};
		}
		//endregion

		//region tagClass
		if (inputSchema.idBlock.hasOwnProperty("tagClass") === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region tagNumber
		if (inputSchema.idBlock.hasOwnProperty("tagNumber") === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region isConstructed
		if (inputSchema.idBlock.hasOwnProperty("isConstructed") === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region isHexOnly
		if ("isHexOnly" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property
			{
				return {
					verified: false,
					result: { error: "Wrong ASN.1 schema" }
				};
			}

		if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region valueHex
		if (inputSchema.idBlock.isHexOnly === true) {
			if ("valueHex" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property
				{
					return {
						verified: false,
						result: { error: "Wrong ASN.1 schema" }
					};
				}

			const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);
			const asn1View = new Uint8Array(inputData.idBlock.valueHex);

			if (schemaView.length !== asn1View.length) {
				return {
					verified: false,
					result: root
				};
			}

			for (let i = 0; i < schemaView.length; i++) {
				if (schemaView[i] !== asn1View[1]) {
					return {
						verified: false,
						result: root
					};
				}
			}
		}
		//endregion
		//endregion

		//region Add named component of ASN.1 schema
		if (inputSchema.hasOwnProperty("name")) {
			inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
			if (inputSchema.name !== "") root[inputSchema.name] = inputData;
		}
		//endregion

		//region Getting next ASN.1 block for comparition
		if (inputSchema.idBlock.isConstructed === true) {
			let admission = 0;
			let result = { verified: false };

			let maxLength = inputSchema.valueBlock.value.length;

			if (maxLength > 0) {
				if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;
			}

			//region Special case when constructive value has no elements
			if (maxLength === 0) {
				return {
					verified: true,
					result: root
				};
			}
			//endregion

			//region Special case when "inputData" has no values and "inputSchema" has all optional values
			if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
				let _optional = true;

				for (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);

				if (_optional === true) {
					return {
						verified: true,
						result: root
					};
				}

				//region Delete early added name of block
				if (inputSchema.hasOwnProperty("name")) {
					inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
					if (inputSchema.name !== "") delete root[inputSchema.name];
				}
				//endregion

				root.error = "Inconsistent object length";

				return {
					verified: false,
					result: root
				};
			}
			//endregion

			for (let i = 0; i < maxLength; i++) {
				//region Special case when there is an "optional" element of ASN.1 schema at the end
				if (i - admission >= inputData.valueBlock.value.length) {
					if (inputSchema.valueBlock.value[i].optional === false) {
						const _result = {
							verified: false,
							result: root
						};

						root.error = "Inconsistent length between ASN.1 data and schema";

						//region Delete early added name of block
						if (inputSchema.hasOwnProperty("name")) {
							inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
							if (inputSchema.name !== "") {
								delete root[inputSchema.name];
								_result.name = inputSchema.name;
							}
						}
						//endregion

						return _result;
					}
				}
				//endregion
				else {
						//region Special case for Repeated type of ASN.1 schema element
						if (inputSchema.valueBlock.value[0] instanceof Repeated) {
							result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
							if (result.verified === false) {
								if (inputSchema.valueBlock.value[0].optional === true) admission++;else {
									//region Delete early added name of block
									if (inputSchema.hasOwnProperty("name")) {
										inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
										if (inputSchema.name !== "") delete root[inputSchema.name];
									}
									//endregion

									return result;
								}
							}

							if ("name" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
								let arrayRoot = {};

								if ("local" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;

								if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined") arrayRoot[inputSchema.valueBlock.value[0].name] = [];

								arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
							}
						}
						//endregion
						else {
								result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
								if (result.verified === false) {
									if (inputSchema.valueBlock.value[i].optional === true) admission++;else {
										//region Delete early added name of block
										if (inputSchema.hasOwnProperty("name")) {
											inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
											if (inputSchema.name !== "") delete root[inputSchema.name];
										}
										//endregion

										return result;
									}
								}
							}
					}
			}

			if (result.verified === false) // The situation may take place if last element is "optional" and verification failed
				{
					const _result = {
						verified: false,
						result: root
					};

					//region Delete early added name of block
					if (inputSchema.hasOwnProperty("name")) {
						inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
						if (inputSchema.name !== "") {
							delete root[inputSchema.name];
							_result.name = inputSchema.name;
						}
					}
					//endregion

					return _result;
				}

			return {
				verified: true,
				result: root
			};
		}
		//endregion
		//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)
		if ("primitiveSchema" in inputSchema && "valueHex" in inputData.valueBlock) {
			//region Decoding of raw ASN.1 data
			const asn1 = fromBER(inputData.valueBlock.valueHex);
			if (asn1.offset === -1) {
				const _result = {
					verified: false,
					result: asn1.result
				};

				//region Delete early added name of block
				if (inputSchema.hasOwnProperty("name")) {
					inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
					if (inputSchema.name !== "") {
						delete root[inputSchema.name];
						_result.name = inputSchema.name;
					}
				}
				//endregion

				return _result;
			}
			//endregion

			return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
		}

		return {
			verified: true,
			result: root
		};
		//endregion
	}
	//**************************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * ASN.1 schema verification for ArrayBuffer data
	 * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data
	 * @param {!Object} inputSchema Input ASN.1 schema to verify against to
	 * @return {{verified: boolean}|{verified:boolean, result: Object}}
	 */
	function verifySchema(inputBuffer, inputSchema) {
		//region Initial check
		if (inputSchema instanceof Object === false) {
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema type" }
			};
		}
		//endregion

		//region Decoding of raw ASN.1 data
		const asn1 = fromBER(inputBuffer);
		if (asn1.offset === -1) {
			return {
				verified: false,
				result: asn1.result
			};
		}
		//endregion

		//region Compare ASN.1 struct with input schema
		return compareSchema(asn1.result, asn1.result, inputSchema);
		//endregion
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Major function converting JSON to ASN.1 objects
	//**************************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Converting from JSON to ASN.1 objects
	 * @param {string|Object} json JSON string or object to convert to ASN.1 objects
	 */
	function fromJSON(json) {}
	// TODO Implement

	//**************************************************************************************
	//endregion
	//**************************************************************************************

	});

	unwrapExports(asn1);
	var asn1_1 = asn1.RawData;
	var asn1_2 = asn1.Repeated;
	var asn1_3 = asn1.Any;
	var asn1_4 = asn1.Choice;
	var asn1_5 = asn1.TIME;
	var asn1_6 = asn1.Duration;
	var asn1_7 = asn1.DateTime;
	var asn1_8 = asn1.TimeOfDay;
	var asn1_9 = asn1.DATE;
	var asn1_10 = asn1.GeneralizedTime;
	var asn1_11 = asn1.UTCTime;
	var asn1_12 = asn1.CharacterString;
	var asn1_13 = asn1.GeneralString;
	var asn1_14 = asn1.VisibleString;
	var asn1_15 = asn1.GraphicString;
	var asn1_16 = asn1.IA5String;
	var asn1_17 = asn1.VideotexString;
	var asn1_18 = asn1.TeletexString;
	var asn1_19 = asn1.PrintableString;
	var asn1_20 = asn1.NumericString;
	var asn1_21 = asn1.UniversalString;
	var asn1_22 = asn1.BmpString;
	var asn1_23 = asn1.Utf8String;
	var asn1_24 = asn1.ObjectIdentifier;
	var asn1_25 = asn1.Enumerated;
	var asn1_26 = asn1.Integer;
	var asn1_27 = asn1.BitString;
	var asn1_28 = asn1.OctetString;
	var asn1_29 = asn1.Null;
	var asn1_30 = asn1.Set;
	var asn1_31 = asn1.Sequence;
	var asn1_32 = asn1.Boolean;
	var asn1_33 = asn1.EndOfContent;
	var asn1_34 = asn1.Constructed;
	var asn1_35 = asn1.Primitive;
	var asn1_36 = asn1.BaseBlock;
	var asn1_37 = asn1.fromBER;
	var asn1_38 = asn1.compareSchema;
	var asn1_39 = asn1.verifySchema;
	var asn1_40 = asn1.fromJSON;

	var build = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });


	const AsnAnyConverter = {
	    fromASN: (value) => value instanceof asn1.Null ? null : value.valueBeforeDecode,
	    toASN: (value) => {
	        if (value === null) {
	            return new asn1.Null();
	        }
	        const schema = asn1.fromBER(value);
	        if (schema.result.error) {
	            throw new Error(schema.result.error);
	        }
	        return schema.result;
	    },
	};
	const AsnIntegerConverter = {
	    fromASN: (value) => !value.valueBlock.valueDec && value.valueBlock.valueHex.byteLength > 0 ?
	        value.valueBlock.toString()
	        : value.valueBlock.valueDec,
	    toASN: (value) => new asn1.Integer({ value }),
	};
	const AsnEnumeratedConverter = {
	    fromASN: (value) => value.valueBlock.valueDec,
	    toASN: (value) => new asn1.Enumerated({ value }),
	};
	const AsnIntegerArrayBufferConverter = {
	    fromASN: (value) => value.valueBlock.valueHex,
	    toASN: (value) => new asn1.Integer({ valueHex: value }),
	};
	const AsnBitStringConverter = {
	    fromASN: (value) => value.valueBlock.valueHex,
	    toASN: (value) => new asn1.BitString({ valueHex: value }),
	};
	const AsnObjectIdentifierConverter = {
	    fromASN: (value) => value.valueBlock.toString(),
	    toASN: (value) => new asn1.ObjectIdentifier({ value }),
	};
	const AsnBooleanConverter = {
	    fromASN: (value) => value.valueBlock.value,
	    toASN: (value) => new asn1.Boolean({ value }),
	};
	const AsnOctetStringConverter = {
	    fromASN: (value) => value.valueBlock.valueHex,
	    toASN: (value) => new asn1.OctetString({ valueHex: value }),
	};
	function createStringConverter(Asn1Type) {
	    return {
	        fromASN: (value) => value.valueBlock.value,
	        toASN: (value) => new Asn1Type({ value }),
	    };
	}
	const AsnUtf8StringConverter = createStringConverter(asn1.Utf8String);
	const AsnBmpStringConverter = createStringConverter(asn1.BmpString);
	const AsnUniversalStringConverter = createStringConverter(asn1.UniversalString);
	const AsnNumericStringConverter = createStringConverter(asn1.NumericString);
	const AsnPrintableStringConverter = createStringConverter(asn1.PrintableString);
	const AsnTeletexStringConverter = createStringConverter(asn1.TeletexString);
	const AsnVideotexStringConverter = createStringConverter(asn1.VideotexString);
	const AsnIA5StringConverter = createStringConverter(asn1.IA5String);
	const AsnGraphicStringConverter = createStringConverter(asn1.GraphicString);
	const AsnVisibleStringConverter = createStringConverter(asn1.VisibleString);
	const AsnGeneralStringConverter = createStringConverter(asn1.GeneralString);
	const AsnCharacterStringConverter = createStringConverter(asn1.CharacterString);
	const AsnUTCTimeConverter = {
	    fromASN: (value) => value.toDate(),
	    toASN: (value) => new asn1.UTCTime({ valueDate: value }),
	};
	const AsnGeneralizedTimeConverter = {
	    fromASN: (value) => value.toDate(),
	    toASN: (value) => new asn1.GeneralizedTime({ valueDate: value }),
	};

	var defaultConverters = /*#__PURE__*/Object.freeze({
	  AsnAnyConverter: AsnAnyConverter,
	  AsnIntegerConverter: AsnIntegerConverter,
	  AsnEnumeratedConverter: AsnEnumeratedConverter,
	  AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,
	  AsnBitStringConverter: AsnBitStringConverter,
	  AsnObjectIdentifierConverter: AsnObjectIdentifierConverter,
	  AsnBooleanConverter: AsnBooleanConverter,
	  AsnOctetStringConverter: AsnOctetStringConverter,
	  AsnUtf8StringConverter: AsnUtf8StringConverter,
	  AsnBmpStringConverter: AsnBmpStringConverter,
	  AsnUniversalStringConverter: AsnUniversalStringConverter,
	  AsnNumericStringConverter: AsnNumericStringConverter,
	  AsnPrintableStringConverter: AsnPrintableStringConverter,
	  AsnTeletexStringConverter: AsnTeletexStringConverter,
	  AsnVideotexStringConverter: AsnVideotexStringConverter,
	  AsnIA5StringConverter: AsnIA5StringConverter,
	  AsnGraphicStringConverter: AsnGraphicStringConverter,
	  AsnVisibleStringConverter: AsnVisibleStringConverter,
	  AsnGeneralStringConverter: AsnGeneralStringConverter,
	  AsnCharacterStringConverter: AsnCharacterStringConverter,
	  AsnUTCTimeConverter: AsnUTCTimeConverter,
	  AsnGeneralizedTimeConverter: AsnGeneralizedTimeConverter
	});

	(function (AsnTypeTypes) {
	    AsnTypeTypes[AsnTypeTypes["Sequence"] = 0] = "Sequence";
	    AsnTypeTypes[AsnTypeTypes["Set"] = 1] = "Set";
	    AsnTypeTypes[AsnTypeTypes["Choice"] = 2] = "Choice";
	})(exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));
	(function (AsnPropTypes) {
	    AsnPropTypes[AsnPropTypes["Any"] = 0] = "Any";
	    AsnPropTypes[AsnPropTypes["Boolean"] = 1] = "Boolean";
	    AsnPropTypes[AsnPropTypes["OctetString"] = 2] = "OctetString";
	    AsnPropTypes[AsnPropTypes["BitString"] = 3] = "BitString";
	    AsnPropTypes[AsnPropTypes["Integer"] = 4] = "Integer";
	    AsnPropTypes[AsnPropTypes["Enumerated"] = 5] = "Enumerated";
	    AsnPropTypes[AsnPropTypes["ObjectIdentifier"] = 6] = "ObjectIdentifier";
	    AsnPropTypes[AsnPropTypes["Utf8String"] = 7] = "Utf8String";
	    AsnPropTypes[AsnPropTypes["BmpString"] = 8] = "BmpString";
	    AsnPropTypes[AsnPropTypes["UniversalString"] = 9] = "UniversalString";
	    AsnPropTypes[AsnPropTypes["NumericString"] = 10] = "NumericString";
	    AsnPropTypes[AsnPropTypes["PrintableString"] = 11] = "PrintableString";
	    AsnPropTypes[AsnPropTypes["TeletexString"] = 12] = "TeletexString";
	    AsnPropTypes[AsnPropTypes["VideotexString"] = 13] = "VideotexString";
	    AsnPropTypes[AsnPropTypes["IA5String"] = 14] = "IA5String";
	    AsnPropTypes[AsnPropTypes["GraphicString"] = 15] = "GraphicString";
	    AsnPropTypes[AsnPropTypes["VisibleString"] = 16] = "VisibleString";
	    AsnPropTypes[AsnPropTypes["GeneralString"] = 17] = "GeneralString";
	    AsnPropTypes[AsnPropTypes["CharacterString"] = 18] = "CharacterString";
	    AsnPropTypes[AsnPropTypes["UTCTime"] = 19] = "UTCTime";
	    AsnPropTypes[AsnPropTypes["GeneralizedTime"] = 20] = "GeneralizedTime";
	    AsnPropTypes[AsnPropTypes["DATE"] = 21] = "DATE";
	    AsnPropTypes[AsnPropTypes["TimeOfDay"] = 22] = "TimeOfDay";
	    AsnPropTypes[AsnPropTypes["DateTime"] = 23] = "DateTime";
	    AsnPropTypes[AsnPropTypes["Duration"] = 24] = "Duration";
	    AsnPropTypes[AsnPropTypes["TIME"] = 25] = "TIME";
	    AsnPropTypes[AsnPropTypes["Null"] = 26] = "Null";
	})(exports.AsnPropTypes || (exports.AsnPropTypes = {}));

	const asn1$1 = asn1;
	class AsnSchemaStorage {
	    constructor() {
	        this.items = new Map();
	    }
	    has(target) {
	        return this.items.has(target);
	    }
	    get(target) {
	        const schema = this.items.get(target);
	        if (!schema) {
	            throw new Error("Cannot get schema for current target");
	        }
	        return schema;
	    }
	    cache(target) {
	        const schema = this.get(target);
	        if (!schema.schema) {
	            schema.schema = this.create(target, true);
	        }
	    }
	    createDefault(target) {
	        const schema = {
	            type: exports.AsnTypeTypes.Sequence,
	            items: {},
	        };
	        const parentSchema = this.findParentSchema(target);
	        if (parentSchema) {
	            Object.assign(schema, parentSchema);
	            schema.items = Object.assign({}, schema.items, parentSchema.items);
	        }
	        return schema;
	    }
	    create(target, useNames) {
	        const schema = this.items.get(target) || this.createDefault(target);
	        const asn1Value = [];
	        for (const key in schema.items) {
	            const item = schema.items[key];
	            const name = useNames ? key : "";
	            let asn1Item;
	            if (typeof (item.type) === "number") {
	                const Asn1TypeName = exports.AsnPropTypes[item.type];
	                const Asn1Type = asn1$1[Asn1TypeName];
	                if (!Asn1Type) {
	                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
	                }
	                asn1Item = new Asn1Type({ name });
	            }
	            else {
	                asn1Item = new asn1$1.Any({ name });
	            }
	            const optional = !!item.optional || item.defaultValue !== undefined;
	            if (item.repeated) {
	                asn1Item.name = "";
	                asn1Item = new asn1$1.Repeated({
	                    name,
	                    value: asn1Item,
	                });
	            }
	            if (item.context !== null && item.context !== undefined) {
	                if (item.implicit) {
	                    if (typeof item.type === "number") {
	                        asn1Value.push(new asn1$1.Primitive({
	                            name,
	                            optional,
	                            idBlock: {
	                                tagClass: 3,
	                                tagNumber: item.context,
	                            },
	                        }));
	                    }
	                    else {
	                        this.cache(item.type);
	                        const value = this.get(item.type).schema.valueBlock.value;
	                        asn1Value.push(new asn1$1.Constructed({
	                            name,
	                            optional,
	                            idBlock: {
	                                tagClass: 3,
	                                tagNumber: item.context,
	                            },
	                            value,
	                        }));
	                    }
	                }
	                else {
	                    asn1Value.push(new asn1$1.Constructed({
	                        optional,
	                        idBlock: {
	                            tagClass: 3,
	                            tagNumber: item.context,
	                        },
	                        value: [asn1Item],
	                    }));
	                }
	            }
	            else {
	                asn1Item.optional = optional;
	                asn1Value.push(asn1Item);
	            }
	        }
	        switch (schema.type) {
	            case exports.AsnTypeTypes.Sequence:
	                return new asn1$1.Sequence({ value: asn1Value, name: "" });
	            case exports.AsnTypeTypes.Set:
	                return new asn1$1.Set({ value: asn1Value, name: "" });
	            case exports.AsnTypeTypes.Choice:
	                return new asn1$1.Choice({ value: asn1Value, name: "" });
	            default:
	                throw new Error(`Unsupported ASN1 type in use`);
	        }
	    }
	    set(target, schema) {
	        this.items.set(target, schema);
	        return this;
	    }
	    findParentSchema(target) {
	        const parent = target.__proto__;
	        if (parent) {
	            const schema = this.items.get(parent);
	            return schema || this.findParentSchema(parent);
	        }
	        return null;
	    }
	}

	const schemaStorage = new AsnSchemaStorage();

	const AsnType = (options) => (target) => {
	    const schema = schemaStorage.get(target);
	    Object.assign(schema, options);
	};
	const AsnProp = (options) => (target, propertyKey) => {
	    let schema;
	    if (!schemaStorage.has(target.constructor)) {
	        schema = schemaStorage.createDefault(target.constructor);
	        schemaStorage.set(target.constructor, schema);
	    }
	    else {
	        schema = schemaStorage.get(target.constructor);
	    }
	    const copyOptions = Object.assign({}, options);
	    if (typeof copyOptions.type === "number" && !copyOptions.converter) {
	        const converterName = `Asn${exports.AsnPropTypes[options.type]}Converter`;
	        const defaultConverter = defaultConverters[converterName];
	        if (!defaultConverter) {
	            throw new Error(`Cannot get '${converterName}' for property '${propertyKey}' of ${target.constructor.name}`);
	        }
	        copyOptions.converter = defaultConverter;
	    }
	    schema.items[propertyKey] = copyOptions;
	};

	function isConvertible(target) {
	    if (target && target.prototype) {
	        if (target.prototype.toASN && target.prototype.fromASN) {
	            return true;
	        }
	        else {
	            return isConvertible(target.prototype);
	        }
	    }
	    else {
	        return !!(target && target.toASN && target.fromASN);
	    }
	}

	const asn1$2 = asn1;
	class AsnParser {
	    static parse(data, target, obj) {
	        let buf;
	        if (data instanceof ArrayBuffer) {
	            buf = data;
	        }
	        else if (typeof Buffer !== undefined && Buffer.isBuffer(data)) {
	            buf = new Uint8Array(data).buffer;
	        }
	        else if (ArrayBuffer.isView(data)) {
	            buf = data.buffer;
	        }
	        else {
	            throw new TypeError("Wrong type of 'data' argument");
	        }
	        const asn1Parsed = asn1$2.fromBER(buf);
	        if (asn1Parsed.result.error) {
	            throw new Error(asn1Parsed.result.error);
	        }
	        const res = this.fromASN(asn1Parsed.result, target, obj);
	        return res;
	    }
	    static fromASN(asn1Schema, target, obj) {
	        if (isConvertible(target)) {
	            const value = (obj || new target());
	            return value.fromASN(asn1Schema);
	        }
	        const schema = schemaStorage.get(target);
	        schemaStorage.cache(target);
	        let targetSchema = schema.schema;
	        if (asn1Schema.constructor === asn1$2.Constructed && schema.type !== exports.AsnTypeTypes.Choice) {
	            targetSchema = new asn1$2.Constructed({
	                idBlock: {
	                    tagClass: 3,
	                    tagNumber: asn1Schema.idBlock.tagNumber,
	                },
	                value: schema.schema.valueBlock.value,
	            });
	            for (const key in schema.items) {
	                delete asn1Schema[key];
	            }
	        }
	        const asn1ComparedSchema = asn1$2.compareSchema(asn1Schema, asn1Schema, targetSchema);
	        if (!asn1ComparedSchema.verified) {
	            throw new Error(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
	        }
	        const res = obj || new target();
	        for (const key in schema.items) {
	            if (!asn1Schema[key]) {
	                continue;
	            }
	            const schemaItem = schema.items[key];
	            if (typeof (schemaItem.type) === "number") {
	                const converter = schemaItem.converter;
	                if (!converter) {
	                    throw new Error("Converter is empty");
	                }
	                if (schemaItem.repeated) {
	                    res[key] = Array.from(asn1Schema[key], (element) => converter.fromASN(element));
	                }
	                else {
	                    let value = asn1Schema[key];
	                    if (schemaItem.implicit) {
	                        const Asn1TypeName = exports.AsnPropTypes[schemaItem.type];
	                        const Asn1Type = asn1$2[Asn1TypeName];
	                        if (!Asn1Type) {
	                            throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
	                        }
	                        const newItem = new Asn1Type();
	                        newItem.valueBlock = value.valueBlock;
	                        value = asn1$2.fromBER(newItem.toBER(false)).result;
	                    }
	                    res[key] = converter.fromASN(value);
	                }
	            }
	            else {
	                if (schemaItem.repeated) {
	                    res[key] = Array.from(asn1Schema[key], (element) => this.fromASN(element, schemaItem.type));
	                }
	                else {
	                    res[key] = this.fromASN(asn1Schema[key], schemaItem.type);
	                }
	            }
	        }
	        res._cache = { asn1: asn1Schema };
	        return res;
	    }
	}

	const asn1$3 = asn1;
	class AsnSerializer {
	    static serialize(obj) {
	        return this.toASN(obj).toBER(false);
	    }
	    static toASN(obj) {
	        if (obj && isConvertible(obj.constructor)) {
	            return obj.toASN();
	        }
	        const target = obj.constructor;
	        const schema = schemaStorage.get(target);
	        schemaStorage.cache(target);
	        let asn1Value = [];
	        for (const key in schema.items) {
	            const item = schema.items[key];
	            const objProp = obj[key];
	            if (objProp === undefined || item.defaultValue === objProp) {
	                continue;
	            }
	            let asn1Item;
	            if (typeof (item.type) === "number") {
	                const converter = item.converter;
	                if (!converter) {
	                    throw new Error(`Property '${key}' doesn't have converter for type ${exports.AsnPropTypes[item.type]} in schema '${target.name}'`);
	                }
	                if (item.repeated) {
	                    asn1Item = Array.from(objProp, (element) => converter.toASN(element));
	                }
	                else {
	                    asn1Item = converter.toASN(objProp);
	                }
	            }
	            else {
	                if (item.repeated) {
	                    asn1Item = Array.from(objProp, (element) => this.toASN(element));
	                }
	                else {
	                    asn1Item = this.toASN(objProp);
	                }
	            }
	            if (item.context !== null && item.context !== undefined) {
	                if (item.implicit) {
	                    if (typeof item.type === "number") {
	                        const value = {};
	                        value.valueHex = asn1Item.valueBlock.toBER();
	                        asn1Value.push(new asn1$3.Primitive({
	                            optional: item.optional,
	                            idBlock: {
	                                tagClass: 3,
	                                tagNumber: item.context,
	                            },
	                            ...value,
	                        }));
	                    }
	                    else {
	                        asn1Value.push(new asn1$3.Constructed({
	                            optional: item.optional,
	                            idBlock: {
	                                tagClass: 3,
	                                tagNumber: item.context,
	                            },
	                            value: asn1Item.valueBlock.value,
	                        }));
	                    }
	                }
	                else {
	                    asn1Value.push(new asn1$3.Constructed({
	                        optional: item.optional,
	                        idBlock: {
	                            tagClass: 3,
	                            tagNumber: item.context,
	                        },
	                        value: [asn1Item],
	                    }));
	                }
	            }
	            else if (item.repeated) {
	                asn1Value = asn1Value.concat(asn1Item);
	            }
	            else {
	                asn1Value.push(asn1Item);
	            }
	        }
	        let asnSchema;
	        switch (schema.type) {
	            case exports.AsnTypeTypes.Sequence:
	                asnSchema = new asn1$3.Sequence({ value: asn1Value });
	                break;
	            case exports.AsnTypeTypes.Set:
	                asnSchema = new asn1$3.Set({ value: asn1Value });
	                break;
	            case exports.AsnTypeTypes.Choice:
	                if (!asn1Value[0]) {
	                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
	                }
	                asnSchema = asn1Value[0];
	                break;
	        }
	        return asnSchema;
	    }
	}

	exports.AsnProp = AsnProp;
	exports.AsnType = AsnType;
	exports.AsnParser = AsnParser;
	exports.AsnSerializer = AsnSerializer;
	exports.AsnAnyConverter = AsnAnyConverter;
	exports.AsnIntegerConverter = AsnIntegerConverter;
	exports.AsnEnumeratedConverter = AsnEnumeratedConverter;
	exports.AsnIntegerArrayBufferConverter = AsnIntegerArrayBufferConverter;
	exports.AsnBitStringConverter = AsnBitStringConverter;
	exports.AsnObjectIdentifierConverter = AsnObjectIdentifierConverter;
	exports.AsnBooleanConverter = AsnBooleanConverter;
	exports.AsnOctetStringConverter = AsnOctetStringConverter;
	exports.AsnUtf8StringConverter = AsnUtf8StringConverter;
	exports.AsnBmpStringConverter = AsnBmpStringConverter;
	exports.AsnUniversalStringConverter = AsnUniversalStringConverter;
	exports.AsnNumericStringConverter = AsnNumericStringConverter;
	exports.AsnPrintableStringConverter = AsnPrintableStringConverter;
	exports.AsnTeletexStringConverter = AsnTeletexStringConverter;
	exports.AsnVideotexStringConverter = AsnVideotexStringConverter;
	exports.AsnIA5StringConverter = AsnIA5StringConverter;
	exports.AsnGraphicStringConverter = AsnGraphicStringConverter;
	exports.AsnVisibleStringConverter = AsnVisibleStringConverter;
	exports.AsnGeneralStringConverter = AsnGeneralStringConverter;
	exports.AsnCharacterStringConverter = AsnCharacterStringConverter;
	exports.AsnUTCTimeConverter = AsnUTCTimeConverter;
	exports.AsnGeneralizedTimeConverter = AsnGeneralizedTimeConverter;
	});

	unwrapExports(build);
	var build_1 = build.AsnTypeTypes;
	var build_2 = build.AsnPropTypes;
	var build_3 = build.AsnProp;
	var build_4 = build.AsnType;
	var build_5 = build.AsnParser;
	var build_6 = build.AsnSerializer;
	var build_7 = build.AsnAnyConverter;
	var build_8 = build.AsnIntegerConverter;
	var build_9 = build.AsnEnumeratedConverter;
	var build_10 = build.AsnIntegerArrayBufferConverter;
	var build_11 = build.AsnBitStringConverter;
	var build_12 = build.AsnObjectIdentifierConverter;
	var build_13 = build.AsnBooleanConverter;
	var build_14 = build.AsnOctetStringConverter;
	var build_15 = build.AsnUtf8StringConverter;
	var build_16 = build.AsnBmpStringConverter;
	var build_17 = build.AsnUniversalStringConverter;
	var build_18 = build.AsnNumericStringConverter;
	var build_19 = build.AsnPrintableStringConverter;
	var build_20 = build.AsnTeletexStringConverter;
	var build_21 = build.AsnVideotexStringConverter;
	var build_22 = build.AsnIA5StringConverter;
	var build_23 = build.AsnGraphicStringConverter;
	var build_24 = build.AsnVisibleStringConverter;
	var build_25 = build.AsnGeneralStringConverter;
	var build_26 = build.AsnCharacterStringConverter;
	var build_27 = build.AsnUTCTimeConverter;
	var build_28 = build.AsnGeneralizedTimeConverter;

	var build$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	class JsonError extends Error {
	    constructor(message, innerError) {
	        super(innerError
	            ? `${message}. See the inner exception for more details.`
	            : message);
	        this.message = message;
	        this.innerError = innerError;
	    }
	}

	class TransformError extends JsonError {
	    constructor(schema, message, innerError) {
	        super(message, innerError);
	        this.schema = schema;
	    }
	}

	class ParserError extends TransformError {
	    constructor(schema, message, innerError) {
	        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);
	    }
	}

	class ValidationError extends JsonError {
	}

	class SerializerError extends JsonError {
	    constructor(schemaName, message, innerError) {
	        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);
	        this.schemaName = schemaName;
	    }
	}

	class KeyError extends ParserError {
	    constructor(schema, keys, errors = {}) {
	        super(schema, "Some keys doesn't match to schema");
	        this.keys = keys;
	        this.errors = errors;
	    }
	}

	(function (JsonPropTypes) {
	    JsonPropTypes[JsonPropTypes["Any"] = 0] = "Any";
	    JsonPropTypes[JsonPropTypes["Boolean"] = 1] = "Boolean";
	    JsonPropTypes[JsonPropTypes["Number"] = 2] = "Number";
	    JsonPropTypes[JsonPropTypes["String"] = 3] = "String";
	})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));

	function checkType(value, type) {
	    switch (type) {
	        case exports.JsonPropTypes.Boolean:
	            return typeof value === "boolean";
	        case exports.JsonPropTypes.Number:
	            return typeof value === "number";
	        case exports.JsonPropTypes.String:
	            return typeof value === "string";
	    }
	    return true;
	}
	function throwIfTypeIsWrong(value, type) {
	    if (!checkType(value, type)) {
	        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);
	    }
	}
	function isConvertible(target) {
	    if (target && target.prototype) {
	        if (target.prototype.toJSON && target.prototype.fromJSON) {
	            return true;
	        }
	        else {
	            return isConvertible(target.prototype);
	        }
	    }
	    else {
	        return !!(target && target.toJSON && target.fromJSON);
	    }
	}

	class JsonSchemaStorage {
	    constructor() {
	        this.items = new Map();
	    }
	    has(target) {
	        return this.items.has(target) || !!this.findParentSchema(target);
	    }
	    get(target) {
	        const schema = this.items.get(target) || this.findParentSchema(target);
	        if (!schema) {
	            throw new Error("Cannot get schema for current target");
	        }
	        return schema;
	    }
	    create(target) {
	        const schema = { names: {} };
	        const parentSchema = this.findParentSchema(target);
	        if (parentSchema) {
	            Object.assign(schema, parentSchema);
	            schema.names = {};
	            for (const name in parentSchema.names) {
	                schema.names[name] = Object.assign({}, parentSchema.names[name]);
	            }
	        }
	        schema.target = target;
	        return schema;
	    }
	    set(target, schema) {
	        this.items.set(target, schema);
	        return this;
	    }
	    findParentSchema(target) {
	        const parent = target.__proto__;
	        if (parent) {
	            const schema = this.items.get(parent);
	            return schema || this.findParentSchema(parent);
	        }
	        return null;
	    }
	}

	const DEFAULT_SCHEMA = "default";
	const schemaStorage = new JsonSchemaStorage();

	class PatternValidation {
	    constructor(pattern) {
	        this.pattern = new RegExp(pattern);
	    }
	    validate(value) {
	        const pattern = new RegExp(this.pattern.source, this.pattern.flags);
	        if (typeof value !== "string") {
	            throw new ValidationError("Incoming value must be string");
	        }
	        if (!pattern.exec(value)) {
	            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);
	        }
	    }
	}

	class InclusiveValidation {
	    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {
	        this.min = min;
	        this.max = max;
	    }
	    validate(value) {
	        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);
	        if (!(this.min <= value && value <= this.max)) {
	            const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
	            const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
	            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);
	        }
	    }
	}

	class ExclusiveValidation {
	    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {
	        this.min = min;
	        this.max = max;
	    }
	    validate(value) {
	        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);
	        if (!(this.min < value && value < this.max)) {
	            const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
	            const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
	            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);
	        }
	    }
	}

	class LengthValidation {
	    constructor(length, minLength, maxLength) {
	        this.length = length;
	        this.minLength = minLength;
	        this.maxLength = maxLength;
	    }
	    validate(value) {
	        if (this.length !== undefined) {
	            if (value.length !== this.length) {
	                throw new ValidationError(`Value length must be exactly ${this.length}.`);
	            }
	            return;
	        }
	        if (this.minLength !== undefined) {
	            if (value.length < this.minLength) {
	                throw new ValidationError(`Value length must be more than ${this.minLength}.`);
	            }
	        }
	        if (this.maxLength !== undefined) {
	            if (value.length > this.maxLength) {
	                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);
	            }
	        }
	    }
	}

	class EnumerationValidation {
	    constructor(enumeration) {
	        this.enumeration = enumeration;
	    }
	    validate(value) {
	        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);
	        if (!this.enumeration.includes(value)) {
	            throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `'${v}'`).join(", ")}`);
	        }
	    }
	}

	class JsonTransform {
	    static checkValues(data, schemaItem) {
	        const values = Array.isArray(data) ? data : [data];
	        for (const value of values) {
	            for (const validation of schemaItem.validations) {
	                if (validation instanceof LengthValidation && schemaItem.repeated) {
	                    validation.validate(data);
	                }
	                else {
	                    validation.validate(value);
	                }
	            }
	        }
	    }
	    static checkTypes(value, schemaItem) {
	        if (schemaItem.repeated && !Array.isArray(value)) {
	            throw new TypeError("Value must be Array");
	        }
	        if (typeof schemaItem.type === "number") {
	            const values = Array.isArray(value) ? value : [value];
	            for (const v of values) {
	                throwIfTypeIsWrong(v, schemaItem.type);
	            }
	        }
	    }
	    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {
	        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name] };
	    }
	}

	class JsonSerializer extends JsonTransform {
	    static serialize(obj, options, replacer, space) {
	        const json = this.toJSON(obj, options);
	        return JSON.stringify(json, replacer, space);
	    }
	    static toJSON(obj, options = {}) {
	        let res;
	        let targetSchema = options.targetSchema;
	        const schemaName = options.schemaName || DEFAULT_SCHEMA;
	        if (isConvertible(obj)) {
	            return obj.toJSON();
	        }
	        if (Array.isArray(obj)) {
	            res = [];
	            for (const item of obj) {
	                res.push(this.toJSON(item, options));
	            }
	        }
	        else if (typeof obj === "object") {
	            if (targetSchema && !schemaStorage.has(targetSchema)) {
	                throw new JsonError("Cannot get schema for `targetSchema` param");
	            }
	            targetSchema = (targetSchema || obj.constructor);
	            if (schemaStorage.has(targetSchema)) {
	                const schema = schemaStorage.get(targetSchema);
	                res = {};
	                const namedSchema = this.getSchemaByName(schema, schemaName);
	                for (const key in namedSchema) {
	                    try {
	                        const item = namedSchema[key];
	                        const objItem = obj[key];
	                        let value;
	                        if ((item.optional && objItem === undefined)
	                            || (item.defaultValue !== undefined && objItem === item.defaultValue)) {
	                            continue;
	                        }
	                        if (!item.optional && objItem === undefined) {
	                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);
	                        }
	                        if (typeof item.type === "number") {
	                            if (item.converter) {
	                                if (item.repeated) {
	                                    value = objItem.map((el) => item.converter.toJSON(el, obj));
	                                }
	                                else {
	                                    value = item.converter.toJSON(objItem, obj);
	                                }
	                            }
	                            else {
	                                value = objItem;
	                            }
	                        }
	                        else {
	                            if (item.repeated) {
	                                value = objItem.map((el) => this.toJSON(el, { schemaName }));
	                            }
	                            else {
	                                value = this.toJSON(objItem, { schemaName });
	                            }
	                        }
	                        this.checkTypes(value, item);
	                        this.checkValues(value, item);
	                        res[item.name || key] = value;
	                    }
	                    catch (e) {
	                        if (e instanceof SerializerError) {
	                            throw e;
	                        }
	                        else {
	                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);
	                        }
	                    }
	                }
	            }
	            else {
	                res = {};
	                for (const key in obj) {
	                    res[key] = this.toJSON(obj[key], { schemaName });
	                }
	            }
	        }
	        else {
	            res = obj;
	        }
	        return res;
	    }
	}

	class JsonParser extends JsonTransform {
	    static parse(data, options) {
	        const obj = JSON.parse(data);
	        return this.fromJSON(obj, options);
	    }
	    static fromJSON(target, options) {
	        const targetSchema = options.targetSchema;
	        const schemaName = options.schemaName || DEFAULT_SCHEMA;
	        const obj = new targetSchema();
	        if (isConvertible(obj)) {
	            return obj.fromJSON(target);
	        }
	        const schema = schemaStorage.get(targetSchema);
	        const namedSchema = this.getSchemaByName(schema, schemaName);
	        const keyErrors = {};
	        if (options.strictProperty && !Array.isArray(target)) {
	            JsonParser.checkStrictProperty(target, namedSchema, schema);
	        }
	        for (const key in namedSchema) {
	            try {
	                const item = namedSchema[key];
	                const name = item.name || key;
	                const value = target[name];
	                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {
	                    continue;
	                }
	                if (!item.optional && value === undefined) {
	                    throw new ParserError(schema, `Property '${name}' is required.`);
	                }
	                this.checkTypes(value, item);
	                this.checkValues(value, item);
	                if (typeof (item.type) === "number") {
	                    if (item.converter) {
	                        if (item.repeated) {
	                            obj[key] = value.map((el) => item.converter.fromJSON(el, obj));
	                        }
	                        else {
	                            obj[key] = item.converter.fromJSON(value, obj);
	                        }
	                    }
	                    else {
	                        obj[key] = value;
	                    }
	                }
	                else {
	                    const newOptions = {
	                        ...options,
	                        targetSchema: item.type,
	                        schemaName,
	                    };
	                    if (item.repeated) {
	                        obj[key] = value.map((el) => this.fromJSON(el, newOptions));
	                    }
	                    else {
	                        obj[key] = this.fromJSON(value, newOptions);
	                    }
	                }
	            }
	            catch (e) {
	                if (!(e instanceof ParserError)) {
	                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);
	                }
	                if (options.strictAllKeys) {
	                    keyErrors[key] = e;
	                }
	                else {
	                    throw e;
	                }
	            }
	        }
	        const keys = Object.keys(keyErrors);
	        if (keys.length) {
	            throw new KeyError(schema, keys, keyErrors);
	        }
	        return obj;
	    }
	    static checkStrictProperty(target, namedSchema, schema) {
	        const jsonProps = Object.keys(target);
	        const schemaProps = Object.keys(namedSchema);
	        const keys = [];
	        for (const key of jsonProps) {
	            if (schemaProps.indexOf(key) === -1) {
	                keys.push(key);
	            }
	        }
	        if (keys.length) {
	            throw new KeyError(schema, keys);
	        }
	    }
	}

	function getValidations(item) {
	    const validations = [];
	    if (item.pattern) {
	        validations.push(new PatternValidation(item.pattern));
	    }
	    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {
	        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {
	            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));
	        }
	        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {
	            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));
	        }
	        if (item.enumeration !== undefined) {
	            validations.push(new EnumerationValidation(item.enumeration));
	        }
	    }
	    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {
	        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {
	            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));
	        }
	    }
	    return validations;
	}
	const JsonProp = (options = {}) => (target, propertyKey) => {
	    const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;
	    let schema;
	    if (!schemaStorage.has(target.constructor)) {
	        schema = schemaStorage.create(target.constructor);
	        schemaStorage.set(target.constructor, schema);
	    }
	    else {
	        schema = schemaStorage.get(target.constructor);
	        if (schema.target !== target.constructor) {
	            schema = schemaStorage.create(target.constructor);
	            schemaStorage.set(target.constructor, schema);
	        }
	    }
	    const defaultSchema = {
	        type: exports.JsonPropTypes.Any,
	        validations: [],
	    };
	    const copyOptions = Object.assign(defaultSchema, options);
	    copyOptions.validations = getValidations(copyOptions);
	    if (typeof copyOptions.type !== "number") {
	        if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {
	            throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);
	        }
	    }
	    let schemaNames;
	    if (Array.isArray(options.schema)) {
	        schemaNames = options.schema;
	    }
	    else {
	        schemaNames = [options.schema || DEFAULT_SCHEMA];
	    }
	    for (const schemaName of schemaNames) {
	        if (!schema.names[schemaName]) {
	            schema.names[schemaName] = {};
	        }
	        const namedSchema = schema.names[schemaName];
	        namedSchema[propertyKey] = copyOptions;
	    }
	};

	exports.JsonSerializer = JsonSerializer;
	exports.JsonParser = JsonParser;
	exports.JsonProp = JsonProp;
	});

	unwrapExports(build$1);
	var build_1$1 = build$1.JsonPropTypes;
	var build_2$1 = build$1.JsonSerializer;
	var build_3$1 = build$1.JsonParser;
	var build_4$1 = build$1.JsonProp;

	let ObjectIdentifier$1 = class ObjectIdentifier {
	    constructor(value) {
	        if (value) {
	            this.value = value;
	        }
	    }
	};
	__decorate([
	    build_3({ type: build_2.ObjectIdentifier })
	], ObjectIdentifier$1.prototype, "value", void 0);
	ObjectIdentifier$1 = __decorate([
	    build_4({ type: build_1.Choice })
	], ObjectIdentifier$1);

	class AlgorithmIdentifier {
	    constructor(params) {
	        Object.assign(this, params);
	    }
	}
	__decorate([
	    build_3({
	        type: build_2.ObjectIdentifier,
	    })
	], AlgorithmIdentifier.prototype, "algorithm", void 0);
	__decorate([
	    build_3({
	        type: build_2.Any,
	        optional: true,
	    })
	], AlgorithmIdentifier.prototype, "parameters", void 0);

	class PrivateKeyInfo {
	    constructor() {
	        this.version = 0;
	        this.privateKeyAlgorithm = new AlgorithmIdentifier();
	        this.privateKey = new ArrayBuffer(0);
	    }
	}
	__decorate([
	    build_3({ type: build_2.Integer })
	], PrivateKeyInfo.prototype, "version", void 0);
	__decorate([
	    build_3({ type: AlgorithmIdentifier })
	], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
	__decorate([
	    build_3({ type: build_2.OctetString })
	], PrivateKeyInfo.prototype, "privateKey", void 0);
	__decorate([
	    build_3({ type: build_2.Any, optional: true })
	], PrivateKeyInfo.prototype, "attributes", void 0);

	class PublicKeyInfo {
	    constructor() {
	        this.publicKeyAlgorithm = new AlgorithmIdentifier();
	        this.publicKey = new ArrayBuffer(0);
	    }
	}
	__decorate([
	    build_3({ type: AlgorithmIdentifier })
	], PublicKeyInfo.prototype, "publicKeyAlgorithm", void 0);
	__decorate([
	    build_3({ type: build_2.BitString })
	], PublicKeyInfo.prototype, "publicKey", void 0);

	const JsonBase64UrlArrayBufferConverter = {
	    fromJSON: (value) => Convert.FromBase64Url(value),
	    toJSON: (value) => Convert.ToBase64Url(new Uint8Array(value)),
	};

	var Browser;
	(function (Browser) {
	    Browser["Unknown"] = "Unknown";
	    Browser["IE"] = "Internet Explorer";
	    Browser["Safari"] = "Safari";
	    Browser["Edge"] = "Edge";
	    Browser["Chrome"] = "Chrome";
	    Browser["Firefox"] = "Firefox Mozilla";
	    Browser["Mobile"] = "Mobile";
	})(Browser || (Browser = {}));
	function BrowserInfo() {
	    const res = {
	        name: Browser.Unknown,
	        version: "0",
	    };
	    const userAgent = self.navigator.userAgent;
	    let reg;
	    if (reg = /edge\/([\d\.]+)/i.exec(userAgent)) {
	        res.name = Browser.Edge;
	        res.version = reg[1];
	    }
	    else if (/msie/i.test(userAgent)) {
	        res.name = Browser.IE;
	        res.version = /msie ([\d\.]+)/i.exec(userAgent)[1];
	    }
	    else if (/Trident/i.test(userAgent)) {
	        res.name = Browser.IE;
	        res.version = /rv:([\d\.]+)/i.exec(userAgent)[1];
	    }
	    else if (/chrome/i.test(userAgent)) {
	        res.name = Browser.Chrome;
	        res.version = /chrome\/([\d\.]+)/i.exec(userAgent)[1];
	    }
	    else if (/firefox/i.test(userAgent)) {
	        res.name = Browser.Firefox;
	        res.version = /firefox\/([\d\.]+)/i.exec(userAgent)[1];
	    }
	    else if (/mobile/i.test(userAgent)) {
	        res.name = Browser.Mobile;
	        res.version = /mobile\/([\w]+)/i.exec(userAgent)[1];
	    }
	    else if (/safari/i.test(userAgent)) {
	        res.name = Browser.Safari;
	        res.version = /version\/([\d\.]+)/i.exec(userAgent)[1];
	    }
	    return res;
	}
	function concat(...buf) {
	    const res = new Uint8Array(buf.map((item) => item.length).reduce((prev, cur) => prev + cur));
	    let offset = 0;
	    buf.forEach((item, index) => {
	        for (let i = 0; i < item.length; i++) {
	            res[offset + i] = item[i];
	        }
	        offset += item.length;
	    });
	    return res;
	}

	const AsnIntegerArrayBufferConverter = {
	    fromASN: (value) => {
	        const valueHex = value.valueBlock.valueHex;
	        return !(new Uint8Array(valueHex)[0])
	            ? value.valueBlock.valueHex.slice(1)
	            : value.valueBlock.valueHex;
	    },
	    toASN: (value) => {
	        const valueHex = new Uint8Array(value)[0] > 127
	            ? concat(new Uint8Array([0]), new Uint8Array(value))
	            : new Uint8Array(value);
	        return new asn1_26({ valueHex: new Uint8Array(valueHex).buffer });
	    },
	};

	class RsaPrivateKey {
	    constructor() {
	        this.version = 0;
	        this.modulus = new ArrayBuffer(0);
	        this.publicExponent = new ArrayBuffer(0);
	        this.privateExponent = new ArrayBuffer(0);
	        this.prime1 = new ArrayBuffer(0);
	        this.prime2 = new ArrayBuffer(0);
	        this.exponent1 = new ArrayBuffer(0);
	        this.exponent2 = new ArrayBuffer(0);
	        this.coefficient = new ArrayBuffer(0);
	    }
	}
	__decorate([
	    build_3({ type: build_2.Integer, converter: build_8 })
	], RsaPrivateKey.prototype, "version", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "n", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "modulus", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "e", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "publicExponent", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "d", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "privateExponent", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "p", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "prime1", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "q", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "prime2", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "dp", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "exponent1", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "dq", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "exponent2", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "qi", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPrivateKey.prototype, "coefficient", void 0);
	__decorate([
	    build_3({ type: build_2.Any, optional: true })
	], RsaPrivateKey.prototype, "otherPrimeInfos", void 0);

	class RsaPublicKey {
	    constructor() {
	        this.modulus = new ArrayBuffer(0);
	        this.publicExponent = new ArrayBuffer(0);
	    }
	}
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "n", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPublicKey.prototype, "modulus", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerArrayBufferConverter }),
	    build_4$1({ name: "e", converter: JsonBase64UrlArrayBufferConverter })
	], RsaPublicKey.prototype, "publicExponent", void 0);

	let EcPublicKey = class EcPublicKey {
	    constructor(value) {
	        this.value = new ArrayBuffer(0);
	        if (value) {
	            this.value = value;
	        }
	    }
	    toJSON() {
	        let bytes = new Uint8Array(this.value);
	        if (bytes[0] !== 0x04) {
	            throw new CryptoError("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");
	        }
	        bytes = new Uint8Array(this.value.slice(1));
	        const size = bytes.length / 2;
	        const offset = 0;
	        const json = {
	            x: Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),
	            y: Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size)),
	        };
	        return json;
	    }
	    fromJSON(json) {
	        if (!("x" in json)) {
	            throw new Error("x: Missing required property");
	        }
	        if (!("y" in json)) {
	            throw new Error("y: Missing required property");
	        }
	        const x = Convert.FromBase64Url(json.x);
	        const y = Convert.FromBase64Url(json.y);
	        const value = concat(new Uint8Array([0x04]), new Uint8Array(x), new Uint8Array(y));
	        this.value = new Uint8Array(value).buffer;
	        return this;
	    }
	};
	__decorate([
	    build_3({ type: build_2.OctetString })
	], EcPublicKey.prototype, "value", void 0);
	EcPublicKey = __decorate([
	    build_4({ type: build_1.Choice })
	], EcPublicKey);

	class EcPrivateKey {
	    constructor() {
	        this.version = 1;
	        this.privateKey = new ArrayBuffer(0);
	    }
	    fromJSON(json) {
	        if (!("d" in json)) {
	            throw new Error("d: Missing required property");
	        }
	        this.privateKey = Convert.FromBase64Url(json.d);
	        if ("x" in json) {
	            const publicKey = new EcPublicKey();
	            publicKey.fromJSON(json);
	            this.publicKey = build_6.toASN(publicKey).valueBlock.valueHex;
	        }
	        return this;
	    }
	    toJSON() {
	        const jwk = {};
	        jwk.d = Convert.ToBase64Url(this.privateKey);
	        if (this.publicKey) {
	            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());
	        }
	        return jwk;
	    }
	}
	__decorate([
	    build_3({ type: build_2.Integer, converter: build_8 })
	], EcPrivateKey.prototype, "version", void 0);
	__decorate([
	    build_3({ type: build_2.OctetString })
	], EcPrivateKey.prototype, "privateKey", void 0);
	__decorate([
	    build_3({ context: 0, type: build_2.Any, optional: true })
	], EcPrivateKey.prototype, "parameters", void 0);
	__decorate([
	    build_3({ context: 1, type: build_2.BitString, optional: true })
	], EcPrivateKey.prototype, "publicKey", void 0);

	const AsnIntegerWithoutPaddingConverter = {
	    fromASN: (value) => {
	        const bytes = new Uint8Array(value.valueBlock.valueHex);
	        return (bytes[0] === 0)
	            ? bytes.buffer.slice(1)
	            : bytes.buffer;
	    },
	    toASN: (value) => {
	        const bytes = new Uint8Array(value);
	        if (bytes[0] > 127) {
	            const newValue = new Uint8Array(bytes.length + 1);
	            newValue.set(bytes, 1);
	            return new asn1_26({ valueHex: newValue });
	        }
	        return new asn1_26({ valueHex: value });
	    },
	};
	class EcDsaSignature {
	    constructor() {
	        this.r = new ArrayBuffer(0);
	        this.s = new ArrayBuffer(0);
	    }
	}
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerWithoutPaddingConverter })
	], EcDsaSignature.prototype, "r", void 0);
	__decorate([
	    build_3({ type: build_2.Integer, converter: AsnIntegerWithoutPaddingConverter })
	], EcDsaSignature.prototype, "s", void 0);

	class CryptoKey$1 extends CryptoKey {
	    constructor(algorithm, extractable, type, usages) {
	        super();
	        this.extractable = extractable;
	        this.type = type;
	        this.usages = usages;
	        this.algorithm = { ...algorithm };
	    }
	}

	function isAlgorithm(algorithm, name) {
	    return algorithm.name.toUpperCase() === name.toUpperCase();
	}

	class AesCryptoKey extends CryptoKey$1 {
	    constructor(algorithm, extractable, usages, raw) {
	        super(algorithm, extractable, "secret", usages);
	        this.raw = raw;
	    }
	    toJSON() {
	        const jwk = {
	            kty: "oct",
	            alg: this.getJwkAlgorithm(),
	            k: Convert.ToBase64Url(this.raw),
	            ext: this.extractable,
	            key_ops: this.usages,
	        };
	        return jwk;
	    }
	    getJwkAlgorithm() {
	        switch (this.algorithm.name.toUpperCase()) {
	            case "AES-CBC":
	                return `A${this.algorithm.length}CBC`;
	            case "AES-CTR":
	                return `A${this.algorithm.length}CTR`;
	            case "AES-GCM":
	                return `A${this.algorithm.length}GCM`;
	            case "AES-ECB":
	                return `A${this.algorithm.length}ECB`;
	            default:
	                throw new AlgorithmError("Unsupported algorithm name");
	        }
	    }
	}

	class AesCrypto {
	    static checkLib() {
	        if (typeof (asmCrypto) === "undefined") {
	            throw new OperationError("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project");
	        }
	    }
	    static checkCryptoKey(key) {
	        if (!(key instanceof AesCryptoKey)) {
	            throw new TypeError("key: Is not AesCryptoKey");
	        }
	    }
	    static async generateKey(algorithm, extractable, usages) {
	        this.checkLib();
	        const raw = nativeCrypto.getRandomValues(new Uint8Array(algorithm.length / 8));
	        return new AesCryptoKey(algorithm, extractable, usages, raw);
	    }
	    static async encrypt(algorithm, key, data) {
	        return this.cipher(algorithm, key, data, true);
	    }
	    static async decrypt(algorithm, key, data) {
	        return this.cipher(algorithm, key, data, false);
	    }
	    static async exportKey(format, key) {
	        this.checkLib();
	        switch (format) {
	            case "jwk":
	                return key.toJSON();
	            case "raw":
	                return key.raw.buffer;
	            default:
	                throw new OperationError("format: Must be 'jwk' or 'raw'");
	        }
	    }
	    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
	        this.checkLib();
	        let raw;
	        if (isJWK(keyData)) {
	            raw = Convert.FromBase64Url(keyData.k);
	        }
	        else {
	            raw = BufferSourceConverter.toArrayBuffer(keyData);
	        }
	        switch (raw.byteLength << 3) {
	            case 128:
	            case 192:
	            case 256:
	                break;
	            default:
	                throw new OperationError("keyData: Is wrong key length");
	        }
	        const key = new AesCryptoKey({ name: algorithm.name, length: raw.byteLength << 3 }, extractable, keyUsages, new Uint8Array(raw));
	        return key;
	    }
	    static async cipher(algorithm, key, data, encrypt) {
	        this.checkLib();
	        const action = encrypt ? "encrypt" : "decrypt";
	        let res;
	        if (isAlgorithm(algorithm, AesCrypto.AesCBC)) {
	            const iv = BufferSourceConverter.toArrayBuffer(algorithm.iv);
	            res = asmCrypto.AES_CBC[action](data, key.raw, undefined, iv);
	        }
	        else if (isAlgorithm(algorithm, AesCrypto.AesGCM)) {
	            const iv = BufferSourceConverter.toArrayBuffer(algorithm.iv);
	            let additionalData;
	            if (algorithm.additionalData) {
	                additionalData = BufferSourceConverter.toArrayBuffer(algorithm.additionalData);
	            }
	            const tagLength = (algorithm.tagLength || 128) / 8;
	            res = asmCrypto.AES_GCM[action](data, key.raw, iv, additionalData, tagLength);
	        }
	        else if (isAlgorithm(algorithm, AesCrypto.AesECB)) {
	            res = asmCrypto.AES_ECB[action](data, key.raw, true);
	        }
	        else {
	            throw new OperationError(`algorithm: Is not recognized`);
	        }
	        return res.buffer;
	    }
	}
	AesCrypto.AesCBC = "AES-CBC";
	AesCrypto.AesECB = "AES-ECB";
	AesCrypto.AesGCM = "AES-GCM";

	class AesCbcProvider$1 extends AesCbcProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return AesCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onEncrypt(algorithm, key, data) {
	        return AesCrypto.encrypt(algorithm, key, data);
	    }
	    async onDecrypt(algorithm, key, data) {
	        return AesCrypto.decrypt(algorithm, key, data);
	    }
	    async onExportKey(format, key) {
	        return AesCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return AesCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async checkCryptoKey(key, keyUsage) {
	        super.checkCryptoKey(key, keyUsage);
	        AesCrypto.checkCryptoKey(key);
	    }
	}

	class AesEcbProvider$1 extends AesEcbProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return AesCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onEncrypt(algorithm, key, data) {
	        return AesCrypto.encrypt(algorithm, key, data);
	    }
	    async onDecrypt(algorithm, key, data) {
	        return AesCrypto.decrypt(algorithm, key, data);
	    }
	    async onExportKey(format, key) {
	        return AesCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return AesCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async checkCryptoKey(key, keyUsage) {
	        super.checkCryptoKey(key, keyUsage);
	        AesCrypto.checkCryptoKey(key);
	    }
	}

	class AesGcmProvider$1 extends AesGcmProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return AesCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onEncrypt(algorithm, key, data) {
	        return AesCrypto.encrypt(algorithm, key, data);
	    }
	    async onDecrypt(algorithm, key, data) {
	        return AesCrypto.decrypt(algorithm, key, data);
	    }
	    async onExportKey(format, key) {
	        return AesCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return AesCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async checkCryptoKey(key, keyUsage) {
	        super.checkCryptoKey(key, keyUsage);
	        AesCrypto.checkCryptoKey(key);
	    }
	}

	class AesCtrProvider$1 extends AesCtrProvider {
	    async onEncrypt(algorithm, key, data) {
	        throw new Error("Method not implemented.");
	    }
	    async onDecrypt(algorithm, key, data) {
	        throw new Error("Method not implemented.");
	    }
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        throw new Error("Method not implemented.");
	    }
	    async onExportKey(format, key) {
	        throw new Error("Method not implemented.");
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        throw new Error("Method not implemented.");
	    }
	}

	class AesKwProvider$1 extends AesKwProvider {
	    async onEncrypt(algorithm, key, data) {
	        throw new Error("Method not implemented.");
	    }
	    async onDecrypt(algorithm, key, data) {
	        throw new Error("Method not implemented.");
	    }
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        throw new Error("Method not implemented.");
	    }
	    async onExportKey(format, key) {
	        throw new Error("Method not implemented.");
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        throw new Error("Method not implemented.");
	    }
	}

	class RsaCryptoKey extends CryptoKey$1 {
	    constructor(algorithm, extractable, type, usages, data) {
	        super(algorithm, extractable, type, usages);
	        this.data = data;
	    }
	}

	class RsaCrypto {
	    static checkLib() {
	        if (typeof (asmCrypto) === "undefined") {
	            throw new OperationError("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project");
	        }
	    }
	    static checkCryptoKey(key) {
	        if (!(key instanceof RsaCryptoKey)) {
	            throw new TypeError("key: Is not RsaCryptoKey");
	        }
	    }
	    static async generateKey(algorithm, extractable, keyUsages) {
	        this.checkLib();
	        const pubExp = algorithm.publicExponent[0] === 3 ? 3 : 65537;
	        const rsaKey = asmCrypto.RSA.generateKey(algorithm.modulusLength, pubExp);
	        const hashAlgorithm = algorithm.hash.name.toUpperCase();
	        const privateKey = new RsaCryptoKey({ ...algorithm, hash: { name: hashAlgorithm } }, extractable, "private", keyUsages.filter((usage) => ~this.privateUsages.indexOf(usage)), rsaKey);
	        const publicKey = new RsaCryptoKey({ ...algorithm, hash: { name: hashAlgorithm } }, true, "public", keyUsages.filter((usage) => ~this.publicUsages.indexOf(usage)), rsaKey);
	        return { privateKey, publicKey };
	    }
	    static async exportKey(format, key) {
	        this.checkLib();
	        switch (format) {
	            case "pkcs8":
	                return this.exportPkcs8Key(key);
	            case "spki":
	                return this.exportSpkiKey(key);
	            case "jwk":
	                return this.exportJwkKey(key);
	            default:
	                throw new OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
	        }
	    }
	    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
	        this.checkLib();
	        let asmKey;
	        switch (format) {
	            case "pkcs8":
	                asmKey = this.importPkcs8Key(keyData);
	                break;
	            case "spki":
	                asmKey = this.importSpkiKey(keyData);
	                break;
	            case "jwk":
	                asmKey = this.importJwkKey(keyData);
	                break;
	            default:
	                throw new OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
	        }
	        const key = new RsaCryptoKey({
	            publicExponent: asmKey[1][1] === 1
	                ? asmKey[1].slice(1)
	                : asmKey[1].slice(3),
	            modulusLength: asmKey[0].byteLength << 3,
	            ...algorithm,
	        }, extractable, asmKey.length === 2 ? "public" : "private", keyUsages, asmKey);
	        return key;
	    }
	    static exportPkcs8Key(key) {
	        const keyInfo = new PrivateKeyInfo();
	        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
	        keyInfo.privateKeyAlgorithm.parameters = null;
	        keyInfo.privateKey = build_6.serialize(this.exportAsmKey(key.data));
	        return build_6.serialize(keyInfo);
	    }
	    static importPkcs8Key(data) {
	        const keyInfo = build_5.parse(data, PrivateKeyInfo);
	        const privateKey = build_5.parse(keyInfo.privateKey, RsaPrivateKey);
	        return this.importAsmKey(privateKey);
	    }
	    static importSpkiKey(data) {
	        const keyInfo = build_5.parse(data, PublicKeyInfo);
	        const publicKey = build_5.parse(keyInfo.publicKey, RsaPublicKey);
	        return this.importAsmKey(publicKey);
	    }
	    static exportSpkiKey(key) {
	        const publicKey = new RsaPublicKey();
	        publicKey.modulus = key.data[0].buffer;
	        publicKey.publicExponent = key.data[1][1] === 1
	            ? key.data[1].buffer.slice(1)
	            : key.data[1].buffer.slice(3);
	        const keyInfo = new PublicKeyInfo();
	        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
	        keyInfo.publicKeyAlgorithm.parameters = null;
	        keyInfo.publicKey = build_6.serialize(publicKey);
	        return build_6.serialize(keyInfo);
	    }
	    static importJwkKey(data) {
	        let key;
	        if (data.d) {
	            key = build_3$1.fromJSON(data, { targetSchema: RsaPrivateKey });
	        }
	        else {
	            key = build_3$1.fromJSON(data, { targetSchema: RsaPublicKey });
	        }
	        return this.importAsmKey(key);
	    }
	    static exportJwkKey(key) {
	        const asnKey = this.exportAsmKey(key.data);
	        const jwk = build_2$1.toJSON(asnKey);
	        jwk.ext = true;
	        jwk.key_ops = key.usages;
	        jwk.kty = "RSA";
	        jwk.alg = this.getJwkAlgorithm(key.algorithm);
	        return jwk;
	    }
	    static getJwkAlgorithm(algorithm) {
	        switch (algorithm.name.toUpperCase()) {
	            case "RSA-OAEP":
	                const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
	                return `RSA-OAEP${mdSize !== "1" ? `-${mdSize}` : ""}`;
	            case "RSASSA-PKCS1-V1_5":
	                return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
	            case "RSA-PSS":
	                return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
	            default:
	                throw new OperationError("algorithm: Is not recognized");
	        }
	    }
	    static exportAsmKey(asmKey) {
	        let key;
	        if (asmKey.length > 2) {
	            const privateKey = new RsaPrivateKey();
	            privateKey.privateExponent = asmKey[2].buffer;
	            privateKey.prime1 = asmKey[3].buffer;
	            privateKey.prime2 = asmKey[4].buffer;
	            privateKey.exponent1 = asmKey[5].buffer;
	            privateKey.exponent2 = asmKey[6].buffer;
	            privateKey.coefficient = asmKey[7].buffer;
	            key = privateKey;
	        }
	        else {
	            key = new RsaPublicKey();
	        }
	        key.modulus = asmKey[0].buffer;
	        key.publicExponent = asmKey[1][1] === 1
	            ? asmKey[1].buffer.slice(1)
	            : asmKey[1].buffer.slice(3);
	        return key;
	    }
	    static importAsmKey(key) {
	        const expPadding = new Uint8Array(4 - key.publicExponent.byteLength);
	        const asmKey = [
	            new Uint8Array(key.modulus),
	            concat(expPadding, new Uint8Array(key.publicExponent)),
	        ];
	        if (key instanceof RsaPrivateKey) {
	            asmKey.push(new Uint8Array(key.privateExponent));
	            asmKey.push(new Uint8Array(key.prime1));
	            asmKey.push(new Uint8Array(key.prime2));
	            asmKey.push(new Uint8Array(key.exponent1));
	            asmKey.push(new Uint8Array(key.exponent2));
	            asmKey.push(new Uint8Array(key.coefficient));
	        }
	        return asmKey;
	    }
	}
	RsaCrypto.RsaSsa = "RSASSA-PKCS1-v1_5";
	RsaCrypto.RsaPss = "RSA-PSS";
	RsaCrypto.RsaOaep = "RSA-OAEP";
	RsaCrypto.privateUsages = ["sign", "decrypt", "unwrapKey"];
	RsaCrypto.publicUsages = ["verify", "encrypt", "wrapKey"];

	class RsaOaepProvider$1 extends RsaOaepProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return RsaCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onExportKey(format, key) {
	        return RsaCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return RsaCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async onEncrypt(algorithm, key, data) {
	        RsaCrypto.checkLib();
	        return this.cipher(algorithm, key, data, true);
	    }
	    async onDecrypt(algorithm, key, data) {
	        RsaCrypto.checkLib();
	        return this.cipher(algorithm, key, data, false);
	    }
	    cipher(algorithm, key, data, encrypt) {
	        const fn = this.getOperation(key.algorithm, encrypt);
	        let label;
	        if (algorithm.label) {
	            label = BufferSourceConverter.toArrayBuffer(algorithm.label);
	        }
	        return fn(data, key.data, label).slice(0).buffer;
	    }
	    getOperation(keyAlgorithm, encrypt) {
	        const action = encrypt ? "encrypt" : "decrypt";
	        switch (keyAlgorithm.hash.name) {
	            case "SHA-1":
	                return asmCrypto.RSA_OAEP_SHA1[action];
	            case "SHA-256":
	                return asmCrypto.RSA_OAEP_SHA256[action];
	            case "SHA-512":
	                return asmCrypto.RSA_OAEP_SHA512[action];
	            default:
	                throw new AlgorithmError("keyAlgorithm.hash: Is not recognized");
	        }
	    }
	}

	class RsaPssProvider$1 extends RsaPssProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return RsaCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onExportKey(format, key) {
	        return RsaCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return RsaCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async onSign(algorithm, key, data) {
	        RsaCrypto.checkLib();
	        const fn = this.getOperation(key.algorithm, true);
	        return fn(data, key.data, algorithm.saltLength).buffer;
	    }
	    async onVerify(algorithm, key, signature, data) {
	        RsaCrypto.checkLib();
	        const fn = this.getOperation(key.algorithm, false);
	        return fn(signature, data, key.data, algorithm.saltLength);
	    }
	    async checkCryptoKey(key, keyUsage) {
	        super.checkCryptoKey(key, keyUsage);
	        RsaCrypto.checkCryptoKey(key);
	    }
	    getOperation(keyAlgorithm, sign) {
	        const action = sign ? "sign" : "verify";
	        switch (keyAlgorithm.hash.name) {
	            case "SHA-1":
	                return asmCrypto.RSA_PSS_SHA1[action];
	            case "SHA-256":
	                return asmCrypto.RSA_PSS_SHA256[action];
	            case "SHA-512":
	                return asmCrypto.RSA_PSS_SHA512[action];
	            default:
	                throw new AlgorithmError("keyAlgorithm.hash: Is not recognized");
	        }
	    }
	}

	class RsaSsaProvider$1 extends RsaSsaProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return RsaCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onExportKey(format, key) {
	        return RsaCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return RsaCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async onSign(algorithm, key, data) {
	        RsaCrypto.checkLib();
	        const fn = this.getOperation(key.algorithm, true);
	        return fn(data, key.data).buffer;
	    }
	    async onVerify(algorithm, key, signature, data) {
	        RsaCrypto.checkLib();
	        const fn = this.getOperation(key.algorithm, false);
	        return fn(signature, data, key.data);
	    }
	    async checkCryptoKey(key, keyUsage) {
	        super.checkCryptoKey(key, keyUsage);
	        RsaCrypto.checkCryptoKey(key);
	    }
	    getOperation(keyAlgorithm, sign) {
	        const action = sign ? "sign" : "verify";
	        switch (keyAlgorithm.hash.name) {
	            case "SHA-1":
	                return asmCrypto.RSA_PKCS1_v1_5_SHA1[action];
	            case "SHA-256":
	                return asmCrypto.RSA_PKCS1_v1_5_SHA256[action];
	            case "SHA-512":
	                return asmCrypto.RSA_PKCS1_v1_5_SHA512[action];
	            default:
	                throw new AlgorithmError("keyAlgorithm.hash: Is not recognized");
	        }
	    }
	}

	const namedOIDs = {
	    "1.2.840.10045.3.1.7": "P-256",
	    "P-256": "1.2.840.10045.3.1.7",
	    "1.3.132.0.34": "P-384",
	    "P-384": "1.3.132.0.34",
	    "1.3.132.0.35": "P-521",
	    "P-521": "1.3.132.0.35",
	    "1.3.132.0.10": "K-256",
	    "K-256": "1.3.132.0.10",
	};
	function getOidByNamedCurve(namedCurve) {
	    const oid = namedOIDs[namedCurve];
	    if (!oid) {
	        throw new OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
	    }
	    return oid;
	}

	class EcCryptoKey extends CryptoKey$1 {
	    constructor(algorithm, extractable, type, usages, data) {
	        super(algorithm, extractable, type, usages);
	        this.data = data;
	    }
	}

	class EcCrypto {
	    static checkLib() {
	        if (typeof (elliptic) === "undefined") {
	            throw new OperationError("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/elliptic.js' script to your project");
	        }
	    }
	    static async generateKey(algorithm, extractable, keyUsages) {
	        this.checkLib();
	        const key = this.initEcKey(algorithm.namedCurve);
	        const ecKey = key.genKeyPair();
	        ecKey.getPublic();
	        const prvKey = new EcCryptoKey({ ...algorithm }, extractable, "private", keyUsages.filter((usage) => ~this.privateUsages.indexOf(usage)), ecKey);
	        const pubKey = new EcCryptoKey({ ...algorithm }, true, "public", keyUsages.filter((usage) => ~this.publicUsages.indexOf(usage)), ecKey);
	        return {
	            privateKey: prvKey,
	            publicKey: pubKey,
	        };
	    }
	    static checkCryptoKey(key) {
	        if (!(key instanceof EcCryptoKey)) {
	            throw new TypeError("key: Is not EcCryptoKey");
	        }
	    }
	    static concat(...buf) {
	        const res = new Uint8Array(buf.map((item) => item.length).reduce((prev, cur) => prev + cur));
	        let offset = 0;
	        buf.forEach((item, index) => {
	            for (let i = 0; i < item.length; i++) {
	                res[offset + i] = item[i];
	            }
	            offset += item.length;
	        });
	        return res;
	    }
	    static async exportKey(format, key) {
	        this.checkLib();
	        switch (format) {
	            case "pkcs8":
	                return this.exportPkcs8Key(key);
	            case "spki":
	                return this.exportSpkiKey(key);
	            case "jwk":
	                return this.exportJwkKey(key);
	            case "raw":
	                return new Uint8Array(key.data.getPublic("der")).buffer;
	            default:
	                throw new OperationError("format: Must be 'jwk', 'raw, 'pkcs8' or 'spki'");
	        }
	    }
	    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
	        this.checkLib();
	        let ecKey;
	        switch (format) {
	            case "pkcs8":
	                ecKey = this.importPkcs8Key(keyData, algorithm.namedCurve);
	                break;
	            case "spki":
	                ecKey = this.importSpkiKey(keyData, algorithm.namedCurve);
	                break;
	            case "raw":
	                ecKey = this.importEcKey(new EcPublicKey(keyData), algorithm.namedCurve);
	                break;
	            case "jwk":
	                ecKey = this.importJwkKey(keyData);
	                break;
	            default:
	                throw new OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
	        }
	        const key = new EcCryptoKey({
	            ...algorithm,
	        }, extractable, ecKey.priv ? "private" : "public", keyUsages, ecKey);
	        return key;
	    }
	    static getNamedCurve(wcNamedCurve) {
	        const crv = wcNamedCurve.toUpperCase();
	        let res = "";
	        if (["P-256", "P-384", "P-521"].indexOf(crv) > -1) {
	            res = crv.replace("-", "").toLowerCase();
	        }
	        else if (crv === "K-256") {
	            res = "secp256k1";
	        }
	        else {
	            throw new OperationError(`Unsupported named curve '${wcNamedCurve}'`);
	        }
	        return res;
	    }
	    static initEcKey(namedCurve) {
	        return elliptic.ec(this.getNamedCurve(namedCurve));
	    }
	    static exportPkcs8Key(key) {
	        const keyInfo = new PrivateKeyInfo();
	        keyInfo.privateKeyAlgorithm.algorithm = this.ASN_ALGORITHM;
	        keyInfo.privateKeyAlgorithm.parameters = build_6.serialize(new ObjectIdentifier$1(getOidByNamedCurve(key.algorithm.namedCurve)));
	        keyInfo.privateKey = build_6.serialize(this.exportEcKey(key));
	        return build_6.serialize(keyInfo);
	    }
	    static importPkcs8Key(data, namedCurve) {
	        const keyInfo = build_5.parse(data, PrivateKeyInfo);
	        const privateKey = build_5.parse(keyInfo.privateKey, EcPrivateKey);
	        return this.importEcKey(privateKey, namedCurve);
	    }
	    static importSpkiKey(data, namedCurve) {
	        const keyInfo = build_5.parse(data, PublicKeyInfo);
	        const publicKey = new EcPublicKey(keyInfo.publicKey);
	        return this.importEcKey(publicKey, namedCurve);
	    }
	    static exportSpkiKey(key) {
	        const publicKey = new EcPublicKey(new Uint8Array(key.data.getPublic("der")).buffer);
	        const keyInfo = new PublicKeyInfo();
	        keyInfo.publicKeyAlgorithm.algorithm = this.ASN_ALGORITHM;
	        keyInfo.publicKeyAlgorithm.parameters = build_6.serialize(new ObjectIdentifier$1(getOidByNamedCurve(key.algorithm.namedCurve)));
	        keyInfo.publicKey = publicKey.value;
	        return build_6.serialize(keyInfo);
	    }
	    static importJwkKey(data) {
	        let key;
	        if (data.d) {
	            key = build_3$1.fromJSON(data, { targetSchema: EcPrivateKey });
	        }
	        else {
	            key = build_3$1.fromJSON(data, { targetSchema: EcPublicKey });
	        }
	        return this.importEcKey(key, data.crv);
	    }
	    static exportJwkKey(key) {
	        const asnKey = this.exportEcKey(key);
	        const jwk = build_2$1.toJSON(asnKey);
	        jwk.ext = true;
	        jwk.key_ops = key.usages;
	        jwk.crv = key.algorithm.namedCurve;
	        jwk.kty = "EC";
	        return jwk;
	    }
	    static exportEcKey(ecKey) {
	        if (ecKey.type === "private") {
	            const privateKey = new EcPrivateKey();
	            const point = new Uint8Array(ecKey.data.getPrivate("der").toArray());
	            const pointPad = new Uint8Array(this.getPointSize(ecKey.algorithm.namedCurve) - point.length);
	            privateKey.privateKey = concat(pointPad, point);
	            privateKey.publicKey = new Uint8Array(ecKey.data.getPublic("der"));
	            return privateKey;
	        }
	        else if (ecKey.data.pub) {
	            return new EcPublicKey(new Uint8Array(ecKey.data.getPublic("der")).buffer);
	        }
	        else {
	            throw new Error("Cannot get private or public key");
	        }
	    }
	    static importEcKey(key, namedCurve) {
	        const ecKey = this.initEcKey(namedCurve);
	        if (key instanceof EcPublicKey) {
	            return ecKey.keyFromPublic(new Uint8Array(key.value));
	        }
	        return ecKey.keyFromPrivate(new Uint8Array(key.privateKey));
	    }
	    static getPointSize(namedCurve) {
	        switch (namedCurve) {
	            case "P-256":
	            case "K-256":
	                return 32;
	            case "P-384":
	                return 48;
	            case "P-521":
	                return 66;
	        }
	        throw new Error("namedCurve: Is not recognized");
	    }
	}
	EcCrypto.privateUsages = ["sign", "deriveKey", "deriveBits"];
	EcCrypto.publicUsages = ["verify"];
	EcCrypto.ASN_ALGORITHM = "1.2.840.10045.2.1";

	class EcdhProvider$1 extends EcdhProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return EcCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onExportKey(format, key) {
	        return EcCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return EcCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async onDeriveBits(algorithm, baseKey, length) {
	        EcCrypto.checkLib();
	        const shared = baseKey.data.derive(algorithm.public.data.getPublic());
	        let array = new Uint8Array(shared.toArray());
	        let len = array.length;
	        len = (len > 32 ? (len > 48 ? 66 : 48) : 32);
	        if (array.length < len) {
	            array = EcCrypto.concat(new Uint8Array(len - array.length), array);
	        }
	        const buf = array.slice(0, length / 8).buffer;
	        return buf;
	    }
	    async checkCryptoKey(key, keyUsage) {
	        super.checkCryptoKey(key, keyUsage);
	        EcCrypto.checkCryptoKey(key);
	    }
	}

	function b2a(buffer) {
	    const buf = new Uint8Array(buffer);
	    const res = [];
	    for (let i = 0; i < buf.length; i++) {
	        res.push(buf[i]);
	    }
	    return res;
	}
	function hex2buffer(hexString, padded) {
	    if (hexString.length % 2) {
	        hexString = "0" + hexString;
	    }
	    let res = new Uint8Array(hexString.length / 2);
	    for (let i = 0; i < hexString.length; i++) {
	        const c = hexString.slice(i, ++i + 1);
	        res[(i - 1) / 2] = parseInt(c, 16);
	    }
	    if (padded) {
	        let len = res.length;
	        len = len > 32 ? len > 48 ? 66 : 48 : 32;
	        if (res.length < len) {
	            res = EcCrypto.concat(new Uint8Array(len - res.length), res);
	        }
	    }
	    return res;
	}
	function buffer2hex(buffer, padded) {
	    let res = "";
	    for (let i = 0; i < buffer.length; i++) {
	        const char = buffer[i].toString(16);
	        res += char.length % 2 ? "0" + char : char;
	    }
	    if (padded) {
	        let len = buffer.length;
	        len = len > 32 ? len > 48 ? 66 : 48 : 32;
	        if ((res.length / 2) < len) {
	            res = new Array(len * 2 - res.length + 1).join("0") + res;
	        }
	    }
	    return res;
	}
	class EcdsaProvider$1 extends EcdsaProvider {
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return EcCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onExportKey(format, key) {
	        return EcCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return EcCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async onSign(algorithm, key, data) {
	        EcCrypto.checkLib();
	        const crypto = new Crypto$1();
	        let array;
	        const hash = await crypto.subtle.digest(algorithm.hash, data);
	        array = b2a(hash);
	        const signature = await key.data.sign(array);
	        const hexSignature = buffer2hex(signature.r.toArray(), true) + buffer2hex(signature.s.toArray(), true);
	        return hex2buffer(hexSignature).buffer;
	    }
	    async onVerify(algorithm, key, signature, data) {
	        EcCrypto.checkLib();
	        const crypto = new Crypto$1();
	        const sig = {
	            r: new Uint8Array(signature.slice(0, signature.byteLength / 2)),
	            s: new Uint8Array(signature.slice(signature.byteLength / 2)),
	        };
	        const hashedData = await crypto.subtle.digest(algorithm.hash, data);
	        const array = b2a(hashedData);
	        return key.data.verify(array, sig);
	    }
	    async checkCryptoKey(key, keyUsage) {
	        super.checkCryptoKey(key, keyUsage);
	        EcCrypto.checkCryptoKey(key);
	    }
	}

	class ShaCrypto {
	    static checkLib() {
	        if (typeof (asmCrypto) === "undefined") {
	            throw new OperationError("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project");
	        }
	    }
	    static async digest(algorithm, data) {
	        this.checkLib();
	        const mech = asmCrypto[algorithm.name.replace("-", "")];
	        return mech.bytes(data).buffer;
	    }
	}

	class Sha1Provider extends ProviderCrypto {
	    constructor() {
	        super(...arguments);
	        this.name = "SHA-1";
	        this.usages = [];
	    }
	    async onDigest(algorithm, data) {
	        return ShaCrypto.digest(algorithm, data);
	    }
	}

	class Sha256Provider extends Sha1Provider {
	    constructor() {
	        super(...arguments);
	        this.name = "SHA-256";
	    }
	}

	class Sha512Provider extends Sha1Provider {
	    constructor() {
	        super(...arguments);
	        this.name = "SHA-512";
	    }
	}

	class PbkdfCryptoKey extends CryptoKey$1 {
	    constructor(algorithm, extractable, usages, raw) {
	        super(algorithm, extractable, "secret", usages);
	        this.raw = raw;
	    }
	}

	class Pbkdf2Provider$1 extends Pbkdf2Provider {
	    checkLib() {
	        if (typeof (asmCrypto) === "undefined") {
	            throw new OperationError("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js' script to your project");
	        }
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        this.checkLib();
	        return new PbkdfCryptoKey(algorithm, extractable, keyUsages, BufferSourceConverter.toUint8Array(keyData));
	    }
	    async onDeriveBits(algorithm, baseKey, length) {
	        this.checkLib();
	        let result;
	        const salt = BufferSourceConverter.toUint8Array(algorithm.salt);
	        const password = baseKey.raw;
	        switch (algorithm.hash.name.toUpperCase()) {
	            case "SHA-1":
	                result = asmCrypto.PBKDF2_HMAC_SHA1.bytes(password, salt, algorithm.iterations, length >> 3);
	                break;
	            case "SHA-256":
	                result = asmCrypto.PBKDF2_HMAC_SHA256.bytes(password, salt, algorithm.iterations, length >> 3);
	                break;
	            default:
	                throw new OperationError(`algorithm.hash: '${algorithm.hash.name}' hash algorithm is not supported`);
	        }
	        return result.buffer;
	    }
	}

	class DesCryptoKey extends CryptoKey$1 {
	    constructor(algorithm, extractable, usages, raw) {
	        super(algorithm, extractable, "secret", usages);
	        this.raw = raw;
	    }
	    toJSON() {
	        const jwk = {
	            kty: "oct",
	            alg: this.getJwkAlgorithm(),
	            k: Convert.ToBase64Url(this.raw),
	            ext: this.extractable,
	            key_ops: this.usages,
	        };
	        return jwk;
	    }
	    getJwkAlgorithm() {
	        switch (this.algorithm.name.toUpperCase()) {
	            case "DES-CBC":
	                return `DES-CBC`;
	            case "DES-EDE3-CBC":
	                return `3DES-CBC`;
	            default:
	                throw new AlgorithmError("Unsupported algorithm name");
	        }
	    }
	}

	class DesCrypto {
	    static checkLib() {
	        if (typeof (des) === "undefined") {
	            throw new OperationError("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/des.js' script to your project");
	        }
	    }
	    static async generateKey(algorithm, extractable, keyUsages) {
	        this.checkLib();
	        const raw = nativeCrypto.getRandomValues(new Uint8Array(algorithm.length / 8));
	        return new DesCryptoKey(algorithm, extractable, keyUsages, raw);
	    }
	    static async exportKey(format, key) {
	        this.checkLib();
	        switch (format) {
	            case "jwk":
	                return key.toJSON();
	            case "raw":
	                return key.raw.buffer;
	            default:
	                throw new OperationError("format: Must be 'jwk' or 'raw'");
	        }
	    }
	    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
	        this.checkLib();
	        let raw;
	        if (isJWK(keyData)) {
	            raw = Convert.FromBase64Url(keyData.k);
	        }
	        else {
	            raw = BufferSourceConverter.toArrayBuffer(keyData);
	        }
	        if ((algorithm.name === "DES-CBC" && raw.byteLength !== 8)
	            || (algorithm.name === "DES-EDE3-CBC" && raw.byteLength !== 24)) {
	            throw new OperationError("keyData: Is wrong key length");
	        }
	        const key = new DesCryptoKey({ name: algorithm.name, length: raw.byteLength << 3 }, extractable, keyUsages, new Uint8Array(raw));
	        return key;
	    }
	    static async encrypt(algorithm, key, data) {
	        return this.cipher(algorithm, key, data, true);
	    }
	    static async decrypt(algorithm, key, data) {
	        return this.cipher(algorithm, key, data, false);
	    }
	    static async cipher(algorithm, key, data, encrypt) {
	        this.checkLib();
	        const type = encrypt ? "encrypt" : "decrypt";
	        let DesCipher;
	        const iv = BufferSourceConverter.toUint8Array(algorithm.iv);
	        switch (algorithm.name.toUpperCase()) {
	            case "DES-CBC":
	                DesCipher = des.CBC.instantiate(des.DES).create({
	                    key: key.raw,
	                    type,
	                    iv,
	                });
	                break;
	            case "DES-EDE3-CBC":
	                DesCipher = des.CBC.instantiate(des.EDE).create({
	                    key: key.raw,
	                    type,
	                    iv,
	                });
	                break;
	            default:
	                throw new OperationError("algorithm: Is not recognized");
	        }
	        const enc = DesCipher.update(new Uint8Array(data)).concat(DesCipher.final());
	        return new Uint8Array(enc).buffer;
	    }
	}

	class DesCbcProvider extends DesProvider {
	    constructor() {
	        super(...arguments);
	        this.keySizeBits = 64;
	        this.ivSize = 8;
	        this.name = "DES-CBC";
	    }
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return DesCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onExportKey(format, key) {
	        return DesCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return DesCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async onEncrypt(algorithm, key, data) {
	        return DesCrypto.encrypt(algorithm, key, data);
	    }
	    async onDecrypt(algorithm, key, data) {
	        return DesCrypto.decrypt(algorithm, key, data);
	    }
	}

	class DesEde3CbcProvider extends DesProvider {
	    constructor() {
	        super(...arguments);
	        this.keySizeBits = 192;
	        this.ivSize = 8;
	        this.name = "DES-EDE3-CBC";
	    }
	    async onGenerateKey(algorithm, extractable, keyUsages) {
	        return DesCrypto.generateKey(algorithm, extractable, keyUsages);
	    }
	    async onExportKey(format, key) {
	        return DesCrypto.exportKey(format, key);
	    }
	    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
	        return DesCrypto.importKey(format, keyData, algorithm, extractable, keyUsages);
	    }
	    async onEncrypt(algorithm, key, data) {
	        return DesCrypto.encrypt(algorithm, key, data);
	    }
	    async onDecrypt(algorithm, key, data) {
	        return DesCrypto.decrypt(algorithm, key, data);
	    }
	}

	class SubtleCrypto$1 extends SubtleCrypto {
	    constructor() {
	        super();
	        this.browserInfo = BrowserInfo();
	        this.providers.set(new AesCbcProvider$1());
	        this.providers.set(new AesCtrProvider$1());
	        this.providers.set(new AesEcbProvider$1());
	        this.providers.set(new AesGcmProvider$1());
	        this.providers.set(new AesKwProvider$1());
	        this.providers.set(new DesCbcProvider());
	        this.providers.set(new DesEde3CbcProvider());
	        this.providers.set(new RsaSsaProvider$1());
	        this.providers.set(new RsaPssProvider$1());
	        this.providers.set(new RsaOaepProvider$1());
	        this.providers.set(new EcdsaProvider$1());
	        this.providers.set(new EcdhProvider$1());
	        this.providers.set(new Sha1Provider());
	        this.providers.set(new Sha256Provider());
	        this.providers.set(new Sha512Provider());
	        this.providers.set(new Pbkdf2Provider$1());
	    }
	    static isAnotherKey(key) {
	        if (typeof key === "object"
	            && typeof key.type === "string"
	            && typeof key.extractable === "boolean"
	            && typeof key.algorithm === "object") {
	            return !(key instanceof CryptoKey$1);
	        }
	        return false;
	    }
	    async digest(...args) {
	        return this.wrapNative("digest", ...args);
	    }
	    async importKey(...args) {
	        this.fixFirefoxEcImportPkcs8(args);
	        return this.wrapNative("importKey", ...args);
	    }
	    async exportKey(...args) {
	        return await this.fixFirefoxEcExportPkcs8(args) ||
	            await this.wrapNative("exportKey", ...args);
	    }
	    async generateKey(...args) {
	        return this.wrapNative("generateKey", ...args);
	    }
	    async sign(...args) {
	        return this.wrapNative("sign", ...args);
	    }
	    async verify(...args) {
	        return this.wrapNative("verify", ...args);
	    }
	    async encrypt(...args) {
	        return this.wrapNative("encrypt", ...args);
	    }
	    async decrypt(...args) {
	        return this.wrapNative("decrypt", ...args);
	    }
	    async wrapKey(...args) {
	        return this.wrapNative("wrapKey", ...args);
	    }
	    async unwrapKey(...args) {
	        return this.wrapNative("unwrapKey", ...args);
	    }
	    async deriveBits(...args) {
	        return this.wrapNative("deriveBits", ...args);
	    }
	    async deriveKey(...args) {
	        return this.wrapNative("deriveKey", ...args);
	    }
	    async wrapNative(method, ...args) {
	        if (~["generateKey", "unwrapKey", "deriveKey", "importKey"].indexOf(method)) {
	            this.fixAlgorithmName(args);
	        }
	        try {
	            if (method !== "digest" || !args.some((a) => a instanceof CryptoKey$1)) {
	                Debug.info(`Call native '${method}' method`, args);
	                const res = await nativeSubtle[method].apply(nativeSubtle, args);
	                return res;
	            }
	        }
	        catch (e) {
	            Debug.warn(`Error on native '${method}' calling. ${e.message}`, e);
	        }
	        if (method === "wrapKey") {
	            try {
	                Debug.info(`Trying to wrap key by using native functions`, args);
	                const data = await this.exportKey(args[0], args[1]);
	                const keyData = (args[0] === "jwk") ? Convert.FromUtf8String(JSON.stringify(data)) : data;
	                const res = await this.encrypt(args[3], args[2], keyData);
	                return res;
	            }
	            catch (e) {
	                Debug.warn(`Cannot wrap key by native functions. ${e.message}`, e);
	            }
	        }
	        if (method === "unwrapKey") {
	            try {
	                Debug.info(`Trying to unwrap key by using native functions`, args);
	                const data = await this.decrypt(args[3], args[2], args[1]);
	                const keyData = (args[0] === "jwk") ? JSON.parse(Convert.ToUtf8String(data)) : data;
	                const res = await this.importKey(args[0], keyData, args[4], args[5], args[6]);
	                return res;
	            }
	            catch (e) {
	                Debug.warn(`Cannot unwrap key by native functions. ${e.message}`, e);
	            }
	        }
	        if (method === "deriveKey") {
	            try {
	                Debug.info(`Trying to derive key by using native functions`, args);
	                const data = await this.deriveBits(args[0], args[1], args[2].length);
	                const res = await this.importKey("raw", data, args[2], args[3], args[4]);
	                return res;
	            }
	            catch (e) {
	                Debug.warn(`Cannot derive key by native functions. ${e.message}`, e);
	            }
	        }
	        if (method === "deriveBits" || method === "deriveKey") {
	            for (const arg of args) {
	                if (typeof arg === "object" && arg.public && SubtleCrypto$1.isAnotherKey(arg.public)) {
	                    arg.public = await this.castKey(arg.public);
	                }
	            }
	        }
	        for (let i = 0; i < args.length; i++) {
	            const arg = args[i];
	            if (SubtleCrypto$1.isAnotherKey(arg)) {
	                args[i] = await this.castKey(arg);
	            }
	        }
	        return super[method].apply(this, args);
	    }
	    async castKey(key) {
	        Debug.info("Cast native CryptoKey to linter key.", key);
	        if (!key.extractable) {
	            throw new Error("Cannot cast unextractable crypto key");
	        }
	        const provider = this.getProvider(key.algorithm.name);
	        const jwk = await this.exportKey("jwk", key);
	        return provider.importKey("jwk", jwk, key.algorithm, true, key.usages);
	    }
	    fixAlgorithmName(args) {
	        if (this.browserInfo.name === Browser.Edge) {
	            for (let i = 0; i < args.length; i++) {
	                const arg = args[0];
	                if (typeof arg === "string") {
	                    for (const algorithm of this.providers.algorithms) {
	                        if (algorithm.toLowerCase() === arg.toLowerCase()) {
	                            args[i] = algorithm;
	                            break;
	                        }
	                    }
	                }
	                else if (typeof arg === "object" && typeof arg.name === "string") {
	                    for (const algorithm of this.providers.algorithms) {
	                        if (algorithm.toLowerCase() === arg.name.toLowerCase()) {
	                            arg.name = algorithm;
	                        }
	                        if ((typeof arg.hash === "string" && algorithm.toLowerCase() === arg.hash.toLowerCase())
	                            || (typeof arg.hash === "object" && typeof arg.hash.name === "string" && algorithm.toLowerCase() === arg.hash.name.toLowerCase())) {
	                            arg.hash = { name: algorithm };
	                        }
	                    }
	                }
	            }
	        }
	    }
	    fixFirefoxEcImportPkcs8(args) {
	        const preparedAlgorithm = this.prepareAlgorithm(args[2]);
	        const algName = preparedAlgorithm.name.toUpperCase();
	        if (this.browserInfo.name === Browser.Firefox
	            && args[0] === "pkcs8"
	            && ~["ECDSA", "ECDH"].indexOf(algName)
	            && ~["P-256", "P-384", "P-521"].indexOf(preparedAlgorithm.namedCurve)) {
	            if (!BufferSourceConverter.isBufferSource(args[1])) {
	                throw new TypeError("data: Is not ArrayBuffer or ArrayBufferView");
	            }
	            const preparedData = BufferSourceConverter.toArrayBuffer(args[1]);
	            const keyInfo = build_5.parse(preparedData, PrivateKeyInfo);
	            const privateKey = build_5.parse(keyInfo.privateKey, EcPrivateKey);
	            const jwk = build_2$1.toJSON(privateKey);
	            jwk.ext = true;
	            jwk.key_ops = args[4];
	            jwk.crv = preparedAlgorithm.namedCurve;
	            jwk.kty = "EC";
	            args[0] = "jwk";
	            args[1] = jwk;
	        }
	    }
	    async fixFirefoxEcExportPkcs8(args) {
	        try {
	            if (this.browserInfo.name === Browser.Firefox
	                && args[0] === "pkcs8"
	                && ~["ECDSA", "ECDH"].indexOf(args[1].algorithm.name)
	                && ~["P-256", "P-384", "P-521"].indexOf(args[1].algorithm.namedCurve)) {
	                const jwk = await this.exportKey("jwk", args[1]);
	                const ecKey = build_3$1.fromJSON(jwk, { targetSchema: EcPrivateKey });
	                const keyInfo = new PrivateKeyInfo();
	                keyInfo.privateKeyAlgorithm.algorithm = EcCrypto.ASN_ALGORITHM;
	                keyInfo.privateKeyAlgorithm.parameters = build_6.serialize(new ObjectIdentifier$1(getOidByNamedCurve(args[1].algorithm.namedCurve)));
	                keyInfo.privateKey = build_6.serialize(ecKey);
	                return build_6.serialize(keyInfo);
	            }
	        }
	        catch (err) {
	            Debug.error(err);
	            return null;
	        }
	    }
	}
	SubtleCrypto$1.methods = ["digest", "importKey", "exportKey", "sign", "verify", "generateKey", "encrypt", "decrypt", "deriveBits", "deriveKey", "wrapKey", "unwrapKey"];

	class Crypto$1 extends Crypto {
	    constructor() {
	        super(...arguments);
	        this.subtle = new SubtleCrypto$1();
	    }
	    getRandomValues(array) {
	        return nativeCrypto.getRandomValues(array);
	    }
	}

	if (!Math.imul) {
	    Math.imul = function imul(a, b) {
	        const ah = (a >>> 16) & 0xffff;
	        const al = a & 0xffff;
	        const bh = (b >>> 16) & 0xffff;
	        const bl = b & 0xffff;
	        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
	    };
	}

	const window$1$1 = self;
	if (nativeCrypto) {
	    Object.freeze(nativeCrypto.getRandomValues);
	}
	try {
	    delete self.crypto;
	    window$1$1.crypto = new Crypto$1();
	    Object.freeze(window$1$1.crypto);
	}
	catch (e) {
	    Debug.error(e);
	}
	const crypto = window$1$1.crypto;

	//**************************************************************************************
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Get value for input parameters, or set a default value
	 * @param {Object} parameters
	 * @param {string} name
	 * @param defaultValue
	 */
	function getParametersValue$2(parameters, name, defaultValue)
	{
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		if((parameters instanceof Object) === false)
			return defaultValue;
		
		// noinspection NonBlockStatementBodyJS
		if(name in parameters)
			return parameters[name];
		
		return defaultValue;
	}
	//**************************************************************************************
	/**
	 * Converts "ArrayBuffer" into a hexdecimal string
	 * @param {ArrayBuffer} inputBuffer
	 * @param {number} [inputOffset=0]
	 * @param {number} [inputLength=inputBuffer.byteLength]
	 * @param {boolean} [insertSpace=false]
	 * @returns {string}
	 */
	function bufferToHexCodes$2(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false)
	{
		let result = "";
		
		for(const item of (new Uint8Array(inputBuffer, inputOffset, inputLength)))
		{
			// noinspection ChainedFunctionCallJS
			const str = item.toString(16).toUpperCase();
			
			// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
			if(str.length === 1)
				result += "0";
			
			result += str;
			
			// noinspection NonBlockStatementBodyJS
			if(insertSpace)
				result += " ";
		}
		
		return result.trim();
	}
	//**************************************************************************************
	// noinspection JSValidateJSDoc, FunctionWithMultipleReturnPointsJS
	/**
	 * Check input "ArrayBuffer" for common functions
	 * @param {LocalBaseBlock} baseBlock
	 * @param {ArrayBuffer} inputBuffer
	 * @param {number} inputOffset
	 * @param {number} inputLength
	 * @returns {boolean}
	 */
	function checkBufferParams$2(baseBlock, inputBuffer, inputOffset, inputLength)
	{
		// noinspection ConstantOnRightSideOfComparisonJS
		if((inputBuffer instanceof ArrayBuffer) === false)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputBuffer.byteLength === 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputBuffer has zero length";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputOffset < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputOffset less than zero";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(inputLength < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "Wrong parameter: inputLength less than zero";
			return false;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if((inputBuffer.byteLength - inputOffset - inputLength) < 0)
		{
			// noinspection JSUndefinedPropertyAssignment
			baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
			return false;
		}
		
		return true;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Convert number from 2^base to 2^10
	 * @param {Uint8Array} inputBuffer
	 * @param {number} inputBase
	 * @returns {number}
	 */
	function utilFromBase$2(inputBuffer, inputBase)
	{
		let result = 0;
		
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		if(inputBuffer.length === 1)
			return inputBuffer[0];
		
		// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
		for(let i = (inputBuffer.length - 1); i >= 0; i--)
			result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
		
		return result;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Convert number from 2^10 to 2^base
	 * @param {!number} value The number to convert
	 * @param {!number} base The base for 2^base
	 * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by function itself)
	 * @returns {ArrayBuffer}
	 */
	function utilToBase$2(value, base, reserved = (-1))
	{
		const internalReserved = reserved;
		let internalValue = value;
		
		let result = 0;
		let biggest = Math.pow(2, base);
		
		// noinspection ConstantOnRightSideOfComparisonJS
		for(let i = 1; i < 8; i++)
		{
			if(value < biggest)
			{
				let retBuf;
				
				// noinspection ConstantOnRightSideOfComparisonJS
				if(internalReserved < 0)
				{
					retBuf = new ArrayBuffer(i);
					result = i;
				}
				else
				{
					// noinspection NonBlockStatementBodyJS
					if(internalReserved < i)
						return (new ArrayBuffer(0));
					
					retBuf = new ArrayBuffer(internalReserved);
					
					result = internalReserved;
				}
				
				const retView = new Uint8Array(retBuf);
				
				// noinspection ConstantOnRightSideOfComparisonJS
				for(let j = (i - 1); j >= 0; j--)
				{
					const basis = Math.pow(2, j * base);
					
					retView[result - j - 1] = Math.floor(internalValue / basis);
					internalValue -= (retView[result - j - 1]) * basis;
				}
				
				return retBuf;
			}
			
			biggest *= Math.pow(2, base);
		}
		
		return new ArrayBuffer(0);
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Concatenate two ArrayBuffers
	 * @param {...ArrayBuffer} buffers Set of ArrayBuffer
	 */
	function utilConcatBuf$2(...buffers)
	{
		//region Initial variables
		let outputLength = 0;
		let prevLength = 0;
		//endregion
		
		//region Calculate output length
		
		// noinspection NonBlockStatementBodyJS
		for(const buffer of buffers)
			outputLength += buffer.byteLength;
		//endregion
		
		const retBuf = new ArrayBuffer(outputLength);
		const retView = new Uint8Array(retBuf);
		
		for(const buffer of buffers)
		{
			// noinspection NestedFunctionCallJS
			retView.set(new Uint8Array(buffer), prevLength);
			prevLength += buffer.byteLength;
		}
		
		return retBuf;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Concatenate two Uint8Array
	 * @param {...Uint8Array} views Set of Uint8Array
	 */
	function utilConcatView$2(...views)
	{
		//region Initial variables
		let outputLength = 0;
		let prevLength = 0;
		//endregion
		
		//region Calculate output length
		// noinspection NonBlockStatementBodyJS
		for(const view of views)
			outputLength += view.length;
		//endregion
		
		const retBuf = new ArrayBuffer(outputLength);
		const retView = new Uint8Array(retBuf);
		
		for(const view of views)
		{
			retView.set(view, prevLength);
			prevLength += view.length;
		}
		
		return retView;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Decoding of "two complement" values
	 * The function must be called in scope of instance of "hexBlock" class ("valueHex" and "warnings" properties must be present)
	 * @returns {number}
	 */
	function utilDecodeTC$2()
	{
		const buf = new Uint8Array(this.valueHex);
		
		// noinspection ConstantOnRightSideOfComparisonJS
		if(this.valueHex.byteLength >= 2)
		{
			//noinspection JSBitwiseOperatorUsage, ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
			// noinspection ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
			
			// noinspection NonBlockStatementBodyJS
			if(condition1 || condition2)
				this.warnings.push("Needlessly long format");
		}
		
		//region Create big part of the integer
		const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
		const bigIntView = new Uint8Array(bigIntBuffer);
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < this.valueHex.byteLength; i++)
			bigIntView[i] = 0;
		
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		bigIntView[0] = (buf[0] & 0x80); // mask only the biggest bit
		
		const bigInt = utilFromBase$2(bigIntView, 8);
		//endregion
		
		//region Create small part of the integer
		const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
		const smallIntView = new Uint8Array(smallIntBuffer);
		// noinspection NonBlockStatementBodyJS
		for(let j = 0; j < this.valueHex.byteLength; j++)
			smallIntView[j] = buf[j];
		
		// noinspection MagicNumberJS
		smallIntView[0] &= 0x7F; // mask biggest bit
		
		const smallInt = utilFromBase$2(smallIntView, 8);
		//endregion
		
		return (smallInt - bigInt);
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Encode integer value to "two complement" format
	 * @param {number} value Value to encode
	 * @returns {ArrayBuffer}
	 */
	function utilEncodeTC$2(value)
	{
		// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS
		const modValue = (value < 0) ? (value * (-1)) : value;
		let bigInt = 128;
		
		// noinspection ConstantOnRightSideOfComparisonJS
		for(let i = 1; i < 8; i++)
		{
			if(modValue <= bigInt)
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(value < 0)
				{
					const smallInt = bigInt - modValue;
					
					const retBuf = utilToBase$2(smallInt, 8, i);
					const retView = new Uint8Array(retBuf);
					
					// noinspection MagicNumberJS
					retView[0] |= 0x80;
					
					return retBuf;
				}
				
				let retBuf = utilToBase$2(modValue, 8, i);
				let retView = new Uint8Array(retBuf);
				
				//noinspection JSBitwiseOperatorUsage, MagicNumberJS, NonShortCircuitBooleanExpressionJS
				if(retView[0] & 0x80)
				{
					//noinspection JSCheckFunctionSignatures
					const tempBuf = retBuf.slice(0);
					const tempView = new Uint8Array(tempBuf);
					
					retBuf = new ArrayBuffer(retBuf.byteLength + 1);
					// noinspection ReuseOfLocalVariableJS
					retView = new Uint8Array(retBuf);
					
					// noinspection NonBlockStatementBodyJS
					for(let k = 0; k < tempBuf.byteLength; k++)
						retView[k + 1] = tempView[k];
					
					// noinspection MagicNumberJS
					retView[0] = 0x00;
				}
				
				return retBuf;
			}
			
			bigInt *= Math.pow(2, 8);
		}
		
		return (new ArrayBuffer(0));
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS, ParameterNamingConventionJS
	/**
	 * Compare two array buffers
	 * @param {!ArrayBuffer} inputBuffer1
	 * @param {!ArrayBuffer} inputBuffer2
	 * @returns {boolean}
	 */
	function isEqualBuffer$2(inputBuffer1, inputBuffer2)
	{
		// noinspection NonBlockStatementBodyJS
		if(inputBuffer1.byteLength !== inputBuffer2.byteLength)
			return false;
		
		// noinspection LocalVariableNamingConventionJS
		const view1 = new Uint8Array(inputBuffer1);
		// noinspection LocalVariableNamingConventionJS
		const view2 = new Uint8Array(inputBuffer2);
		
		for(let i = 0; i < view1.length; i++)
		{
			// noinspection NonBlockStatementBodyJS
			if(view1[i] !== view2[i])
				return false;
		}
		
		return true;
	}
	//**************************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Pad input number with leade "0" if needed
	 * @returns {string}
	 * @param {number} inputNumber
	 * @param {number} fullLength
	 */
	function padNumber$2(inputNumber, fullLength)
	{
		const str = inputNumber.toString(10);
		
		// noinspection NonBlockStatementBodyJS
		if(fullLength < str.length)
			return "";
		
		const dif = fullLength - str.length;
		
		const padding = new Array(dif);
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < dif; i++)
			padding[i] = "0";
		
		const paddingString = padding.join("");
		
		return paddingString.concat(str);
	}
	//**************************************************************************************
	const base64Template$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	const base64UrlTemplate$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
	//**************************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS, FunctionNamingConventionJS
	/**
	 * Encode string into BASE64 (or "base64url")
	 * @param {string} input
	 * @param {boolean} useUrlTemplate If "true" then output would be encoded using "base64url"
	 * @param {boolean} skipPadding Skip BASE-64 padding or not
	 * @param {boolean} skipLeadingZeros Skip leading zeros in input data or not
	 * @returns {string}
	 */
	function toBase64$1(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false)
	{
		let i = 0;
		
		// noinspection LocalVariableNamingConventionJS
		let flag1 = 0;
		// noinspection LocalVariableNamingConventionJS
		let flag2 = 0;
		
		let output = "";
		
		// noinspection ConditionalExpressionJS
		const template = (useUrlTemplate) ? base64UrlTemplate$1 : base64Template$1;
		
		if(skipLeadingZeros)
		{
			let nonZeroPosition = 0;
			
			for(let i = 0; i < input.length; i++)
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(input.charCodeAt(i) !== 0)
				{
					nonZeroPosition = i;
					// noinspection BreakStatementJS
					break;
				}
			}
			
			// noinspection AssignmentToFunctionParameterJS
			input = input.slice(nonZeroPosition);
		}
		
		while(i < input.length)
		{
			// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const chr1 = input.charCodeAt(i++);
			// noinspection NonBlockStatementBodyJS
			if(i >= input.length)
				flag1 = 1;
			// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const chr2 = input.charCodeAt(i++);
			// noinspection NonBlockStatementBodyJS
			if(i >= input.length)
				flag2 = 1;
			// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const chr3 = input.charCodeAt(i++);
			
			// noinspection LocalVariableNamingConventionJS
			const enc1 = chr1 >> 2;
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			let enc4 = chr3 & 0x3F;
			
			// noinspection ConstantOnRightSideOfComparisonJS
			if(flag1 === 1)
			{
				// noinspection NestedAssignmentJS, AssignmentResultUsedJS, MagicNumberJS
				enc3 = enc4 = 64;
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(flag2 === 1)
				{
					// noinspection MagicNumberJS
					enc4 = 64;
				}
			}
			
			// noinspection NonBlockStatementBodyJS
			if(skipPadding)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
				if(enc3 === 64)
					output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
				else
				{
					// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
					if(enc4 === 64)
						output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
					else
						output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
				}
			}
			else
				output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
		}
		
		return output;
	}
	//**************************************************************************************
	// noinspection FunctionWithMoreThanThreeNegationsJS, FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionNamingConventionJS
	/**
	 * Decode string from BASE64 (or "base64url")
	 * @param {string} input
	 * @param {boolean} [useUrlTemplate=false] If "true" then output would be encoded using "base64url"
	 * @param {boolean} [cutTailZeros=false] If "true" then cut tailing zeroz from function result
	 * @returns {string}
	 */
	function fromBase64$1(input, useUrlTemplate = false, cutTailZeros = false)
	{
		// noinspection ConditionalExpressionJS
		const template = (useUrlTemplate) ? base64UrlTemplate$1 : base64Template$1;
		
		//region Aux functions
		// noinspection FunctionWithMultipleReturnPointsJS, NestedFunctionJS
		function indexof(toSearch)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, MagicNumberJS
			for(let i = 0; i < 64; i++)
			{
				// noinspection NonBlockStatementBodyJS
				if(template.charAt(i) === toSearch)
					return i;
			}
			
			// noinspection MagicNumberJS
			return 64;
		}
		
		// noinspection NestedFunctionJS
		function test(incoming)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS, MagicNumberJS
			return ((incoming === 64) ? 0x00 : incoming);
		}
		//endregion
		
		let i = 0;
		
		let output = "";
		
		while(i < input.length)
		{
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
			const enc1 = indexof(input.charAt(i++));
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS
			const enc2 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS
			const enc3 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));
			// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS
			const enc4 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));
			
			// noinspection LocalVariableNamingConventionJS, NonShortCircuitBooleanExpressionJS
			const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);
			// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
			const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);
			
			output += String.fromCharCode(chr1);
			
			// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
			if(enc3 !== 64)
				output += String.fromCharCode(chr2);
			
			// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
			if(enc4 !== 64)
				output += String.fromCharCode(chr3);
		}
		
		if(cutTailZeros)
		{
			const outputLength = output.length;
			let nonZeroStart = (-1);
			
			// noinspection ConstantOnRightSideOfComparisonJS
			for(let i = (outputLength - 1); i >= 0; i--)
			{
				// noinspection ConstantOnRightSideOfComparisonJS
				if(output.charCodeAt(i) !== 0)
				{
					nonZeroStart = i;
					// noinspection BreakStatementJS
					break;
				}
			}
			
			// noinspection NonBlockStatementBodyJS, NegatedIfStatementJS
			if(nonZeroStart !== (-1))
				output = output.slice(0, nonZeroStart + 1);
			else
				output = "";
		}
		
		return output;
	}
	//**************************************************************************************
	function arrayBufferToString$1(buffer)
	{
		let resultString = "";
		const view = new Uint8Array(buffer);
		
		// noinspection NonBlockStatementBodyJS
		for(const element of view)
			resultString += String.fromCharCode(element);
		
		return resultString;
	}
	//**************************************************************************************
	function stringToArrayBuffer$2(str)
	{
		const stringLength = str.length;
		
		const resultBuffer = new ArrayBuffer(stringLength);
		const resultView = new Uint8Array(resultBuffer);
		
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < stringLength; i++)
			resultView[i] = str.charCodeAt(i);
		
		return resultBuffer;
	}
	//**************************************************************************************
	const log2$1 = Math.log(2);
	//**************************************************************************************
	// noinspection FunctionNamingConventionJS
	/**
	 * Get nearest to input length power of 2
	 * @param {number} length Current length of existing array
	 * @returns {number}
	 */
	function nearestPowerOf2$1(length)
	{
		const base = (Math.log(length) / log2$1);
		
		const floor = Math.floor(base);
		const round = Math.round(base);
		
		// noinspection ConditionalExpressionJS
		return ((floor === round) ? floor : round);
	}
	//**************************************************************************************
	/**
	 * Delete properties by name from specified object
	 * @param {Object} object Object to delete properties from
	 * @param {Array.<string>} propsArray Array of properties names
	 */
	function clearProps$1(object, propsArray)
	{
		for(const prop of propsArray)
			delete object[prop];
	}
	//**************************************************************************************

	/* eslint-disable indent */
	//**************************************************************************************
	//region Declaration of global variables
	//**************************************************************************************
	const powers2$1 = [new Uint8Array([1])];
	const digitsString$1 = "0123456789";
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration for "LocalBaseBlock" class
	//**************************************************************************************
	/**
	 * Class used as a base block for all remaining ASN.1 classes
	 * @typedef LocalBaseBlock
	 * @interface
	 * @property {number} blockLength
	 * @property {string} error
	 * @property {Array.<string>} warnings
	 * @property {ArrayBuffer} valueBeforeDecode
	 */
	class LocalBaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBaseBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueBeforeDecode]
		 */
		constructor(parameters = {})
		{
			/**
			 * @type {number} blockLength
			 */
			this.blockLength = getParametersValue$2(parameters, "blockLength", 0);
			/**
			 * @type {string} error
			 */
			this.error = getParametersValue$2(parameters, "error", "");
			/**
			 * @type {Array.<string>} warnings
			 */
			this.warnings = getParametersValue$2(parameters, "warnings", []);
			//noinspection JSCheckFunctionSignatures
			/**
			 * @type {ArrayBuffer} valueBeforeDecode
			 */
			if("valueBeforeDecode" in parameters)
				this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);
			else
				this.valueBeforeDecode = new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "baseBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			return {
				blockName: this.constructor.blockName(),
				blockLength: this.blockLength,
				error: this.error,
				warnings: this.warnings,
				valueBeforeDecode: bufferToHexCodes$2(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Description for "LocalHexBlock" class
	//**************************************************************************************
	/**
	 * Class used as a base block for all remaining ASN.1 classes
	 * @extends LocalBaseBlock
	 * @typedef LocalHexBlock
	 * @property {number} blockLength
	 * @property {string} error
	 * @property {Array.<string>} warnings
	 * @property {ArrayBuffer} valueBeforeDecode
	 * @property {boolean} isHexOnly
	 * @property {ArrayBuffer} valueHex
	 */
	//noinspection JSUnusedLocalSymbols
	const LocalHexBlock$1 = BaseClass => class LocalHexBlockMixin extends BaseClass
	{
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Constructor for "LocalHexBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			/**
			 * @type {boolean}
			 */
			this.isHexOnly = getParametersValue$2(parameters, "isHexOnly", false);
			/**
			 * @type {ArrayBuffer}
			 */
			if("valueHex" in parameters)
				this.valueHex = parameters.valueHex.slice(0);
			else
				this.valueHex = new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "hexBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Copy input buffer to internal buffer
			this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);
			//endregion

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			if(this.isHexOnly !== true)
			{
				this.error = "Flag \"isHexOnly\" is not set, abort";
				return new ArrayBuffer(0);
			}

			if(sizeOnly === true)
				return new ArrayBuffer(this.valueHex.byteLength);

			//noinspection JSCheckFunctionSignatures
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.blockName = this.constructor.blockName();
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes$2(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	};
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of identification block class
	//**************************************************************************************
	class LocalIdentificationBlock$1 extends LocalHexBlock$1(LocalBaseBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBaseBlock" class
		 * @param {Object} [parameters={}]
		 * @property {Object} [idBlock]
		 */
		constructor(parameters = {})
		{
			super();

			if("idBlock" in parameters)
			{
				//region Properties from hexBlock class
				this.isHexOnly = getParametersValue$2(parameters.idBlock, "isHexOnly", false);
				this.valueHex = getParametersValue$2(parameters.idBlock, "valueHex", new ArrayBuffer(0));
				//endregion

				this.tagClass = getParametersValue$2(parameters.idBlock, "tagClass", (-1));
				this.tagNumber = getParametersValue$2(parameters.idBlock, "tagNumber", (-1));
				this.isConstructed = getParametersValue$2(parameters.idBlock, "isConstructed", false);
			}
			else
			{
				this.tagClass = (-1);
				this.tagNumber = (-1);
				this.isConstructed = false;
			}
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "identificationBlock";
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Initial variables
			let firstOctet = 0;
			let retBuf;
			let retView;
			//endregion

			switch(this.tagClass)
			{
				case 1:
					firstOctet |= 0x00; // UNIVERSAL
					break;
				case 2:
					firstOctet |= 0x40; // APPLICATION
					break;
				case 3:
					firstOctet |= 0x80; // CONTEXT-SPECIFIC
					break;
				case 4:
					firstOctet |= 0xC0; // PRIVATE
					break;
				default:
					this.error = "Unknown tag class";
					return (new ArrayBuffer(0));
			}

			if(this.isConstructed)
				firstOctet |= 0x20;

			if((this.tagNumber < 31) && (!this.isHexOnly))
			{
				retBuf = new ArrayBuffer(1);
				retView = new Uint8Array(retBuf);

				if(!sizeOnly)
				{
					let number = this.tagNumber;
					number &= 0x1F;
					firstOctet |= number;

					retView[0] = firstOctet;
				}

				return retBuf;
			}

			if(this.isHexOnly === false)
			{
				const encodedBuf = utilToBase$2(this.tagNumber, 7);
				const encodedView = new Uint8Array(encodedBuf);
				const size = encodedBuf.byteLength;

				retBuf = new ArrayBuffer(size + 1);
				retView = new Uint8Array(retBuf);
				retView[0] = (firstOctet | 0x1F);

				if(!sizeOnly)
				{
					for(let i = 0; i < (size - 1); i++)
						retView[i + 1] = encodedView[i] | 0x80;

					retView[size] = encodedView[size - 1];
				}

				return retBuf;
			}

			retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
			retView = new Uint8Array(retBuf);

			retView[0] = (firstOctet | 0x1F);

			if(sizeOnly === false)
			{
				const curView = new Uint8Array(this.valueHex);

				for(let i = 0; i < (curView.length - 1); i++)
					retView[i + 1] = curView[i] | 0x80;

				retView[this.valueHex.byteLength] = curView[curView.length - 1];
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.error = "Zero buffer length";
				return (-1);
			}
			//endregion

			//region Find tag class
			const tagClassMask = intBuffer[0] & 0xC0;

			switch(tagClassMask)
			{
				case 0x00:
					this.tagClass = (1); // UNIVERSAL
					break;
				case 0x40:
					this.tagClass = (2); // APPLICATION
					break;
				case 0x80:
					this.tagClass = (3); // CONTEXT-SPECIFIC
					break;
				case 0xC0:
					this.tagClass = (4); // PRIVATE
					break;
				default:
					this.error = "Unknown tag class";
					return (-1);
			}
			//endregion

			//region Find it's constructed or not
			this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
			//endregion

			//region Find tag number
			this.isHexOnly = false;

			const tagNumberMask = intBuffer[0] & 0x1F;

			//region Simple case (tag number < 31)
			if(tagNumberMask !== 0x1F)
			{
				this.tagNumber = (tagNumberMask);
				this.blockLength = 1;
			}
			//endregion
			//region Tag number bigger or equal to 31
			else
			{
				let count = 1;

				this.valueHex = new ArrayBuffer(255);
				let tagNumberBufferMaxLength = 255;
				let intTagNumberBuffer = new Uint8Array(this.valueHex);

				//noinspection JSBitwiseOperatorUsage
				while(intBuffer[count] & 0x80)
				{
					intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
					count++;

					if(count >= intBuffer.length)
					{
						this.error = "End of input reached before message was fully decoded";
						return (-1);
					}

					//region In case if tag number length is greater than 255 bytes (rare but possible case)
					if(count === tagNumberBufferMaxLength)
					{
						tagNumberBufferMaxLength += 255;

						const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);
						const tempBufferView = new Uint8Array(tempBuffer);

						for(let i = 0; i < intTagNumberBuffer.length; i++)
							tempBufferView[i] = intTagNumberBuffer[i];

						this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);
						intTagNumberBuffer = new Uint8Array(this.valueHex);
					}
					//endregion
				}

				this.blockLength = (count + 1);
				intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer

				//region Cut buffer
				const tempBuffer = new ArrayBuffer(count);
				const tempBufferView = new Uint8Array(tempBuffer);

				for(let i = 0; i < count; i++)
					tempBufferView[i] = intTagNumberBuffer[i];

				this.valueHex = new ArrayBuffer(count);
				intTagNumberBuffer = new Uint8Array(this.valueHex);
				intTagNumberBuffer.set(tempBufferView);
				//endregion

				//region Try to convert long tag number to short form
				if(this.blockLength <= 9)
					this.tagNumber = utilFromBase$2(intTagNumberBuffer, 7);
				else
				{
					this.isHexOnly = true;
					this.warnings.push("Tag too long, represented as hex-coded");
				}
				//endregion
			}
			//endregion
			//endregion

			//region Check if constructed encoding was using for primitive type
			if(((this.tagClass === 1)) &&
				(this.isConstructed))
			{
				switch(this.tagNumber)
				{
					case 1:  // Boolean
					case 2:  // REAL
					case 5:  // Null
					case 6:  // OBJECT IDENTIFIER
					case 9:  // REAL
					case 14: // Time
					case 23:
					case 24:
					case 31:
					case 32:
					case 33:
					case 34:
						this.error = "Constructed encoding used for primitive type";
						return (-1);
					default:
				}
			}
			//endregion

			return (inputOffset + this.blockLength); // Return current offset in input buffer
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName: string,
		 *  tagClass: number,
		 *  tagNumber: number,
		 *  isConstructed: boolean,
		 *  isHexOnly: boolean,
		 *  valueHex: ArrayBuffer,
		 *  blockLength: number,
		 *  error: string, warnings: Array.<string>,
		 *  valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.blockName = this.constructor.blockName();
			object.tagClass = this.tagClass;
			object.tagNumber = this.tagNumber;
			object.isConstructed = this.isConstructed;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of length block class
	//**************************************************************************************
	class LocalLengthBlock$1 extends LocalBaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalLengthBlock" class
		 * @param {Object} [parameters={}]
		 * @property {Object} [lenBlock]
		 */
		constructor(parameters = {})
		{
			super();

			if("lenBlock" in parameters)
			{
				this.isIndefiniteForm = getParametersValue$2(parameters.lenBlock, "isIndefiniteForm", false);
				this.longFormUsed = getParametersValue$2(parameters.lenBlock, "longFormUsed", false);
				this.length = getParametersValue$2(parameters.lenBlock, "length", 0);
			}
			else
			{
				this.isIndefiniteForm = false;
				this.longFormUsed = false;
				this.length = 0;
			}
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "lengthBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.error = "Zero buffer length";
				return (-1);
			}

			if(intBuffer[0] === 0xFF)
			{
				this.error = "Length block 0xFF is reserved by standard";
				return (-1);
			}
			//endregion

			//region Check for length form type
			this.isIndefiniteForm = intBuffer[0] === 0x80;
			//endregion

			//region Stop working in case of indefinite length form
			if(this.isIndefiniteForm === true)
			{
				this.blockLength = 1;
				return (inputOffset + this.blockLength);
			}
			//endregion

			//region Check is long form of length encoding using
			this.longFormUsed = !!(intBuffer[0] & 0x80);
			//endregion

			//region Stop working in case of short form of length value
			if(this.longFormUsed === false)
			{
				this.length = (intBuffer[0]);
				this.blockLength = 1;
				return (inputOffset + this.blockLength);
			}
			//endregion

			//region Calculate length value in case of long form
			const count = intBuffer[0] & 0x7F;

			if(count > 8) // Too big length value
			{
				this.error = "Too big integer";
				return (-1);
			}

			if((count + 1) > intBuffer.length)
			{
				this.error = "End of input reached before message was fully decoded";
				return (-1);
			}

			const lengthBufferView = new Uint8Array(count);

			for(let i = 0; i < count; i++)
				lengthBufferView[i] = intBuffer[i + 1];

			if(lengthBufferView[count - 1] === 0x00)
				this.warnings.push("Needlessly long encoded length");

			this.length = utilFromBase$2(lengthBufferView, 8);

			if(this.longFormUsed && (this.length <= 127))
				this.warnings.push("Unneccesary usage of long length form");

			this.blockLength = count + 1;
			//endregion

			return (inputOffset + this.blockLength); // Return current offset in input buffer
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Initial variables
			let retBuf;
			let retView;
			//endregion

			if(this.length > 127)
				this.longFormUsed = true;

			if(this.isIndefiniteForm)
			{
				retBuf = new ArrayBuffer(1);

				if(sizeOnly === false)
				{
					retView = new Uint8Array(retBuf);
					retView[0] = 0x80;
				}

				return retBuf;
			}

			if(this.longFormUsed === true)
			{
				const encodedBuf = utilToBase$2(this.length, 8);

				if(encodedBuf.byteLength > 127)
				{
					this.error = "Too big length";
					return (new ArrayBuffer(0));
				}

				retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);

				if(sizeOnly === true)
					return retBuf;

				const encodedView = new Uint8Array(encodedBuf);
				retView = new Uint8Array(retBuf);

				retView[0] = encodedBuf.byteLength | 0x80;

				for(let i = 0; i < encodedBuf.byteLength; i++)
					retView[i + 1] = encodedView[i];

				return retBuf;
			}

			retBuf = new ArrayBuffer(1);

			if(sizeOnly === false)
			{
				retView = new Uint8Array(retBuf);

				retView[0] = this.length;
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.blockName = this.constructor.blockName();
			object.isIndefiniteForm = this.isIndefiniteForm;
			object.longFormUsed = this.longFormUsed;
			object.length = this.length;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of value block class
	//**************************************************************************************
	class LocalValueBlock$1 extends LocalBaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "valueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Throw an exception for a function which needs to be specified in extended classes
			throw TypeError("User need to make a specific function in a class which extends \"LocalValueBlock\"");
			//endregion
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Throw an exception for a function which needs to be specified in extended classes
			throw TypeError("User need to make a specific function in a class which extends \"LocalValueBlock\"");
			//endregion
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic ASN.1 block class
	//**************************************************************************************
	class BaseBlock$1 extends LocalBaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "BaseBlock" class
		 * @param {Object} [parameters={}]
		 * @property {Object} [primitiveSchema]
		 * @property {string} [name]
		 * @property {boolean} [optional]
		 * @param valueBlockType Type of value block
		 */
		constructor(parameters = {}, valueBlockType = LocalValueBlock$1)
		{
			super(parameters);

			if("name" in parameters)
				this.name = parameters.name;
			if("optional" in parameters)
				this.optional = parameters.optional;
			if("primitiveSchema" in parameters)
				this.primitiveSchema = parameters.primitiveSchema;

			this.idBlock = new LocalIdentificationBlock$1(parameters);
			this.lenBlock = new LocalLengthBlock$1(parameters);
			this.valueBlock = new valueBlockType(parameters);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BaseBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			let retBuf;

			const idBlockBuf = this.idBlock.toBER(sizeOnly);
			const valueBlockSizeBuf = this.valueBlock.toBER(true);

			this.lenBlock.length = valueBlockSizeBuf.byteLength;
			const lenBlockBuf = this.lenBlock.toBER(sizeOnly);

			retBuf = utilConcatBuf$2(idBlockBuf, lenBlockBuf);

			let valueBlockBuf;

			if(sizeOnly === false)
				valueBlockBuf = this.valueBlock.toBER(sizeOnly);
			else
				valueBlockBuf = new ArrayBuffer(this.lenBlock.length);

			retBuf = utilConcatBuf$2(retBuf, valueBlockBuf);

			if(this.lenBlock.isIndefiniteForm === true)
			{
				const indefBuf = new ArrayBuffer(2);

				if(sizeOnly === false)
				{
					const indefView = new Uint8Array(indefBuf);

					indefView[0] = 0x00;
					indefView[1] = 0x00;
				}

				retBuf = utilConcatBuf$2(retBuf, indefBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.idBlock = this.idBlock.toJSON();
			object.lenBlock = this.lenBlock.toJSON();
			object.valueBlock = this.valueBlock.toJSON();

			if("name" in this)
				object.name = this.name;
			if("optional" in this)
				object.optional = this.optional;
			if("primitiveSchema" in this)
				object.primitiveSchema = this.primitiveSchema.toJSON();

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic block for all PRIMITIVE types
	//**************************************************************************************
	class LocalPrimitiveValueBlock$1 extends LocalValueBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalPrimitiveValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueBeforeDecode]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			//region Variables from "hexBlock" class
			if("valueHex" in parameters)
				this.valueHex = parameters.valueHex.slice(0);
			else
				this.valueHex = new ArrayBuffer(0);

			this.isHexOnly = getParametersValue$2(parameters, "isHexOnly", true);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Copy input buffer into internal buffer
			this.valueHex = new ArrayBuffer(intBuffer.length);
			const valueHexView = new Uint8Array(this.valueHex);

			for(let i = 0; i < intBuffer.length; i++)
				valueHexView[i] = intBuffer[i];
			//endregion

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "PrimitiveValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.valueHex = bufferToHexCodes$2(this.valueHex, 0, this.valueHex.byteLength);
			object.isHexOnly = this.isHexOnly;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Primitive$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Primitive" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalPrimitiveValueBlock$1);

			this.idBlock.isConstructed = false;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "PRIMITIVE";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of basic block for all CONSTRUCTED types
	//**************************************************************************************
	class LocalConstructedValueBlock$1 extends LocalValueBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalConstructedValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.value = getParametersValue$2(parameters, "value", []);
			this.isIndefiniteForm = getParametersValue$2(parameters, "isIndefiniteForm", false);
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Store initial offset and length
			const initialOffset = inputOffset;
			const initialLength = inputLength;
			//endregion

			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			//region Initial checks
			if(intBuffer.length === 0)
			{
				this.warnings.push("Zero buffer length");
				return inputOffset;
			}
			//endregion

			//region Aux function
			function checkLen(indefiniteLength, length)
			{
				if(indefiniteLength === true)
					return 1;

				return length;
			}
			//endregion

			let currentOffset = inputOffset;

			while(checkLen(this.isIndefiniteForm, inputLength) > 0)
			{
				const returnObject = LocalFromBER$1(inputBuffer, currentOffset, inputLength);
				if(returnObject.offset === (-1))
				{
					this.error = returnObject.result.error;
					this.warnings.concat(returnObject.result.warnings);
					return (-1);
				}

				currentOffset = returnObject.offset;

				this.blockLength += returnObject.result.blockLength;
				inputLength -= returnObject.result.blockLength;

				this.value.push(returnObject.result);

				if((this.isIndefiniteForm === true) && (returnObject.result.constructor.blockName() === EndOfContent$1.blockName()))
					break;
			}

			if(this.isIndefiniteForm === true)
			{
				if(this.value[this.value.length - 1].constructor.blockName() === EndOfContent$1.blockName())
					this.value.pop();
				else
					this.warnings.push("No EndOfContent block encoded");
			}

			//region Copy "inputBuffer" to "valueBeforeDecode"
			this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);
			//endregion

			return currentOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			let retBuf = new ArrayBuffer(0);

			for(let i = 0; i < this.value.length; i++)
			{
				const valueBuf = this.value[i].toBER(sizeOnly);
				retBuf = utilConcatBuf$2(retBuf, valueBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "ConstructedValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.isIndefiniteForm = this.isIndefiniteForm;
			object.value = [];
			for(let i = 0; i < this.value.length; i++)
				object.value.push(this.value[i].toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Constructed$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Constructed" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalConstructedValueBlock$1);

			this.idBlock.isConstructed = true;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "CONSTRUCTED";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 EndOfContent type class
	//**************************************************************************************
	class LocalEndOfContentValueBlock$1 extends LocalValueBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalEndOfContentValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number}
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region There is no "value block" for EndOfContent type and we need to return the same offset
			return inputOffset;
			//endregion
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			return new ArrayBuffer(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "EndOfContentValueBlock";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class EndOfContent$1 extends BaseBlock$1
	{
		//**********************************************************************************
		constructor(paramaters = {})
		{
			super(paramaters, LocalEndOfContentValueBlock$1);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 0; // EndOfContent
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "EndOfContent";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Boolean type class
	//**************************************************************************************
	class LocalBooleanValueBlock$1 extends LocalValueBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBooleanValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);
			
			this.value = getParametersValue$2(parameters, "value", false);
			this.isHexOnly = getParametersValue$2(parameters, "isHexOnly", false);
			
			if("valueHex" in parameters)
				this.valueHex = parameters.valueHex.slice(0);
			else
			{
				this.valueHex = new ArrayBuffer(1);
				if(this.value === true)
				{
					const view = new Uint8Array(this.valueHex);
					view[0] = 0xFF;
				}
			}
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			//region Getting Uint8Array from ArrayBuffer
			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
			//endregion

			if(inputLength > 1)
				this.warnings.push("Boolean value encoded in more then 1 octet");

			this.isHexOnly = true;

			//region Copy input buffer to internal array
			this.valueHex = new ArrayBuffer(intBuffer.length);
			const view = new Uint8Array(this.valueHex);

			for(let i = 0; i < intBuffer.length; i++)
				view[i] = intBuffer[i];
			//endregion
			
			if(utilDecodeTC$2.call(this) !== 0 )
				this.value = true;
			else
				this.value = false;

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			return this.valueHex;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BooleanValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes$2(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Boolean$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Boolean" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBooleanValueBlock$1);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 1; // Boolean
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Boolean";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Sequence and Set type classes
	//**************************************************************************************
	class Sequence$1 extends Constructed$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Sequence" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 16; // Sequence
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Sequence";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Set$1 extends Constructed$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Set" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 17; // Set
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Set";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Null type class
	//**************************************************************************************
	class Null$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Null" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBaseBlock$1); // We will not have a call to "Null value block" because of specified "fromBER" and "toBER" functions

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 5; // Null
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Null";
		}
		//**********************************************************************************
		//noinspection JSUnusedLocalSymbols
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			if(this.lenBlock.length > 0)
				this.warnings.push("Non-zero length of value block for Null type");

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;
			
			this.blockLength += inputLength;
			
			if((inputOffset + inputLength) > inputBuffer.byteLength)
			{
				this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
				return (-1);
			}
			
			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			const retBuf = new ArrayBuffer(2);

			if(sizeOnly === true)
				return retBuf;

			const retView = new Uint8Array(retBuf);
			retView[0] = 0x05;
			retView[1] = 0x00;

			return retBuf;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 OctetString type class
	//**************************************************************************************
	class LocalOctetStringValueBlock$1 extends LocalHexBlock$1(LocalConstructedValueBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalOctetStringValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isConstructed = getParametersValue$2(parameters, "isConstructed", false);
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			let resultOffset = 0;

			if(this.isConstructed === true)
			{
				this.isHexOnly = false;

				resultOffset = LocalConstructedValueBlock$1.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
				if(resultOffset === (-1))
					return resultOffset;

				for(let i = 0; i < this.value.length; i++)
				{
					const currentBlockName = this.value[i].constructor.blockName();

					if(currentBlockName === EndOfContent$1.blockName())
					{
						if(this.isIndefiniteForm === true)
							break;
						else
						{
							this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
							return (-1);
						}
					}

					if(currentBlockName !== OctetString$1.blockName())
					{
						this.error = "OCTET STRING may consists of OCTET STRINGs only";
						return (-1);
					}
				}
			}
			else
			{
				this.isHexOnly = true;

				resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
				this.blockLength = inputLength;
			}

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			if(this.isConstructed === true)
				return LocalConstructedValueBlock$1.prototype.toBER.call(this, sizeOnly);

			let retBuf = new ArrayBuffer(this.valueHex.byteLength);

			if(sizeOnly === true)
				return retBuf;

			if(this.valueHex.byteLength === 0)
				return retBuf;

			retBuf = this.valueHex.slice(0);

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "OctetStringValueBlock";
		}
		//**********************************************************************************
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.isConstructed = this.isConstructed;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes$2(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class OctetString$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "OctetString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalOctetStringValueBlock$1);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 4; // OctetString
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			this.valueBlock.isConstructed = this.idBlock.isConstructed;
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			//region Ability to encode empty OCTET STRING
			if(inputLength === 0)
			{
				if(this.idBlock.error.length === 0)
					this.blockLength += this.idBlock.blockLength;

				if(this.lenBlock.error.length === 0)
					this.blockLength += this.lenBlock.blockLength;

				return inputOffset;
			}
			//endregion

			return super.fromBER(inputBuffer, inputOffset, inputLength);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "OctetString";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Checking that two OCTETSTRINGs are equal
		 * @param {OctetString} octetString
		 */
		isEqual(octetString)
		{
			//region Check input type
			if((octetString instanceof OctetString$1) === false)
				return false;
			//endregion

			//region Compare two JSON strings
			if(JSON.stringify(this) !== JSON.stringify(octetString))
				return false;
			//endregion

			return true;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 BitString type class
	//**************************************************************************************
	class LocalBitStringValueBlock$1 extends LocalHexBlock$1(LocalConstructedValueBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBitStringValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.unusedBits = getParametersValue$2(parameters, "unusedBits", 0);
			this.isConstructed = getParametersValue$2(parameters, "isConstructed", false);
			this.blockLength = this.valueHex.byteLength;
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Ability to decode zero-length BitString value
			if(inputLength === 0)
				return inputOffset;
			//endregion

			let resultOffset = (-1);

			//region If the BISTRING supposed to be a constructed value
			if(this.isConstructed === true)
			{
				resultOffset = LocalConstructedValueBlock$1.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
				if(resultOffset === (-1))
					return resultOffset;

				for(let i = 0; i < this.value.length; i++)
				{
					const currentBlockName = this.value[i].constructor.blockName();

					if(currentBlockName === EndOfContent$1.blockName())
					{
						if(this.isIndefiniteForm === true)
							break;
						else
						{
							this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
							return (-1);
						}
					}

					if(currentBlockName !== BitString$1.blockName())
					{
						this.error = "BIT STRING may consists of BIT STRINGs only";
						return (-1);
					}

					if((this.unusedBits > 0) && (this.value[i].valueBlock.unusedBits > 0))
					{
						this.error = "Usign of \"unused bits\" inside constructive BIT STRING allowed for least one only";
						return (-1);
					}

					this.unusedBits = this.value[i].valueBlock.unusedBits;
					if(this.unusedBits > 7)
					{
						this.error = "Unused bits for BitString must be in range 0-7";
						return (-1);
					}
				}

				return resultOffset;
			}
			//endregion
			//region If the BitString supposed to be a primitive value
			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

			this.unusedBits = intBuffer[0];
			
			if(this.unusedBits > 7)
			{
				this.error = "Unused bits for BitString must be in range 0-7";
				return (-1);
			}

			//region Copy input buffer to internal buffer
			this.valueHex = new ArrayBuffer(intBuffer.length - 1);
			const view = new Uint8Array(this.valueHex);
			for(let i = 0; i < (inputLength - 1); i++)
				view[i] = intBuffer[i + 1];
			//endregion

			this.blockLength = intBuffer.length;

			return (inputOffset + inputLength);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			if(this.isConstructed === true)
				return LocalConstructedValueBlock$1.prototype.toBER.call(this, sizeOnly);

			if(sizeOnly === true)
				return (new ArrayBuffer(this.valueHex.byteLength + 1));

			if(this.valueHex.byteLength === 0)
				return (new ArrayBuffer(0));

			const curView = new Uint8Array(this.valueHex);

			const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
			const retView = new Uint8Array(retBuf);

			retView[0] = this.unusedBits;

			for(let i = 0; i < this.valueHex.byteLength; i++)
				retView[i + 1] = curView[i];

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BitStringValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.unusedBits = this.unusedBits;
			object.isConstructed = this.isConstructed;
			object.isHexOnly = this.isHexOnly;
			object.valueHex = bufferToHexCodes$2(this.valueHex, 0, this.valueHex.byteLength);

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class BitString$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "BitString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBitStringValueBlock$1);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 3; // BitString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BitString";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			//region Ability to encode empty BitString
			if(inputLength === 0)
				return inputOffset;
			//endregion

			this.valueBlock.isConstructed = this.idBlock.isConstructed;
			this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

			return super.fromBER(inputBuffer, inputOffset, inputLength);
		}
		//**********************************************************************************
		/**
		 * Checking that two BITSTRINGs are equal
		 * @param {BitString} bitString
		 */
		isEqual(bitString)
		{
			//region Check input type
			if((bitString instanceof BitString$1) === false)
				return false;
			//endregion

			//region Compare two JSON strings
			if(JSON.stringify(this) !== JSON.stringify(bitString))
				return false;
			//endregion

			return true;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Integer type class
	//**************************************************************************************
	/**
	 * @extends LocalValueBlock
	 */
	class LocalIntegerValueBlock$1 extends LocalHexBlock$1(LocalValueBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalIntegerValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			if("value" in parameters)
				this.valueDec = parameters.value;
		}
		//**********************************************************************************
		/**
		 * Setter for "valueHex"
		 * @param {ArrayBuffer} _value
		 */
		set valueHex(_value)
		{
			this._valueHex = _value.slice(0);

			if(_value.byteLength >= 4)
			{
				this.warnings.push("Too big Integer for decoding, hex only");
				this.isHexOnly = true;
				this._valueDec = 0;
			}
			else
			{
				this.isHexOnly = false;

				if(_value.byteLength > 0)
					this._valueDec = utilDecodeTC$2.call(this);
			}
		}
		//**********************************************************************************
		/**
		 * Getter for "valueHex"
		 * @returns {ArrayBuffer}
		 */
		get valueHex()
		{
			return this._valueHex;
		}
		//**********************************************************************************
		/**
		 * Getter for "valueDec"
		 * @param {number} _value
		 */
		set valueDec(_value)
		{
			this._valueDec = _value;

			this.isHexOnly = false;
			this._valueHex = utilEncodeTC$2(_value);
		}
		//**********************************************************************************
		/**
		 * Getter for "valueDec"
		 * @returns {number}
		 */
		get valueDec()
		{
			return this._valueDec;
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from DER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @param {number} [expectedLength=0] Expected length of converted "valueHex" buffer
		 * @returns {number} Offset after least decoded byte
		 */
		fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0)
		{
			const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
			if(offset === (-1))
				return offset;

			const view = new Uint8Array(this._valueHex);

			if((view[0] === 0x00) && ((view[1] & 0x80) !== 0))
			{
				const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
				const updatedView = new Uint8Array(updatedValueHex);

				updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

				this._valueHex = updatedValueHex.slice(0);
			}
			else
			{
				if(expectedLength !== 0)
				{
					if(this._valueHex.byteLength < expectedLength)
					{
						if((expectedLength - this._valueHex.byteLength) > 1)
							expectedLength = this._valueHex.byteLength + 1;
						
						const updatedValueHex = new ArrayBuffer(expectedLength);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView.set(view, expectedLength - this._valueHex.byteLength);

						this._valueHex = updatedValueHex.slice(0);
					}
				}
			}

			return offset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toDER(sizeOnly = false)
		{
			const view = new Uint8Array(this._valueHex);

			switch(true)
			{
				case ((view[0] & 0x80) !== 0):
					{
						const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView[0] = 0x00;
						updatedView.set(view, 1);

						this._valueHex = updatedValueHex.slice(0);
					}
					break;
				case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):
					{
						const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
						const updatedView = new Uint8Array(updatedValueHex);

						updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

						this._valueHex = updatedValueHex.slice(0);
					}
					break;
				default:
			}

			return this.toBER(sizeOnly);
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
			if(resultOffset === (-1))
				return resultOffset;

			this.blockLength = inputLength;

			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//noinspection JSCheckFunctionSignatures
			return this.valueHex.slice(0);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "IntegerValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.valueDec = this.valueDec;

			return object;
		}
		//**********************************************************************************
		/**
		 * Convert current value to decimal string representation
		 */
		toString()
		{
			//region Aux functions
			function viewAdd(first, second)
			{
				//region Initial variables
				const c = new Uint8Array([0]);
				
				let firstView = new Uint8Array(first);
				let secondView = new Uint8Array(second);
				
				let firstViewCopy = firstView.slice(0);
				const firstViewCopyLength = firstViewCopy.length - 1;
				let secondViewCopy = secondView.slice(0);
				const secondViewCopyLength = secondViewCopy.length - 1;
				
				let value = 0;
				
				const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;
				
				let counter = 0;
				//endregion
				
				for(let i = max; i >= 0; i--, counter++)
				{
					switch(true)
					{
						case (counter < secondViewCopy.length):
							value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
							break;
						default:
							value = firstViewCopy[firstViewCopyLength - counter] + c[0];
					}
					
					c[0] = value / 10;
					
					switch(true)
					{
						case (counter >= firstViewCopy.length):
							firstViewCopy = utilConcatView$2(new Uint8Array([value % 10]), firstViewCopy);
							break;
						default:
							firstViewCopy[firstViewCopyLength - counter] = value % 10;
					}
				}
				
				if(c[0] > 0)
					firstViewCopy = utilConcatView$2(c, firstViewCopy);
				
				return firstViewCopy.slice(0);
			}
			
			function power2(n)
			{
				if(n >= powers2$1.length)
				{
					for(let p = powers2$1.length; p <= n; p++)
					{
						const c = new Uint8Array([0]);
						let digits = (powers2$1[p - 1]).slice(0);
						
						for(let i = (digits.length - 1); i >=0; i--)
						{
							const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
							c[0] = newValue[0] / 10;
							digits[i] = newValue[0] % 10;
						}
						
						if (c[0] > 0)
							digits = utilConcatView$2(c, digits);
						
						powers2$1.push(digits);
					}
				}
				
				return powers2$1[n];
			}
			
			function viewSub(first, second)
			{
				//region Initial variables
				let b = 0;
				
				let firstView = new Uint8Array(first);
				let secondView = new Uint8Array(second);
				
				let firstViewCopy = firstView.slice(0);
				const firstViewCopyLength = firstViewCopy.length - 1;
				let secondViewCopy = secondView.slice(0);
				const secondViewCopyLength = secondViewCopy.length - 1;
				
				let value;
				
				let counter = 0;
				//endregion
				
				for(let i = secondViewCopyLength; i >= 0; i--, counter++)
				{
					value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
					
					switch(true)
					{
						case (value < 0):
							b = 1;
							firstViewCopy[firstViewCopyLength - counter] = value + 10;
							break;
						default:
							b = 0;
							firstViewCopy[firstViewCopyLength - counter] = value;
					}
				}
				
				if(b > 0)
				{
					for(let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++)
					{
						value = firstViewCopy[firstViewCopyLength - counter] - b;
						
						if(value < 0)
						{
							b = 1;
							firstViewCopy[firstViewCopyLength - counter] = value + 10;
						}
						else
						{
							b = 0;
							firstViewCopy[firstViewCopyLength - counter] = value;
							break;
						}
					}
				}
				
				return firstViewCopy.slice();
			}
			//endregion
			
			//region Initial variables
			const firstBit = (this._valueHex.byteLength * 8) - 1;
			
			let digits = new Uint8Array((this._valueHex.byteLength * 8) / 3);
			let bitNumber = 0;
			let currentByte;
			
			const asn1View = new Uint8Array(this._valueHex);
			
			let result = "";
			
			let flag = false;
			//endregion
			
			//region Calculate number
			for(let byteNumber = (this._valueHex.byteLength - 1); byteNumber >= 0; byteNumber--)
			{
				currentByte = asn1View[byteNumber];
				
				for(let i = 0; i < 8; i++)
				{
					if((currentByte & 1) === 1)
					{
						switch(bitNumber)
						{
							case firstBit:
								digits = viewSub(power2(bitNumber), digits);
								result = "-";
								break;
							default:
								digits = viewAdd(digits, power2(bitNumber));
						}
					}
					
					bitNumber++;
					currentByte >>= 1;
				}
			}
			//endregion
			
			//region Print number
			for(let i = 0; i < digits.length; i++)
			{
				if(digits[i])
					flag = true;
				
				if(flag)
					result += digitsString$1.charAt(digits[i]);
			}
			
			if(flag === false)
				result += digitsString$1.charAt(0);
			//endregion
			
			return result;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class Integer$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Integer" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalIntegerValueBlock$1);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 2; // Integer
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Integer";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Compare two Integer object, or Integer and ArrayBuffer objects
		 * @param {!Integer|ArrayBuffer} otherValue
		 * @returns {boolean}
		 */
		isEqual(otherValue)
		{
			if(otherValue instanceof Integer$1)
			{
				if(this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers
					return isEqualBuffer$2(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);

				if(this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly)
					return (this.valueBlock.valueDec === otherValue.valueBlock.valueDec);

				return false;
			}
			
			if(otherValue instanceof ArrayBuffer)
				return isEqualBuffer$2(this.valueBlock.valueHex, otherValue);

			return false;
		}
		//**********************************************************************************
		/**
		 * Convert current Integer value from BER into DER format
		 * @returns {Integer}
		 */
		convertToDER()
		{
			const integer = new Integer$1({ valueHex: this.valueBlock.valueHex });
			integer.valueBlock.toDER();

			return integer;
		}
		//**********************************************************************************
		/**
		 * Convert current Integer value from DER to BER format
		 * @returns {Integer}
		 */
		convertFromDER()
		{
			const expectedLength = (this.valueBlock.valueHex.byteLength % 2) ? (this.valueBlock.valueHex.byteLength + 1) : this.valueBlock.valueHex.byteLength;
			const integer = new Integer$1({ valueHex: this.valueBlock.valueHex });
			integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);
			
			return integer;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 Enumerated type class
	//**************************************************************************************
	class Enumerated$1 extends Integer$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Enumerated" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 10; // Enumerated
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Enumerated";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of ASN.1 ObjectIdentifier type class
	//**************************************************************************************
	class LocalSidValueBlock$1 extends LocalHexBlock$1(LocalBaseBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalSidValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {number} [valueDec]
		 * @property {boolean} [isFirstSid]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.valueDec = getParametersValue$2(parameters, "valueDec", -1);
			this.isFirstSid = getParametersValue$2(parameters, "isFirstSid", false);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "sidBlock";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			if(inputLength === 0)
				return inputOffset;

			//region Basic check for parameters
			//noinspection JSCheckFunctionSignatures
			if(checkBufferParams$2(this, inputBuffer, inputOffset, inputLength) === false)
				return (-1);
			//endregion

			const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

			this.valueHex = new ArrayBuffer(inputLength);
			let view = new Uint8Array(this.valueHex);

			for(let i = 0; i < inputLength; i++)
			{
				view[i] = intBuffer[i] & 0x7F;

				this.blockLength++;

				if((intBuffer[i] & 0x80) === 0x00)
					break;
			}

			//region Ajust size of valueHex buffer
			const tempValueHex = new ArrayBuffer(this.blockLength);
			const tempView = new Uint8Array(tempValueHex);

			for(let i = 0; i < this.blockLength; i++)
				tempView[i] = view[i];

			//noinspection JSCheckFunctionSignatures
			this.valueHex = tempValueHex.slice(0);
			view = new Uint8Array(this.valueHex);
			//endregion

			if((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)
			{
				this.error = "End of input reached before message was fully decoded";
				return (-1);
			}

			if(view[0] === 0x00)
				this.warnings.push("Needlessly long format of SID encoding");

			if(this.blockLength <= 8)
				this.valueDec = utilFromBase$2(view, 7);
			else
			{
				this.isHexOnly = true;
				this.warnings.push("Too big SID for decoding, hex only");
			}

			return (inputOffset + this.blockLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			//region Initial variables
			let retBuf;
			let retView;
			//endregion

			if(this.isHexOnly)
			{
				if(sizeOnly === true)
					return (new ArrayBuffer(this.valueHex.byteLength));

				const curView = new Uint8Array(this.valueHex);

				retBuf = new ArrayBuffer(this.blockLength);
				retView = new Uint8Array(retBuf);

				for(let i = 0; i < (this.blockLength - 1); i++)
					retView[i] = curView[i] | 0x80;

				retView[this.blockLength - 1] = curView[this.blockLength - 1];

				return retBuf;
			}

			const encodedBuf = utilToBase$2(this.valueDec, 7);
			if(encodedBuf.byteLength === 0)
			{
				this.error = "Error during encoding SID value";
				return (new ArrayBuffer(0));
			}

			retBuf = new ArrayBuffer(encodedBuf.byteLength);

			if(sizeOnly === false)
			{
				const encodedView = new Uint8Array(encodedBuf);
				retView = new Uint8Array(retBuf);

				for(let i = 0; i < (encodedBuf.byteLength - 1); i++)
					retView[i] = encodedView[i] | 0x80;

				retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Create string representation of current SID block
		 * @returns {string}
		 */
		toString()
		{
			let result = "";

			if(this.isHexOnly === true)
				result = bufferToHexCodes$2(this.valueHex, 0, this.valueHex.byteLength);
			else
			{
				if(this.isFirstSid)
				{
					let sidValue = this.valueDec;

					if(this.valueDec <= 39)
						result = "0.";
					else
					{
						if(this.valueDec <= 79)
						{
							result = "1.";
							sidValue -= 40;
						}
						else
						{
							result = "2.";
							sidValue -= 80;
						}
					}

					result += sidValue.toString();
				}
				else
					result = this.valueDec.toString();
			}

			return result;
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.valueDec = this.valueDec;
			object.isFirstSid = this.isFirstSid;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class LocalObjectIdentifierValueBlock$1 extends LocalValueBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalObjectIdentifierValueBlock" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.fromString(getParametersValue$2(parameters, "value", ""));
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			let resultOffset = inputOffset;

			while(inputLength > 0)
			{
				const sidBlock = new LocalSidValueBlock$1();
				resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
				if(resultOffset === (-1))
				{
					this.blockLength = 0;
					this.error = sidBlock.error;
					return resultOffset;
				}

				if(this.value.length === 0)
					sidBlock.isFirstSid = true;

				this.blockLength += sidBlock.blockLength;
				inputLength -= sidBlock.blockLength;

				this.value.push(sidBlock);
			}

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			let retBuf = new ArrayBuffer(0);

			for(let i = 0; i < this.value.length; i++)
			{
				const valueBuf = this.value[i].toBER(sizeOnly);
				if(valueBuf.byteLength === 0)
				{
					this.error = this.value[i].error;
					return (new ArrayBuffer(0));
				}

				retBuf = utilConcatBuf$2(retBuf, valueBuf);
			}

			return retBuf;
		}
		//**********************************************************************************
		/**
		 * Create "LocalObjectIdentifierValueBlock" class from string
		 * @param {string} string Input string to convert from
		 * @returns {boolean}
		 */
		fromString(string)
		{
			this.value = []; // Clear existing SID values

			let pos1 = 0;
			let pos2 = 0;

			let sid = "";

			let flag = false;

			do
			{
				pos2 = string.indexOf(".", pos1);
				if(pos2 === (-1))
					sid = string.substr(pos1);
				else
					sid = string.substr(pos1, pos2 - pos1);

				pos1 = pos2 + 1;

				if(flag)
				{
					const sidBlock = this.value[0];

					let plus = 0;

					switch(sidBlock.valueDec)
					{
						case 0:
							break;
						case 1:
							plus = 40;
							break;
						case 2:
							plus = 80;
							break;
						default:
							this.value = []; // clear SID array
							return false; // ???
					}

					const parsedSID = parseInt(sid, 10);
					if(isNaN(parsedSID))
						return true;

					sidBlock.valueDec = parsedSID + plus;

					flag = false;
				}
				else
				{
					const sidBlock = new LocalSidValueBlock$1();
					sidBlock.valueDec = parseInt(sid, 10);
					if(isNaN(sidBlock.valueDec))
						return true;

					if(this.value.length === 0)
					{
						sidBlock.isFirstSid = true;
						flag = true;
					}

					this.value.push(sidBlock);
				}
			} while(pos2 !== (-1));

			return true;
		}
		//**********************************************************************************
		/**
		 * Converts "LocalObjectIdentifierValueBlock" class to string
		 * @returns {string}
		 */
		toString()
		{
			let result = "";
			let isHexOnly = false;

			for(let i = 0; i < this.value.length; i++)
			{
				isHexOnly = this.value[i].isHexOnly;

				let sidStr = this.value[i].toString();

				if(i !== 0)
					result = `${result}.`;

				if(isHexOnly)
				{
					sidStr = `{${sidStr}}`;

					if(this.value[i].isFirstSid)
						result = `2.{${sidStr} - 80}`;
					else
						result += sidStr;
				}
				else
					result += sidStr;
			}

			return result;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "ObjectIdentifierValueBlock";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.toString();
			object.sidArray = [];
			for(let i = 0; i < this.value.length; i++)
				object.sidArray.push(this.value[i].toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class ObjectIdentifier$2 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "ObjectIdentifier" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalObjectIdentifierValueBlock$1);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "ObjectIdentifier";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of all string's classes
	//**************************************************************************************
	class LocalUtf8StringValueBlock$1 extends LocalHexBlock$1(LocalBaseBlock$1)
	{
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Constructor for "LocalUtf8StringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isHexOnly = true;
			this.value = ""; // String representation of decoded ArrayBuffer
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Utf8StringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class Utf8String$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Utf8String" class
		 * @param {Object} [parameters={}]
		 * @property {ArrayBuffer} [valueHex]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalUtf8StringValueBlock$1);

			if("value" in parameters)
				this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 12; // Utf8String
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Utf8String";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));

			try
			{
				//noinspection JSDeprecatedSymbols
				this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));
			}
			catch(ex)
			{
				this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
			}
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			//noinspection JSDeprecatedSymbols
			const str = unescape(encodeURIComponent(inputString));
			const strLen = str.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLen);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLen; i++)
				view[i] = str.charCodeAt(i);

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalBaseBlock
	 * @extends LocalHexBlock
	 */
	class LocalBmpStringValueBlock$1 extends LocalHexBlock$1(LocalBaseBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalBmpStringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isHexOnly = true;
			this.value = "";
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BmpStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class BmpString$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "BmpString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalBmpStringValueBlock$1);

			if("value" in parameters)
				this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 30; // BmpString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "BmpString";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			//noinspection JSCheckFunctionSignatures
			const copyBuffer = inputBuffer.slice(0);
			const valueView = new Uint8Array(copyBuffer);

			for(let i = 0; i < valueView.length; i += 2)
			{
				const temp = valueView[i];

				valueView[i] = valueView[i + 1];
				valueView[i + 1] = temp;
			}

			this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			const strLength = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);
			const valueHexView = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLength; i++)
			{
				const codeBuf = utilToBase$2(inputString.charCodeAt(i), 8);
				const codeView = new Uint8Array(codeBuf);
				if(codeView.length > 2)
					continue;

				const dif = 2 - codeView.length;

				for(let j = (codeView.length - 1); j >= 0; j--)
					valueHexView[i * 2 + j + dif] = codeView[j];
			}

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class LocalUniversalStringValueBlock$1 extends LocalHexBlock$1(LocalBaseBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalUniversalStringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.isHexOnly = true;
			this.value = "";
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "UniversalStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class UniversalString$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "UniversalString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalUniversalStringValueBlock$1);

			if("value" in parameters)
				this.fromString(parameters.value);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 28; // UniversalString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "UniversalString";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			//noinspection JSCheckFunctionSignatures
			const copyBuffer = inputBuffer.slice(0);
			const valueView = new Uint8Array(copyBuffer);

			for(let i = 0; i < valueView.length; i += 4)
			{
				valueView[i] = valueView[i + 3];
				valueView[i + 1] = valueView[i + 2];
				valueView[i + 2] = 0x00;
				valueView[i + 3] = 0x00;
			}

			this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			const strLength = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);
			const valueHexView = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLength; i++)
			{
				const codeBuf = utilToBase$2(inputString.charCodeAt(i), 8);
				const codeView = new Uint8Array(codeBuf);
				if(codeView.length > 4)
					continue;

				const dif = 4 - codeView.length;

				for(let j = (codeView.length - 1); j >= 0; j--)
					valueHexView[i * 4 + j + dif] = codeView[j];
			}

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class LocalSimpleStringValueBlock$1 extends LocalHexBlock$1(LocalBaseBlock$1)
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalSimpleStringValueBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.value = "";
			this.isHexOnly = true;
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "SimpleStringValueBlock";
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.value = this.value;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends BaseBlock
	 */
	class LocalSimpleStringBlock$1 extends BaseBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "LocalSimpleStringBlock" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters, LocalSimpleStringValueBlock$1);

			if("value" in parameters)
				this.fromString(parameters.value);
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "SIMPLESTRING";
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			const strLen = inputString.length;

			this.valueBlock.valueHex = new ArrayBuffer(strLen);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < strLen; i++)
				view[i] = inputString.charCodeAt(i);

			this.valueBlock.value = inputString;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class NumericString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "NumericString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 18; // NumericString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "NumericString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class PrintableString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "PrintableString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 19; // PrintableString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "PrintableString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class TeletexString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "TeletexString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 20; // TeletexString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "TeletexString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class VideotexString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "VideotexString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 21; // VideotexString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "VideotexString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class IA5String$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "IA5String" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 22; // IA5String
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "IA5String";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class GraphicString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "GraphicString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 25; // GraphicString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "GraphicString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class VisibleString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "VisibleString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 26; // VisibleString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "VisibleString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class GeneralString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "GeneralString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 27; // GeneralString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "GeneralString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends LocalSimpleStringBlock
	 */
	class CharacterString$1 extends LocalSimpleStringBlock$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "CharacterString" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 29; // CharacterString
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "CharacterString";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of all date and time classes
	//**************************************************************************************
	/**
	 * @extends VisibleString
	 */
	class UTCTime$1 extends VisibleString$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "UTCTime" class
		 * @param {Object} [parameters={}]
		 * @property {string} [value] String representatio of the date
		 * @property {Date} [valueDate] JavaScript "Date" object
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.year = 0;
			this.month = 0;
			this.day = 0;
			this.hour = 0;
			this.minute = 0;
			this.second = 0;

			//region Create UTCTime from ASN.1 UTC string value
			if("value" in parameters)
			{
				this.fromString(parameters.value);

				this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
				const view = new Uint8Array(this.valueBlock.valueHex);

				for(let i = 0; i < parameters.value.length; i++)
					view[i] = parameters.value.charCodeAt(i);
			}
			//endregion
			//region Create GeneralizedTime from JavaScript Date type
			if("valueDate" in parameters)
			{
				this.fromDate(parameters.valueDate);
				this.valueBlock.valueHex = this.toBuffer();
			}
			//endregion

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 23; // UTCTime
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal string into ArrayBuffer
		 * @returns {ArrayBuffer}
		 */
		toBuffer()
		{
			const str = this.toString();

			const buffer = new ArrayBuffer(str.length);
			const view = new Uint8Array(buffer);

			for(let i = 0; i < str.length; i++)
				view[i] = str.charCodeAt(i);

			return buffer;
		}
		//**********************************************************************************
		/**
		 * Function converting "Date" object into ASN.1 internal string
		 * @param {!Date} inputDate JavaScript "Date" object
		 */
		fromDate(inputDate)
		{
			this.year = inputDate.getUTCFullYear();
			this.month = inputDate.getUTCMonth() + 1;
			this.day = inputDate.getUTCDate();
			this.hour = inputDate.getUTCHours();
			this.minute = inputDate.getUTCMinutes();
			this.second = inputDate.getUTCSeconds();
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Function converting ASN.1 internal string into "Date" object
		 * @returns {Date}
		 */
		toDate()
		{
			return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			//region Parse input string
			const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
			const parserArray = parser.exec(inputString);
			if(parserArray === null)
			{
				this.error = "Wrong input string for convertion";
				return;
			}
			//endregion

			//region Store parsed values
			const year = parseInt(parserArray[1], 10);
			if(year >= 50)
				this.year = 1900 + year;
			else
				this.year = 2000 + year;

			this.month = parseInt(parserArray[2], 10);
			this.day = parseInt(parserArray[3], 10);
			this.hour = parseInt(parserArray[4], 10);
			this.minute = parseInt(parserArray[5], 10);
			this.second = parseInt(parserArray[6], 10);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal class into JavaScript string
		 * @returns {string}
		 */
		toString()
		{
			const outputArray = new Array(7);

			outputArray[0] = padNumber$2(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);
			outputArray[1] = padNumber$2(this.month, 2);
			outputArray[2] = padNumber$2(this.day, 2);
			outputArray[3] = padNumber$2(this.hour, 2);
			outputArray[4] = padNumber$2(this.minute, 2);
			outputArray[5] = padNumber$2(this.second, 2);
			outputArray[6] = "Z";

			return outputArray.join("");
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "UTCTime";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.year = this.year;
			object.month = this.month;
			object.day = this.day;
			object.hour = this.hour;
			object.minute = this.minute;
			object.second = this.second;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends VisibleString
	 */
	class GeneralizedTime$1 extends VisibleString$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "GeneralizedTime" class
		 * @param {Object} [parameters={}]
		 * @property {string} [value] String representatio of the date
		 * @property {Date} [valueDate] JavaScript "Date" object
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.year = 0;
			this.month = 0;
			this.day = 0;
			this.hour = 0;
			this.minute = 0;
			this.second = 0;
			this.millisecond = 0;

			//region Create UTCTime from ASN.1 UTC string value
			if("value" in parameters)
			{
				this.fromString(parameters.value);

				this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
				const view = new Uint8Array(this.valueBlock.valueHex);

				for(let i = 0; i < parameters.value.length; i++)
					view[i] = parameters.value.charCodeAt(i);
			}
			//endregion
			//region Create GeneralizedTime from JavaScript Date type
			if("valueDate" in parameters)
			{
				this.fromDate(parameters.valueDate);
				this.valueBlock.valueHex = this.toBuffer();
			}
			//endregion

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 24; // GeneralizedTime
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
			if(resultOffset === (-1))
			{
				this.error = this.valueBlock.error;
				return resultOffset;
			}

			this.fromBuffer(this.valueBlock.valueHex);

			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			if(this.valueBlock.error.length === 0)
				this.blockLength += this.valueBlock.blockLength;

			return resultOffset;
		}
		//**********************************************************************************
		/**
		 * Function converting ArrayBuffer into ASN.1 internal string
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 */
		fromBuffer(inputBuffer)
		{
			this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal string into ArrayBuffer
		 * @returns {ArrayBuffer}
		 */
		toBuffer()
		{
			const str = this.toString();

			const buffer = new ArrayBuffer(str.length);
			const view = new Uint8Array(buffer);

			for(let i = 0; i < str.length; i++)
				view[i] = str.charCodeAt(i);

			return buffer;
		}
		//**********************************************************************************
		/**
		 * Function converting "Date" object into ASN.1 internal string
		 * @param {!Date} inputDate JavaScript "Date" object
		 */
		fromDate(inputDate)
		{
			this.year = inputDate.getUTCFullYear();
			this.month = inputDate.getUTCMonth() + 1;
			this.day = inputDate.getUTCDate();
			this.hour = inputDate.getUTCHours();
			this.minute = inputDate.getUTCMinutes();
			this.second = inputDate.getUTCSeconds();
			this.millisecond = inputDate.getUTCMilliseconds();
		}
		//**********************************************************************************
		//noinspection JSUnusedGlobalSymbols
		/**
		 * Function converting ASN.1 internal string into "Date" object
		 * @returns {Date}
		 */
		toDate()
		{
			return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));
		}
		//**********************************************************************************
		/**
		 * Function converting JavaScript string into ASN.1 internal class
		 * @param {!string} inputString ASN.1 BER encoded array
		 */
		fromString(inputString)
		{
			//region Initial variables
			let isUTC = false;

			let timeString = "";
			let dateTimeString = "";
			let fractionPart = 0;

			let parser;

			let hourDifference = 0;
			let minuteDifference = 0;
			//endregion

			//region Convert as UTC time
			if(inputString[inputString.length - 1] === "Z")
			{
				timeString = inputString.substr(0, inputString.length - 1);

				isUTC = true;
			}
			//endregion
			//region Convert as local time
			else
			{
				//noinspection JSPrimitiveTypeWrapperUsage
				const number = new Number(inputString[inputString.length - 1]);

				if(isNaN(number.valueOf()))
					throw new Error("Wrong input string for convertion");

				timeString = inputString;
			}
			//endregion

			//region Check that we do not have a "+" and "-" symbols inside UTC time
			if(isUTC)
			{
				if(timeString.indexOf("+") !== (-1))
					throw new Error("Wrong input string for convertion");

				if(timeString.indexOf("-") !== (-1))
					throw new Error("Wrong input string for convertion");
			}
			//endregion
			//region Get "UTC time difference" in case of local time
			else
			{
				let multiplier = 1;
				let differencePosition = timeString.indexOf("+");
				let differenceString = "";

				if(differencePosition === (-1))
				{
					differencePosition = timeString.indexOf("-");
					multiplier = (-1);
				}

				if(differencePosition !== (-1))
				{
					differenceString = timeString.substr(differencePosition + 1);
					timeString = timeString.substr(0, differencePosition);

					if((differenceString.length !== 2) && (differenceString.length !== 4))
						throw new Error("Wrong input string for convertion");

					//noinspection JSPrimitiveTypeWrapperUsage
					let number = new Number(differenceString.substr(0, 2));

					if(isNaN(number.valueOf()))
						throw new Error("Wrong input string for convertion");

					hourDifference = multiplier * number;

					if(differenceString.length === 4)
					{
						//noinspection JSPrimitiveTypeWrapperUsage
						number = new Number(differenceString.substr(2, 2));

						if(isNaN(number.valueOf()))
							throw new Error("Wrong input string for convertion");

						minuteDifference = multiplier * number;
					}
				}
			}
			//endregion

			//region Get position of fraction point
			let fractionPointPosition = timeString.indexOf("."); // Check for "full stop" symbol
			if(fractionPointPosition === (-1))
				fractionPointPosition = timeString.indexOf(","); // Check for "comma" symbol
			//endregion

			//region Get fraction part
			if(fractionPointPosition !== (-1))
			{
				//noinspection JSPrimitiveTypeWrapperUsage
				const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);

				if(isNaN(fractionPartCheck.valueOf()))
					throw new Error("Wrong input string for convertion");

				fractionPart = fractionPartCheck.valueOf();

				dateTimeString = timeString.substr(0, fractionPointPosition);
			}
			else
				dateTimeString = timeString;
			//endregion

			//region Parse internal date
			switch(true)
			{
				case (dateTimeString.length === 8): // "YYYYMMDD"
					parser = /(\d{4})(\d{2})(\d{2})/ig;
					if(fractionPointPosition !== (-1))
						throw new Error("Wrong input string for convertion"); // Here we should not have a "fraction point"
					break;
				case (dateTimeString.length === 10): // "YYYYMMDDHH"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;

					if(fractionPointPosition !== (-1))
					{
						let fractionResult = 60 * fractionPart;
						this.minute = Math.floor(fractionResult);

						fractionResult = 60 * (fractionResult - this.minute);
						this.second = Math.floor(fractionResult);

						fractionResult = 1000 * (fractionResult - this.second);
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				case (dateTimeString.length === 12): // "YYYYMMDDHHMM"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

					if(fractionPointPosition !== (-1))
					{
						let fractionResult = 60 * fractionPart;
						this.second = Math.floor(fractionResult);

						fractionResult = 1000 * (fractionResult - this.second);
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				case (dateTimeString.length === 14): // "YYYYMMDDHHMMSS"
					parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

					if(fractionPointPosition !== (-1))
					{
						const fractionResult = 1000 * fractionPart;
						this.millisecond = Math.floor(fractionResult);
					}
					break;
				default:
					throw new Error("Wrong input string for convertion");
			}
			//endregion

			//region Put parsed values at right places
			const parserArray = parser.exec(dateTimeString);
			if(parserArray === null)
				throw new Error("Wrong input string for convertion");

			for(let j = 1; j < parserArray.length; j++)
			{
				switch(j)
				{
					case 1:
						this.year = parseInt(parserArray[j], 10);
						break;
					case 2:
						this.month = parseInt(parserArray[j], 10);
						break;
					case 3:
						this.day = parseInt(parserArray[j], 10);
						break;
					case 4:
						this.hour = parseInt(parserArray[j], 10) + hourDifference;
						break;
					case 5:
						this.minute = parseInt(parserArray[j], 10) + minuteDifference;
						break;
					case 6:
						this.second = parseInt(parserArray[j], 10);
						break;
					default:
						throw new Error("Wrong input string for convertion");
				}
			}
			//endregion

			//region Get final date
			if(isUTC === false)
			{
				const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);

				this.year = tempDate.getUTCFullYear();
				this.month = tempDate.getUTCMonth();
				this.day = tempDate.getUTCDay();
				this.hour = tempDate.getUTCHours();
				this.minute = tempDate.getUTCMinutes();
				this.second = tempDate.getUTCSeconds();
				this.millisecond = tempDate.getUTCMilliseconds();
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Function converting ASN.1 internal class into JavaScript string
		 * @returns {string}
		 */
		toString()
		{
			const outputArray = [];

			outputArray.push(padNumber$2(this.year, 4));
			outputArray.push(padNumber$2(this.month, 2));
			outputArray.push(padNumber$2(this.day, 2));
			outputArray.push(padNumber$2(this.hour, 2));
			outputArray.push(padNumber$2(this.minute, 2));
			outputArray.push(padNumber$2(this.second, 2));
			if(this.millisecond !== 0)
			{
				outputArray.push(".");
				outputArray.push(padNumber$2(this.millisecond, 3));
			}
			outputArray.push("Z");

			return outputArray.join("");
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "GeneralizedTime";
		}
		//**********************************************************************************
		/**
		 * Convertion for the block to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let object = {};
			
			//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
			try
			{
				object = super.toJSON();
			}
			catch(ex){}
			//endregion

			object.year = this.year;
			object.month = this.month;
			object.day = this.day;
			object.hour = this.hour;
			object.minute = this.minute;
			object.second = this.second;
			object.millisecond = this.millisecond;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class DATE$1 extends Utf8String$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "DATE" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 31; // DATE
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "DATE";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class TimeOfDay$1 extends Utf8String$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "TimeOfDay" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 32; // TimeOfDay
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "TimeOfDay";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class DateTime$1 extends Utf8String$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "DateTime" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 33; // DateTime
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "DateTime";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class Duration$1 extends Utf8String$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Duration" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 34; // Duration
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "Duration";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * @extends Utf8String
	 */
	class TIME$1 extends Utf8String$1
	{
		//**********************************************************************************
		/**
		 * Constructor for "Time" class
		 * @param {Object} [parameters={}]
		 */
		constructor(parameters = {})
		{
			super(parameters);

			this.idBlock.tagClass = 1; // UNIVERSAL
			this.idBlock.tagNumber = 14; // Time
		}
		//**********************************************************************************
		/**
		 * Aux function, need to get a block name. Need to have it here for inhiritence
		 * @returns {string}
		 */
		static blockName()
		{
			return "TIME";
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type Choice
	//**************************************************************************************
	class Choice
	{
		//**********************************************************************************
		/**
		 * Constructor for "Choice" class
		 * @param {Object} [parameters={}]
		 * @property {Array} [value] Array of ASN.1 types for make a choice from
		 * @property {boolean} [optional]
		 */
		constructor(parameters = {})
		{
			this.value = getParametersValue$2(parameters, "value", []);
			this.optional = getParametersValue$2(parameters, "optional", false);
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type Any
	//**************************************************************************************
	class Any
	{
		//**********************************************************************************
		/**
		 * Constructor for "Any" class
		 * @param {Object} [parameters={}]
		 * @property {string} [name]
		 * @property {boolean} [optional]
		 */
		constructor(parameters = {})
		{
			this.name = getParametersValue$2(parameters, "name", "");
			this.optional = getParametersValue$2(parameters, "optional", false);
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type Repeated
	//**************************************************************************************
	class Repeated
	{
		//**********************************************************************************
		/**
		 * Constructor for "Repeated" class
		 * @param {Object} [parameters={}]
		 * @property {string} [name]
		 * @property {boolean} [optional]
		 */
		constructor(parameters = {})
		{
			this.name = getParametersValue$2(parameters, "name", "");
			this.optional = getParametersValue$2(parameters, "optional", false);
			this.value = getParametersValue$2(parameters, "value", new Any());
			this.local = getParametersValue$2(parameters, "local", false); // Could local or global array to store elements
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of special ASN.1 schema type RawData
	//**************************************************************************************
	/**
	 * @description Special class providing ability to have "toBER/fromBER" for raw ArrayBuffer
	 */
	class RawData
	{
		//**********************************************************************************
		/**
		 * Constructor for "Repeated" class
		 * @param {Object} [parameters={}]
		 * @property {string} [name]
		 * @property {boolean} [optional]
		 */
		constructor(parameters = {})
		{
			this.data = getParametersValue$2(parameters, "data", new ArrayBuffer(0));
		}
		//**********************************************************************************
		/**
		 * Base function for converting block from BER encoded array of bytes
		 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
		 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
		 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
		 * @returns {number} Offset after least decoded byte
		 */
		fromBER(inputBuffer, inputOffset, inputLength)
		{
			this.data = inputBuffer.slice(inputOffset, inputLength);
			return (inputOffset + inputLength);
		}
		//**********************************************************************************
		/**
		 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
		 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
		 * @returns {ArrayBuffer}
		 */
		toBER(sizeOnly = false)
		{
			return this.data;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Major ASN.1 BER decoding function
	//**************************************************************************************
	/**
	 * Internal library function for decoding ASN.1 BER
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {{offset: number, result: Object}}
	 */
	function LocalFromBER$1(inputBuffer, inputOffset, inputLength)
	{
		const incomingOffset = inputOffset; // Need to store initial offset since "inputOffset" is changing in the function

		//region Local function changing a type for ASN.1 classes
		function localChangeType(inputObject, newType)
		{
			if(inputObject instanceof newType)
				return inputObject;

			const newObject = new newType();
			newObject.idBlock = inputObject.idBlock;
			newObject.lenBlock = inputObject.lenBlock;
			newObject.warnings = inputObject.warnings;
			//noinspection JSCheckFunctionSignatures
			newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);

			return newObject;
		}
		//endregion

		//region Create a basic ASN.1 type since we need to return errors and warnings from the function
		let returnObject = new BaseBlock$1({}, Object);
		//endregion

		//region Basic check for parameters
		if(checkBufferParams$2(new LocalBaseBlock$1(), inputBuffer, inputOffset, inputLength) === false)
		{
			returnObject.error = "Wrong input parameters";
			return {
				offset: (-1),
				result: returnObject
			};
		}
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if(intBuffer.length === 0)
		{
			this.error = "Zero buffer length";
			return {
				offset: (-1),
				result: returnObject
			};
		}
		//endregion

		//region Decode indentifcation block of ASN.1 BER structure
		let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
		returnObject.warnings.concat(returnObject.idBlock.warnings);
		if(resultOffset === (-1))
		{
			returnObject.error = returnObject.idBlock.error;
			return {
				offset: (-1),
				result: returnObject
			};
		}

		inputOffset = resultOffset;
		inputLength -= returnObject.idBlock.blockLength;
		//endregion

		//region Decode length block of ASN.1 BER structure
		resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
		returnObject.warnings.concat(returnObject.lenBlock.warnings);
		if(resultOffset === (-1))
		{
			returnObject.error = returnObject.lenBlock.error;
			return {
				offset: (-1),
				result: returnObject
			};
		}

		inputOffset = resultOffset;
		inputLength -= returnObject.lenBlock.blockLength;
		//endregion

		//region Check for usign indefinite length form in encoding for primitive types
		if((returnObject.idBlock.isConstructed === false) &&
			(returnObject.lenBlock.isIndefiniteForm === true))
		{
			returnObject.error = "Indefinite length form used for primitive encoding form";
			return {
				offset: (-1),
				result: returnObject
			};
		}
		//endregion

		//region Switch ASN.1 block type
		let newASN1Type = BaseBlock$1;

		switch(returnObject.idBlock.tagClass)
		{
			//region UNIVERSAL
			case 1:
				//region Check for reserved tag numbers
				if((returnObject.idBlock.tagNumber >= 37) &&
					(returnObject.idBlock.isHexOnly === false))
				{
					returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
					return {
						offset: (-1),
						result: returnObject
					};
				}
				//endregion

				switch(returnObject.idBlock.tagNumber)
				{
					//region EndOfContent type
					case 0:
						//region Check for EndOfContent type
						if((returnObject.idBlock.isConstructed === true) &&
							(returnObject.lenBlock.length > 0))
						{
							returnObject.error = "Type [UNIVERSAL 0] is reserved";
							return {
								offset: (-1),
								result: returnObject
							};
						}
						//endregion

						newASN1Type = EndOfContent$1;

						break;
					//endregion
					//region Boolean type
					case 1:
						newASN1Type = Boolean$1;
						break;
					//endregion
					//region Integer type
					case 2:
						newASN1Type = Integer$1;
						break;
					//endregion
					//region BitString type
					case 3:
						newASN1Type = BitString$1;
						break;
					//endregion
					//region OctetString type
					case 4:
						newASN1Type = OctetString$1;
						break;
					//endregion
					//region Null type
					case 5:
						newASN1Type = Null$1;
						break;
					//endregion
					//region OBJECT IDENTIFIER type
					case 6:
						newASN1Type = ObjectIdentifier$2;
						break;
					//endregion
					//region Enumerated type
					case 10:
						newASN1Type = Enumerated$1;
						break;
					//endregion
					//region Utf8String type
					case 12:
						newASN1Type = Utf8String$1;
						break;
					//endregion
					//region Time type
					case 14:
						newASN1Type = TIME$1;
						break;
					//endregion
					//region ASN.1 reserved type
					case 15:
						returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
						return {
							offset: (-1),
							result: returnObject
						};
					//endregion
					//region Sequence type
					case 16:
						newASN1Type = Sequence$1;
						break;
					//endregion
					//region Set type
					case 17:
						newASN1Type = Set$1;
						break;
					//endregion
					//region NumericString type
					case 18:
						newASN1Type = NumericString$1;
						break;
					//endregion
					//region PrintableString type
					case 19:
						newASN1Type = PrintableString$1;
						break;
					//endregion
					//region TeletexString type
					case 20:
						newASN1Type = TeletexString$1;
						break;
					//endregion
					//region VideotexString type
					case 21:
						newASN1Type = VideotexString$1;
						break;
					//endregion
					//region IA5String type
					case 22:
						newASN1Type = IA5String$1;
						break;
					//endregion
					//region UTCTime type
					case 23:
						newASN1Type = UTCTime$1;
						break;
					//endregion
					//region GeneralizedTime type
					case 24:
						newASN1Type = GeneralizedTime$1;
						break;
					//endregion
					//region GraphicString type
					case 25:
						newASN1Type = GraphicString$1;
						break;
					//endregion
					//region VisibleString type
					case 26:
						newASN1Type = VisibleString$1;
						break;
					//endregion
					//region GeneralString type
					case 27:
						newASN1Type = GeneralString$1;
						break;
					//endregion
					//region UniversalString type
					case 28:
						newASN1Type = UniversalString$1;
						break;
					//endregion
					//region CharacterString type
					case 29:
						newASN1Type = CharacterString$1;
						break;
					//endregion
					//region BmpString type
					case 30:
						newASN1Type = BmpString$1;
						break;
					//endregion
					//region DATE type
					case 31:
						newASN1Type = DATE$1;
						break;
					//endregion
					//region TimeOfDay type
					case 32:
						newASN1Type = TimeOfDay$1;
						break;
					//endregion
					//region Date-Time type
					case 33:
						newASN1Type = DateTime$1;
						break;
					//endregion
					//region Duration type
					case 34:
						newASN1Type = Duration$1;
						break;
					//endregion
					//region default
					default:
						{
							let newObject;

							if(returnObject.idBlock.isConstructed === true)
								newObject = new Constructed$1();
							else
								newObject = new Primitive$1();

							newObject.idBlock = returnObject.idBlock;
							newObject.lenBlock = returnObject.lenBlock;
							newObject.warnings = returnObject.warnings;

							returnObject = newObject;

							resultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);
						}
					//endregion
				}
				break;
			//endregion
			//region All other tag classes
			case 2: // APPLICATION
			case 3: // CONTEXT-SPECIFIC
			case 4: // PRIVATE
			default:
				{
					if(returnObject.idBlock.isConstructed === true)
						newASN1Type = Constructed$1;
					else
						newASN1Type = Primitive$1;
				}
			//endregion
		}
		//endregion

		//region Change type and perform BER decoding
		returnObject = localChangeType(returnObject, newASN1Type);
		resultOffset = returnObject.fromBER(inputBuffer, inputOffset, (returnObject.lenBlock.isIndefiniteForm === true) ? inputLength : returnObject.lenBlock.length);
		//endregion

		//region Coping incoming buffer for entire ASN.1 block
		returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);
		//endregion

		return {
			offset: resultOffset,
			result: returnObject
		};
	}
	//**************************************************************************************
	/**
	 * Major function for decoding ASN.1 BER array into internal library structuries
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes
	 */
	function fromBER$1(inputBuffer)
	{
		if(inputBuffer.byteLength === 0)
		{
			const result = new BaseBlock$1({}, Object);
			result.error = "Input buffer has zero length";

			return {
				offset: (-1),
				result
			};
		}

		return LocalFromBER$1(inputBuffer, 0, inputBuffer.byteLength);
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Major scheme verification function
	//**************************************************************************************
	/**
	 * Compare of two ASN.1 object trees
	 * @param {!Object} root Root of input ASN.1 object tree
	 * @param {!Object} inputData Input ASN.1 object tree
	 * @param {!Object} inputSchema Input ASN.1 schema to compare with
	 * @return {{verified: boolean}|{verified:boolean, result: Object}}
	 */
	function compareSchema(root, inputData, inputSchema)
	{
		//region Special case for Choice schema element type
		if(inputSchema instanceof Choice)
		{

			for(let j = 0; j < inputSchema.value.length; j++)
			{
				const result = compareSchema(root, inputData, inputSchema.value[j]);
				if(result.verified === true)
				{
					return {
						verified: true,
						result: root
					};
				}
			}

			{
				const _result = {
					verified: false,
					result: {
						error: "Wrong values for Choice type"
					}
				};

				if(inputSchema.hasOwnProperty("name"))
					_result.name = inputSchema.name;

				return _result;
			}
		}
		//endregion

		//region Special case for Any schema element type
		if(inputSchema instanceof Any)
		{
			//region Add named component of ASN.1 schema
			if(inputSchema.hasOwnProperty("name"))
				root[inputSchema.name] = inputData;
			//endregion

			return {
				verified: true,
				result: root
			};
		}
		//endregion

		//region Initial check
		if((root instanceof Object) === false)
		{
			return {
				verified: false,
				result: { error: "Wrong root object" }
			};
		}

		if((inputData instanceof Object) === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 data" }
			};
		}

		if((inputSchema instanceof Object) === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if(("idBlock" in inputSchema) === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}
		//endregion

		//region Comparing idBlock properties in ASN.1 data and ASN.1 schema
		//region Encode and decode ASN.1 schema idBlock
		/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>
		if(("fromBER" in inputSchema.idBlock) === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if(("toBER" in inputSchema.idBlock) === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		const encodedId = inputSchema.idBlock.toBER(false);
		if(encodedId.byteLength === 0)
		{
			return {
				verified: false,
				result: { error: "Error encoding idBlock for ASN.1 schema" }
			};
		}

		const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
		if(decodedOffset === (-1))
		{
			return {
				verified: false,
				result: { error: "Error decoding idBlock for ASN.1 schema" }
			};
		}
		//endregion

		//region tagClass
		if(inputSchema.idBlock.hasOwnProperty("tagClass") === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if(inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass)
		{
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region tagNumber
		if(inputSchema.idBlock.hasOwnProperty("tagNumber") === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if(inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber)
		{
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region isConstructed
		if(inputSchema.idBlock.hasOwnProperty("isConstructed") === false)
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if(inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed)
		{
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region isHexOnly
		if(("isHexOnly" in inputSchema.idBlock) === false) // Since 'isHexOnly' is an inhirited property
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		if(inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly)
		{
			return {
				verified: false,
				result: root
			};
		}
		//endregion
		//region valueHex
		if(inputSchema.idBlock.isHexOnly === true)
		{
			if(("valueHex" in inputSchema.idBlock) === false) // Since 'valueHex' is an inhirited property
			{
				return {
					verified: false,
					result: { error: "Wrong ASN.1 schema" }
				};
			}

			const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);
			const asn1View = new Uint8Array(inputData.idBlock.valueHex);

			if(schemaView.length !== asn1View.length)
			{
				return {
					verified: false,
					result: root
				};
			}

			for(let i = 0; i < schemaView.length; i++)
			{
				if(schemaView[i] !== asn1View[1])
				{
					return {
						verified: false,
						result: root
					};
				}
			}
		}
		//endregion
		//endregion

		//region Add named component of ASN.1 schema
		if(inputSchema.hasOwnProperty("name"))
		{
			inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
			if(inputSchema.name !== "")
				root[inputSchema.name] = inputData;
		}
		//endregion

		//region Getting next ASN.1 block for comparition
		if(inputSchema.idBlock.isConstructed === true)
		{
			let admission = 0;
			let result = { verified: false };

			let maxLength = inputSchema.valueBlock.value.length;

			if(maxLength > 0)
			{
				if(inputSchema.valueBlock.value[0] instanceof Repeated)
					maxLength = inputData.valueBlock.value.length;
			}

			//region Special case when constructive value has no elements
			if(maxLength === 0)
			{
				return {
					verified: true,
					result: root
				};
			}
			//endregion

			//region Special case when "inputData" has no values and "inputSchema" has all optional values
			if((inputData.valueBlock.value.length === 0) &&
				(inputSchema.valueBlock.value.length !== 0))
			{
				let _optional = true;

				for(let i = 0; i < inputSchema.valueBlock.value.length; i++)
					_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);

				if(_optional === true)
				{
					return {
						verified: true,
						result: root
					};
				}

				//region Delete early added name of block
				if(inputSchema.hasOwnProperty("name"))
				{
					inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
					if(inputSchema.name !== "")
						delete root[inputSchema.name];
				}
				//endregion

				root.error = "Inconsistent object length";

				return {
					verified: false,
					result: root
				};
			}
			//endregion

			for(let i = 0; i < maxLength; i++)
			{
				//region Special case when there is an "optional" element of ASN.1 schema at the end
				if((i - admission) >= inputData.valueBlock.value.length)
				{
					if(inputSchema.valueBlock.value[i].optional === false)
					{
						const _result = {
							verified: false,
							result: root
						};

						root.error = "Inconsistent length between ASN.1 data and schema";

						//region Delete early added name of block
						if(inputSchema.hasOwnProperty("name"))
						{
							inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
							if(inputSchema.name !== "")
							{
								delete root[inputSchema.name];
								_result.name = inputSchema.name;
							}
						}
						//endregion

						return _result;
					}
				}
				//endregion
				else
				{
					//region Special case for Repeated type of ASN.1 schema element
					if(inputSchema.valueBlock.value[0] instanceof Repeated)
					{
						result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
						if(result.verified === false)
						{
							if(inputSchema.valueBlock.value[0].optional === true)
								admission++;
							else
							{
								//region Delete early added name of block
								if(inputSchema.hasOwnProperty("name"))
								{
									inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
									if(inputSchema.name !== "")
										delete root[inputSchema.name];
								}
								//endregion

								return result;
							}
						}

						if(("name" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0))
						{
							let arrayRoot = {};

							if(("local" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local === true))
								arrayRoot = inputData;
							else
								arrayRoot = root;

							if(typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
								arrayRoot[inputSchema.valueBlock.value[0].name] = [];

							arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
						}
					}
					//endregion
					else
					{
						result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
						if(result.verified === false)
						{
							if(inputSchema.valueBlock.value[i].optional === true)
								admission++;
							else
							{
								//region Delete early added name of block
								if(inputSchema.hasOwnProperty("name"))
								{
									inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
									if(inputSchema.name !== "")
										delete root[inputSchema.name];
								}
								//endregion

								return result;
							}
						}
					}
				}
			}

			if(result.verified === false) // The situation may take place if last element is "optional" and verification failed
			{
				const _result = {
					verified: false,
					result: root
				};

				//region Delete early added name of block
				if(inputSchema.hasOwnProperty("name"))
				{
					inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
					if(inputSchema.name !== "")
					{
						delete root[inputSchema.name];
						_result.name = inputSchema.name;
					}
				}
				//endregion

				return _result;
			}

			return {
				verified: true,
				result: root
			};
		}
		//endregion
		//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)
		if(("primitiveSchema" in inputSchema) &&
			("valueHex" in inputData.valueBlock))
		{
			//region Decoding of raw ASN.1 data
			const asn1 = fromBER$1(inputData.valueBlock.valueHex);
			if(asn1.offset === (-1))
			{
				const _result = {
					verified: false,
					result: asn1.result
				};

				//region Delete early added name of block
				if(inputSchema.hasOwnProperty("name"))
				{
					inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
					if(inputSchema.name !== "")
					{
						delete root[inputSchema.name];
						_result.name = inputSchema.name;
					}
				}
				//endregion

				return _result;
			}
			//endregion

			return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
		}

		return {
			verified: true,
			result: root
		};
		//endregion
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class AlgorithmIdentifier$1
	{
		//**********************************************************************************
		/**
		 * Constructor for AlgorithmIdentifier class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc ObjectIdentifier for algorithm (string representation)
			 */
			this.algorithmId = getParametersValue$2(parameters, "algorithmId", AlgorithmIdentifier$1.defaultValues("algorithmId"));

			if("algorithmParams" in parameters)
				/**
				 * @type {Object}
				 * @desc Any algorithm parameters
				 */
				this.algorithmParams = getParametersValue$2(parameters, "algorithmParams", AlgorithmIdentifier$1.defaultValues("algorithmParams"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "algorithmId":
					return "";
				case "algorithmParams":
					return new Any();
				default:
					throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "algorithmId":
					return (memberValue === "");
				case "algorithmParams":
					return (memberValue instanceof Any);
				default:
					throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * AlgorithmIdentifier  ::=  Sequence  {
		 *    algorithm               OBJECT IDENTIFIER,
		 *    parameters              ANY DEFINED BY algorithm OPTIONAL  }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm
			 * @property {string} algorithmParams Any algorithm parameters
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				optional: (names.optional || false),
				value: [
					new ObjectIdentifier$2({ name: (names.algorithmIdentifier || "") }),
					new Any({ name: (names.algorithmParams || ""), optional: true })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"algorithm",
				"params"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				AlgorithmIdentifier$1.schema({
					names: {
						algorithmIdentifier: "algorithm",
						algorithmParams: "params"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");
			//endregion

			//region Get internal properties from parsed schema
			this.algorithmId = asn1.result.algorithm.valueBlock.toString();
			if("params" in asn1.result)
				this.algorithmParams = asn1.result.params;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			outputArray.push(new ObjectIdentifier$2({ value: this.algorithmId }));
			if(("algorithmParams" in this) && ((this.algorithmParams instanceof Any) === false))
				outputArray.push(this.algorithmParams);
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				algorithmId: this.algorithmId
			};

			if(("algorithmParams" in this) && ((this.algorithmParams instanceof Any) === false))
				object.algorithmParams = this.algorithmParams.toJSON();

			return object;
		}
		//**********************************************************************************
		/**
		 * Check that two "AlgorithmIdentifiers" are equal
		 * @param {AlgorithmIdentifier} algorithmIdentifier
		 * @returns {boolean}
		 */
		isEqual(algorithmIdentifier)
		{
			//region Check input type
			if((algorithmIdentifier instanceof AlgorithmIdentifier$1) === false)
				return false;
			//endregion

			//region Check "algorithm_id"
			if(this.algorithmId !== algorithmIdentifier.algorithmId)
				return false;
			//endregion

			//region Check "algorithm_params"
			if("algorithmParams" in this)
			{
				if("algorithmParams" in algorithmIdentifier)
					return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);

				return false;
			}

			if("algorithmParams" in algorithmIdentifier)
				return false;
			//endregion

			return true;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5480
	 */
	class ECPublicKey
	{
		//**********************************************************************************
		/**
		 * Constructor for ECCPublicKey class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {ArrayBuffer}
			 * @desc type
			 */
			this.x = getParametersValue$2(parameters, "x", ECPublicKey.defaultValues("x"));
			/**
			 * @type {ArrayBuffer}
			 * @desc values
			 */
			this.y = getParametersValue$2(parameters, "y", ECPublicKey.defaultValues("y"));
			/**
			 * @type {string}
			 * @desc namedCurve
			 */
			this.namedCurve = getParametersValue$2(parameters, "namedCurve", ECPublicKey.defaultValues("namedCurve"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			//region If input argument array contains "json" for this object
			if("json" in parameters)
				this.fromJSON(parameters.json);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "x":
				case "y":
					return new ArrayBuffer(0);
				case "namedCurve":
					return "";
				default:
					throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "x":
				case "y":
					return (isEqualBuffer$2(memberValue, ECPublicKey.defaultValues(memberName)));
				case "namedCurve":
					return (memberValue === "");
				default:
					throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			return new RawData();
		}
		//**********************************************************************************
		/**
		 * Convert ArrayBuffer into current class
		 * @param {!ArrayBuffer} schema Special case: schema is an ArrayBuffer
		 */
		fromSchema(schema)
		{
			//region Check the schema is valid
			if((schema instanceof ArrayBuffer) === false)
				throw new Error("Object's schema was not verified against input data for ECPublicKey");

			const view = new Uint8Array(schema);
			if(view[0] !== 0x04)
				throw new Error("Object's schema was not verified against input data for ECPublicKey");
			//endregion

			//region Get internal properties from parsed schema
			let coordinateLength;

			switch(this.namedCurve)
			{
				case "1.2.840.10045.3.1.7": // P-256
					coordinateLength = 32;
					break;
				case "1.3.132.0.10": //K-256
					coordinateLength = 32;
					break;
				case "1.3.132.0.34": // P-384
					coordinateLength = 48;
					break;
				case "1.3.132.0.35": // P-521
					coordinateLength = 66;
					break;
				default:
					throw new Error(`Incorrect curve OID: ${this.namedCurve}`);
			}

			if(schema.byteLength !== (coordinateLength * 2 + 1))
				throw new Error("Object's schema was not verified against input data for ECPublicKey");
			
			this.x = schema.slice(1, coordinateLength + 1);
			this.y = schema.slice(1 + coordinateLength, coordinateLength * 2 + 1);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			return new RawData({ data: utilConcatBuf$2(
				(new Uint8Array([0x04])).buffer,
				this.x,
				this.y
			)
			});
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			let crvName = "";

			switch(this.namedCurve)
			{
				case "1.2.840.10045.3.1.7": // P-256
					crvName = "P-256";
					break;
				case "1.3.132.0.34": // P-384
					crvName = "P-384";
					break;
				case "1.3.132.0.35": // P-521
					crvName = "P-521";
					break;
				case "1.3.132.0.10": //K-256
					crvName = "K-256";
					break;
				default:
			}

			return {
				crv: crvName,
				x: toBase64$1(arrayBufferToString$1(this.x), true, true, false),
				y: toBase64$1(arrayBufferToString$1(this.y), true, true, false)
			};
		}
		//**********************************************************************************
		/**
		 * Convert JSON value into current object
		 * @param {Object} json
		 */
		fromJSON(json)
		{
			let coodinateLength = 0;

			if("crv" in json)
			{
				switch(json.crv.toUpperCase())
				{
						case "P-256":
						this.namedCurve = "1.2.840.10045.3.1.7";
						coodinateLength = 32;
						break;
					case "K-256":
						this.namedCurve = "1.3.132.0.10";
						coodinateLength = 32;
						break;
					case "P-384":
						this.namedCurve = "1.3.132.0.34";
						coodinateLength = 48;
						break;
					case "P-521":
						this.namedCurve = "1.3.132.0.35";
						coodinateLength = 66;
					default:
				}
			}
			else
				throw new Error("Absent mandatory parameter \"crv\"");

			if("x" in json)
			{
				const convertBuffer = stringToArrayBuffer$2(fromBase64$1(json.x, true));
				
				if(convertBuffer.byteLength < coodinateLength)
				{
					this.x = new ArrayBuffer(coodinateLength);
					const view = new Uint8Array(this.x);
					const convertBufferView = new Uint8Array(convertBuffer);
					view.set(convertBufferView, 1);
				}
				else
					this.x = convertBuffer.slice(0, coodinateLength);
			}
			else
				throw new Error("Absent mandatory parameter \"x\"");

			if("y" in json)
			{
				const convertBuffer = stringToArrayBuffer$2(fromBase64$1(json.y, true));
				
				if(convertBuffer.byteLength < coodinateLength)
				{
					this.y = new ArrayBuffer(coodinateLength);
					const view = new Uint8Array(this.y);
					const convertBufferView = new Uint8Array(convertBuffer);
					view.set(convertBufferView, 1);
				}
				else
					this.y = convertBuffer.slice(0, coodinateLength);
			}
			else
				throw new Error("Absent mandatory parameter \"y\"");
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC3447
	 */
	class RSAPublicKey
	{
		//**********************************************************************************
		/**
		 * Constructor for RSAPublicKey class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 * @property {Integer} [modulus]
		 * @property {Integer} [publicExponent]
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Integer}
			 * @desc Modulus part of RSA public key
			 */
			this.modulus = getParametersValue$2(parameters, "modulus", RSAPublicKey.defaultValues("modulus"));
			/**
			 * @type {Integer}
			 * @desc Public exponent of RSA public key
			 */
			this.publicExponent = getParametersValue$2(parameters, "publicExponent", RSAPublicKey.defaultValues("publicExponent"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			//region If input argument array contains "json" for this object
			if("json" in parameters)
				this.fromJSON(parameters.json);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "modulus":
					return new Integer$1();
				case "publicExponent":
					return new Integer$1();
				default:
					throw new Error(`Invalid member name for RSAPublicKey class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * RSAPublicKey ::= Sequence {
		 *    modulus           Integer,  -- n
		 *    publicExponent    Integer   -- e
		 * }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} utcTimeName Name for "utcTimeName" choice
			 * @property {string} generalTimeName Name for "generalTimeName" choice
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Integer$1({ name: (names.modulus || "") }),
					new Integer$1({ name: (names.publicExponent || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"modulus",
				"publicExponent"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				RSAPublicKey.schema({
					names: {
						modulus: "modulus",
						publicExponent: "publicExponent"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for RSAPublicKey");
			//endregion

			//region Get internal properties from parsed schema
			this.modulus = asn1.result.modulus.convertFromDER(256);
			this.publicExponent = asn1.result.publicExponent;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					this.modulus.convertToDER(),
					this.publicExponent
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				n: toBase64$1(arrayBufferToString$1(this.modulus.valueBlock.valueHex), true, true, true),
				e: toBase64$1(arrayBufferToString$1(this.publicExponent.valueBlock.valueHex), true, true, true)
			};
		}
		//**********************************************************************************
		/**
		 * Convert JSON value into current object
		 * @param {Object} json
		 */
		fromJSON(json)
		{
			if("n" in json)
			{
				const array = stringToArrayBuffer$2(fromBase64$1(json.n, true));
				this.modulus = new Integer$1({ valueHex: array.slice(0, Math.pow(2, nearestPowerOf2$1(array.byteLength))) });
			}
			else
				throw new Error("Absent mandatory parameter \"n\"");

			if("e" in json)
				this.publicExponent = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.e, true)).slice(0, 3) });
			else
				throw new Error("Absent mandatory parameter \"e\"");
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class PublicKeyInfo$1 
	{
		//**********************************************************************************
		/**
		 * Constructor for PublicKeyInfo class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc Algorithm identifier
			 */
			this.algorithm = getParametersValue$2(parameters, "algorithm", PublicKeyInfo$1.defaultValues("algorithm"));
			/**
			 * @type {BitString}
			 * @desc Subject public key value
			 */
			this.subjectPublicKey = getParametersValue$2(parameters, "subjectPublicKey", PublicKeyInfo$1.defaultValues("subjectPublicKey"));
			
			if("parsedKey" in parameters)
				/**
				 * @type {ECPublicKey|RSAPublicKey}
				 * @desc Parsed public key value
				 */
				this.parsedKey = getParametersValue$2(parameters, "parsedKey", PublicKeyInfo$1.defaultValues("parsedKey"));
			//endregion
			
			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			//region If input argument array contains "json" for this object
			if("json" in parameters)
				this.fromJSON(parameters.json);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "algorithm":
					return new AlgorithmIdentifier$1();
				case "subjectPublicKey":
					return new BitString$1();
				default:
					throw new Error(`Invalid member name for PublicKeyInfo class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * SubjectPublicKeyInfo  ::=  Sequence  {
		 *    algorithm            AlgorithmIdentifier,
		 *    subjectPublicKey     BIT STRING  }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [algorithm]
			 * @property {string} [subjectPublicKey]
			 */
			const names = getParametersValue$2(parameters, "names", {});
			
			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					AlgorithmIdentifier$1.schema(names.algorithm || {}),
					new BitString$1({ name: (names.subjectPublicKey || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"algorithm",
				"subjectPublicKey"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PublicKeyInfo$1.schema({
					names: {
						algorithm: {
							names: {
								blockName: "algorithm"
							}
						},
						subjectPublicKey: "subjectPublicKey"
					}
				})
			);
			
			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PublicKeyInfo");
			//endregion
			
			//region Get internal properties from parsed schema
			this.algorithm = new AlgorithmIdentifier$1({ schema: asn1.result.algorithm });
			this.subjectPublicKey = asn1.result.subjectPublicKey;
			
			switch(this.algorithm.algorithmId)
			{
				case "1.2.840.10045.2.1": // ECDSA
					if("algorithmParams" in this.algorithm)
					{
						if(this.algorithm.algorithmParams instanceof ObjectIdentifier$2)
						{
							try
							{
								this.parsedKey = new ECPublicKey({
									namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
									schema: this.subjectPublicKey.valueBlock.valueHex
								});
							}
							catch(ex){} // Could be a problems during recognision of internal public key data here. Let's ignore them.
						}
					}
					break;
				case "1.2.840.113549.1.1.1": // RSA
					{
						const publicKeyASN1 = fromBER$1(this.subjectPublicKey.valueBlock.valueHex);
						if(publicKeyASN1.offset !== (-1))
						{
							try
							{
								this.parsedKey = new RSAPublicKey({ schema: publicKeyASN1.result });
							}
							catch(ex){} // Could be a problems during recognision of internal public key data here. Let's ignore them.
						}
					}
					break;
				default:
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					this.algorithm.toSchema(),
					this.subjectPublicKey
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			//region Return common value in case we do not have enough info fo making JWK
			if(("parsedKey" in this) === false)
			{
				return {
					algorithm: this.algorithm.toJSON(),
					subjectPublicKey: this.subjectPublicKey.toJSON()
				};
			}
			//endregion
			
			//region Making JWK
			const jwk = {};
			
			switch(this.algorithm.algorithmId)
			{
				case "1.2.840.10045.2.1": // ECDSA
					jwk.kty = "EC";
					break;
				case "1.2.840.113549.1.1.1": // RSA
					jwk.kty = "RSA";
					break;
				default:
			}
			
			const publicKeyJWK = this.parsedKey.toJSON();
			
			for(const key of Object.keys(publicKeyJWK))
				jwk[key] = publicKeyJWK[key];
			
			return jwk;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert JSON value into current object
		 * @param {Object} json
		 */
		fromJSON(json)
		{
			if("kty" in json)
			{
				switch(json.kty.toUpperCase())
				{
					case "EC":
						this.parsedKey = new ECPublicKey({ json });
						
						this.algorithm = new AlgorithmIdentifier$1({
							algorithmId: "1.2.840.10045.2.1",
							algorithmParams: new ObjectIdentifier$2({ value: this.parsedKey.namedCurve })
						});
						break;
					case "RSA":
						this.parsedKey = new RSAPublicKey({ json });
						
						this.algorithm = new AlgorithmIdentifier$1({
							algorithmId: "1.2.840.113549.1.1.1",
							algorithmParams: new Null$1()
						});
						break;
					default:
						throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
				}
				
				this.subjectPublicKey = new BitString$1({ valueHex: this.parsedKey.toSchema().toBER(false) });
			}
		}
		//**********************************************************************************
		importKey(publicKey)
		{
			//region Initial variables
			let sequence = Promise.resolve();
			const _this = this;
			//endregion
			
			//region Initial check
			if(typeof publicKey === "undefined")
				return Promise.reject("Need to provide publicKey input parameter");
			//endregion
			
			//region Get a "crypto" extension
			const crypto = getCrypto();
			if(typeof crypto === "undefined")
				return Promise.reject("Unable to create WebCrypto object");
			//endregion
			
			//region Export public key
			sequence = sequence.then(() =>
				crypto.exportKey("spki", publicKey));
			//endregion
			
			//region Initialize internal variables by parsing exported value
			sequence = sequence.then(
				/**
				 * @param {ArrayBuffer} exportedKey
				 */
				exportedKey =>
				{
					const asn1 = fromBER$1(exportedKey);
					try
					{
						_this.fromSchema(asn1.result);
					}
					catch(exception)
					{
						return Promise.reject("Error during initializing object from schema");
					}
					
					return undefined;
				},
				error => Promise.reject(`Error during exporting public key: ${error}`)
			);
			//endregion
			
			return sequence;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC2986
	 */
	class Attribute {
		//**********************************************************************************
		/**
		 * Constructor for Attribute class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc ObjectIdentifier for attribute (string representation)
			 */
			this.type = getParametersValue$2(parameters, "type", Attribute.defaultValues("type"));
			/**
			 * @type {Array}
			 * @desc Any attribute values
			 */
			this.values = getParametersValue$2(parameters, "values", Attribute.defaultValues("values"));
			//endregion
			
			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "type":
					return "";
				case "values":
					return [];
				default:
					throw new Error(`Invalid member name for Attribute class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "type":
					return (memberValue === "");
				case "values":
					return (memberValue.length === 0);
				default:
					throw new Error(`Invalid member name for Attribute class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
		 *    type   ATTRIBUTE.&id({IOSet}),
		 *    values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
		 * }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [type]
			 * @property {string} [setName]
			 * @property {string} [values]
			 */
			const names = getParametersValue$2(parameters, "names", {});
			
			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.type || "") }),
					new Set$1({
						name: (names.setName || ""),
						value: [
							new Repeated({
								name: (names.values || ""),
								value: new Any()
							})
						]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"type",
				"values"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				Attribute.schema({
					names: {
						type: "type",
						values: "values"
					}
				})
			);
			
			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for Attribute");
			//endregion
			
			//region Get internal properties from parsed schema
			this.type = asn1.result.type.valueBlock.toString();
			this.values = asn1.result.values;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					new ObjectIdentifier$2({ value: this.type }),
					new Set$1({
						value: this.values
					})
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				type: this.type,
				values: Array.from(this.values, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5915
	 */
	class ECPrivateKey
	{
		//**********************************************************************************
		/**
		 * Constructor for ECPrivateKey class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {number}
			 * @desc version
			 */
			this.version = getParametersValue$2(parameters, "version", ECPrivateKey.defaultValues("version"));
			/**
			 * @type {OctetString}
			 * @desc privateKey
			 */
			this.privateKey = getParametersValue$2(parameters, "privateKey", ECPrivateKey.defaultValues("privateKey"));

			if("namedCurve" in parameters)
				/**
				 * @type {string}
				 * @desc namedCurve
				 */
				this.namedCurve = getParametersValue$2(parameters, "namedCurve", ECPrivateKey.defaultValues("namedCurve"));

			if("publicKey" in parameters)
				/**
				 * @type {ECPublicKey}
				 * @desc publicKey
				 */
				this.publicKey = getParametersValue$2(parameters, "publicKey", ECPrivateKey.defaultValues("publicKey"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			//region If input argument array contains "json" for this object
			if("json" in parameters)
				this.fromJSON(parameters.json);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "version":
					return 1;
				case "privateKey":
					return new OctetString$1();
				case "namedCurve":
					return "";
				case "publicKey":
					return new ECPublicKey();
				default:
					throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "version":
					return (memberValue === ECPrivateKey.defaultValues(memberName));
				case "privateKey":
					return (memberValue.isEqual(ECPrivateKey.defaultValues(memberName)));
				case "namedCurve":
					return (memberValue === "");
				case "publicKey":
					return ((ECPublicKey.compareWithDefault("namedCurve", memberValue.namedCurve)) &&
							(ECPublicKey.compareWithDefault("x", memberValue.x)) &&
							(ECPublicKey.compareWithDefault("y", memberValue.y)));
				default:
					throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * ECPrivateKey ::= SEQUENCE {
		 * version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
		 * privateKey     OCTET STRING,
		 * parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
		 * publicKey  [1] BIT STRING OPTIONAL
		 * }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [version]
			 * @property {string} [privateKey]
			 * @property {string} [namedCurve]
			 * @property {string} [publicKey]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Integer$1({ name: (names.version || "") }),
					new OctetString$1({ name: (names.privateKey || "") }),
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: [
							new ObjectIdentifier$2({ name: (names.namedCurve || "") })
						]
					}),
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						},
						value: [
							new BitString$1({ name: (names.publicKey || "") })
						]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"version",
				"privateKey",
				"namedCurve",
				"publicKey"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				ECPrivateKey.schema({
					names: {
						version: "version",
						privateKey: "privateKey",
						namedCurve: "namedCurve",
						publicKey: "publicKey"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for ECPrivateKey");
			//endregion

			//region Get internal properties from parsed schema
			this.version = asn1.result.version.valueBlock.valueDec;
			this.privateKey = asn1.result.privateKey;

			if("namedCurve" in asn1.result)
				this.namedCurve = asn1.result.namedCurve.valueBlock.toString();

			if("publicKey" in asn1.result)
			{
				const publicKeyData = { schema: asn1.result.publicKey.valueBlock.valueHex };
				if("namedCurve" in this)
					publicKeyData.namedCurve = this.namedCurve;

				this.publicKey = new ECPublicKey(publicKeyData);
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			const outputArray = [
				new Integer$1({ value: this.version }),
				this.privateKey
			];

			if("namedCurve" in this)
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new ObjectIdentifier$2({ value: this.namedCurve })
					]
				}));
			}

			if("publicKey" in this)
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new BitString$1({ valueHex: this.publicKey.toSchema().toBER(false) })
					]
				}));
			}

			return new Sequence$1({
				value: outputArray
			});
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			if((("namedCurve" in this) === false) || (ECPrivateKey.compareWithDefault("namedCurve", this.namedCurve)))
				throw new Error("Not enough information for making JSON: absent \"namedCurve\" value");

			let crvName = "";

			switch(this.namedCurve)
			{
				case "1.2.840.10045.3.1.7": // P-256
					crvName = "P-256";
					break;
				case "1.3.132.0.34": // P-384
					crvName = "P-384";
					break;
				case "1.3.132.0.35": // P-521
					crvName = "P-521";
					break;
				case "1.3.132.0.10": //K-256
					crvName = "K-256";
				default:
			}

			const privateKeyJSON = {
				crv: crvName,
				d: toBase64$1(arrayBufferToString$1(this.privateKey.valueBlock.valueHex), true, true, false)
			};

			if("publicKey" in this)
			{
				const publicKeyJSON = this.publicKey.toJSON();

				privateKeyJSON.x = publicKeyJSON.x;
				privateKeyJSON.y = publicKeyJSON.y;
			}

			return privateKeyJSON;
		}
		//**********************************************************************************
		/**
		 * Convert JSON value into current object
		 * @param {Object} json
		 */
		fromJSON(json)
		{
			let coodinateLength = 0;

			if("crv" in json)
			{
				switch(json.crv.toUpperCase())
				{
					case "P-256":
						this.namedCurve = "1.2.840.10045.3.1.7";
						coodinateLength = 32;
						break;
					case "K-256":
						this.namedCurve = "1.3.132.0.10";
						coodinateLength = 32;
						break;
					case "P-384":
						this.namedCurve = "1.3.132.0.34";
						coodinateLength = 48;
						break;
					case "P-521":
						this.namedCurve = "1.3.132.0.35";
						coodinateLength = 66;
						break;
					default:
				}
			}
			else
				throw new Error("Absent mandatory parameter \"crv\"");

			if("d" in json)
			{
				const convertBuffer = stringToArrayBuffer$2(fromBase64$1(json.d, true));
				
				if(convertBuffer.byteLength < coodinateLength)
				{
					const buffer = new ArrayBuffer(coodinateLength);
					const view = new Uint8Array(buffer);
					const convertBufferView = new Uint8Array(convertBuffer);
					view.set(convertBufferView, 1);
					
					this.privateKey = new OctetString$1({ valueHex: buffer });
				}
				else
					this.privateKey = new OctetString$1({ valueHex: convertBuffer.slice(0, coodinateLength) });
			}
			else
				throw new Error("Absent mandatory parameter \"d\"");

			if(("x" in json) && ("y" in json))
				this.publicKey = new ECPublicKey({ json });
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC3447
	 */
	class OtherPrimeInfo
	{
		//**********************************************************************************
		/**
		 * Constructor for OtherPrimeInfo class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Integer}
			 * @desc prime
			 */
			this.prime = getParametersValue$2(parameters, "prime", OtherPrimeInfo.defaultValues("prime"));
			/**
			 * @type {Integer}
			 * @desc exponent
			 */
			this.exponent = getParametersValue$2(parameters, "exponent", OtherPrimeInfo.defaultValues("exponent"));
			/**
			 * @type {Integer}
			 * @desc coefficient
			 */
			this.coefficient = getParametersValue$2(parameters, "coefficient", OtherPrimeInfo.defaultValues("coefficient"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			//region If input argument array contains "json" for this object
			if("json" in parameters)
				this.fromJSON(parameters.json);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "prime":
					return new Integer$1();
				case "exponent":
					return new Integer$1();
				case "coefficient":
					return new Integer$1();
				default:
					throw new Error(`Invalid member name for OtherPrimeInfo class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * OtherPrimeInfo ::= Sequence {
		 *    prime             Integer,  -- ri
		 *    exponent          Integer,  -- di
		 *    coefficient       Integer   -- ti
		 * }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{

			/**
			 * @type {Object}
			 * @property {string} prime
			 * @property {string} exponent
			 * @property {string} coefficient
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Integer$1({ name: (names.prime || "") }),
					new Integer$1({ name: (names.exponent || "") }),
					new Integer$1({ name: (names.coefficient || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"prime",
				"exponent",
				"coefficient"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				OtherPrimeInfo.schema({
					names: {
						prime: "prime",
						exponent: "exponent",
						coefficient: "coefficient"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");
			//endregion

			//region Get internal properties from parsed schema
			this.prime = asn1.result.prime.convertFromDER();
			this.exponent = asn1.result.exponent.convertFromDER();
			this.coefficient = asn1.result.coefficient.convertFromDER();
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					this.prime.convertToDER(),
					this.exponent.convertToDER(),
					this.coefficient.convertToDER()
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				r: toBase64$1(arrayBufferToString$1(this.prime.valueBlock.valueHex), true, true),
				d: toBase64$1(arrayBufferToString$1(this.exponent.valueBlock.valueHex), true, true),
				t: toBase64$1(arrayBufferToString$1(this.coefficient.valueBlock.valueHex), true, true)
			};
		}
		//**********************************************************************************
		/**
		 * Convert JSON value into current object
		 * @param {Object} json
		 */
		fromJSON(json)
		{
			if("r" in json)
				this.prime = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.r, true)) });
			else
				throw new Error("Absent mandatory parameter \"r\"");

			if("d" in json)
				this.exponent = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.d, true)) });
			else
				throw new Error("Absent mandatory parameter \"d\"");

			if("t" in json)
				this.coefficient = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.t, true)) });
			else
				throw new Error("Absent mandatory parameter \"t\"");
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC3447
	 */
	class RSAPrivateKey
	{
		//**********************************************************************************
		/**
		 * Constructor for RSAPrivateKey class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {number}
			 * @desc version
			 */
			this.version = getParametersValue$2(parameters, "version", RSAPrivateKey.defaultValues("version"));
			/**
			 * @type {Integer}
			 * @desc modulus
			 */
			this.modulus = getParametersValue$2(parameters, "modulus", RSAPrivateKey.defaultValues("modulus"));
			/**
			 * @type {Integer}
			 * @desc publicExponent
			 */
			this.publicExponent = getParametersValue$2(parameters, "publicExponent", RSAPrivateKey.defaultValues("publicExponent"));
			/**
			 * @type {Integer}
			 * @desc privateExponent
			 */
			this.privateExponent = getParametersValue$2(parameters, "privateExponent", RSAPrivateKey.defaultValues("privateExponent"));
			/**
			 * @type {Integer}
			 * @desc prime1
			 */
			this.prime1 = getParametersValue$2(parameters, "prime1", RSAPrivateKey.defaultValues("prime1"));
			/**
			 * @type {Integer}
			 * @desc prime2
			 */
			this.prime2 = getParametersValue$2(parameters, "prime2", RSAPrivateKey.defaultValues("prime2"));
			/**
			 * @type {Integer}
			 * @desc exponent1
			 */
			this.exponent1 = getParametersValue$2(parameters, "exponent1", RSAPrivateKey.defaultValues("exponent1"));
			/**
			 * @type {Integer}
			 * @desc exponent2
			 */
			this.exponent2 = getParametersValue$2(parameters, "exponent2", RSAPrivateKey.defaultValues("exponent2"));
			/**
			 * @type {Integer}
			 * @desc coefficient
			 */
			this.coefficient = getParametersValue$2(parameters, "coefficient", RSAPrivateKey.defaultValues("coefficient"));

			if("otherPrimeInfos" in parameters)
				/**
				 * @type {Array.<OtherPrimeInfo>}
				 * @desc otherPrimeInfos
				 */
				this.otherPrimeInfos = getParametersValue$2(parameters, "otherPrimeInfos", RSAPrivateKey.defaultValues("otherPrimeInfos"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			//region If input argument array contains "json" for this object
			if("json" in parameters)
				this.fromJSON(parameters.json);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "version":
					return 0;
				case "modulus":
					return new Integer$1();
				case "publicExponent":
					return new Integer$1();
				case "privateExponent":
					return new Integer$1();
				case "prime1":
					return new Integer$1();
				case "prime2":
					return new Integer$1();
				case "exponent1":
					return new Integer$1();
				case "exponent2":
					return new Integer$1();
				case "coefficient":
					return new Integer$1();
				case "otherPrimeInfos":
					return [];
				default:
					throw new Error(`Invalid member name for RSAPrivateKey class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * RSAPrivateKey ::= Sequence {
		 *    version           Version,
		 *    modulus           Integer,  -- n
		 *    publicExponent    Integer,  -- e
		 *    privateExponent   Integer,  -- d
		 *    prime1            Integer,  -- p
		 *    prime2            Integer,  -- q
		 *    exponent1         Integer,  -- d mod (p-1)
		 *    exponent2         Integer,  -- d mod (q-1)
		 *    coefficient       Integer,  -- (inverse of q) mod p
		 *    otherPrimeInfos   OtherPrimeInfos OPTIONAL
		 * }
		 *
		 * OtherPrimeInfos ::= Sequence SIZE(1..MAX) OF OtherPrimeInfo
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [version]
			 * @property {string} [modulus]
			 * @property {string} [publicExponent]
			 * @property {string} [privateExponent]
			 * @property {string} [prime1]
			 * @property {string} [prime2]
			 * @property {string} [exponent1]
			 * @property {string} [exponent2]
			 * @property {string} [coefficient]
			 * @property {string} [otherPrimeInfosName]
			 * @property {Object} [otherPrimeInfo]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Integer$1({ name: (names.version || "") }),
					new Integer$1({ name: (names.modulus || "") }),
					new Integer$1({ name: (names.publicExponent || "") }),
					new Integer$1({ name: (names.privateExponent || "") }),
					new Integer$1({ name: (names.prime1 || "") }),
					new Integer$1({ name: (names.prime2 || "") }),
					new Integer$1({ name: (names.exponent1 || "") }),
					new Integer$1({ name: (names.exponent2 || "") }),
					new Integer$1({ name: (names.coefficient || "") }),
					new Sequence$1({
						optional: true,
						value: [
							new Repeated({
								name: (names.otherPrimeInfosName || ""),
								value: OtherPrimeInfo.schema(names.otherPrimeInfo || {})
							})
						]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"version",
				"modulus",
				"publicExponent",
				"privateExponent",
				"prime1",
				"prime2",
				"exponent1",
				"exponent2",
				"coefficient",
				"otherPrimeInfos"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				RSAPrivateKey.schema({
					names: {
						version: "version",
						modulus: "modulus",
						publicExponent: "publicExponent",
						privateExponent: "privateExponent",
						prime1: "prime1",
						prime2: "prime2",
						exponent1: "exponent1",
						exponent2: "exponent2",
						coefficient: "coefficient",
						otherPrimeInfo: {
							names: {
								blockName: "otherPrimeInfos"
							}
						}
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for RSAPrivateKey");
			//endregion

			//region Get internal properties from parsed schema
			this.version = asn1.result.version.valueBlock.valueDec;
			this.modulus = asn1.result.modulus.convertFromDER(256);
			this.publicExponent = asn1.result.publicExponent;
			this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
			this.prime1 = asn1.result.prime1.convertFromDER(128);
			this.prime2 = asn1.result.prime2.convertFromDER(128);
			this.exponent1 = asn1.result.exponent1.convertFromDER(128);
			this.exponent2 = asn1.result.exponent2.convertFromDER(128);
			this.coefficient = asn1.result.coefficient.convertFromDER(128);

			if("otherPrimeInfos" in asn1.result)
				this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, element => new OtherPrimeInfo({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			outputArray.push(new Integer$1({ value: this.version }));
			outputArray.push(this.modulus.convertToDER());
			outputArray.push(this.publicExponent);
			outputArray.push(this.privateExponent.convertToDER());
			outputArray.push(this.prime1.convertToDER());
			outputArray.push(this.prime2.convertToDER());
			outputArray.push(this.exponent1.convertToDER());
			outputArray.push(this.exponent2.convertToDER());
			outputArray.push(this.coefficient.convertToDER());
			
			if("otherPrimeInfos" in this)
			{
				outputArray.push(new Sequence$1({
					value: Array.from(this.otherPrimeInfos, element => element.toSchema())
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const jwk = {
				n: toBase64$1(arrayBufferToString$1(this.modulus.valueBlock.valueHex), true, true, true),
				e: toBase64$1(arrayBufferToString$1(this.publicExponent.valueBlock.valueHex), true, true, true),
				d: toBase64$1(arrayBufferToString$1(this.privateExponent.valueBlock.valueHex), true, true, true),
				p: toBase64$1(arrayBufferToString$1(this.prime1.valueBlock.valueHex), true, true, true),
				q: toBase64$1(arrayBufferToString$1(this.prime2.valueBlock.valueHex), true, true, true),
				dp: toBase64$1(arrayBufferToString$1(this.exponent1.valueBlock.valueHex), true, true, true),
				dq: toBase64$1(arrayBufferToString$1(this.exponent2.valueBlock.valueHex), true, true, true),
				qi: toBase64$1(arrayBufferToString$1(this.coefficient.valueBlock.valueHex), true, true, true)
			};

			if("otherPrimeInfos" in this)
				jwk.oth = Array.from(this.otherPrimeInfos, element => element.toJSON());

			return jwk;
		}
		//**********************************************************************************
		/**
		 * Convert JSON value into current object
		 * @param {Object} json
		 */
		fromJSON(json)
		{
			if("n" in json)
				this.modulus = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.n, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"n\"");

			if("e" in json)
				this.publicExponent = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.e, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"e\"");

			if("d" in json)
				this.privateExponent = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.d, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"d\"");

			if("p" in json)
				this.prime1 = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.p, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"p\"");

			if("q" in json)
				this.prime2 = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.q, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"q\"");

			if("dp" in json)
				this.exponent1 = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.dp, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"dp\"");

			if("dq" in json)
				this.exponent2 = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.dq, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"dq\"");

			if("qi" in json)
				this.coefficient = new Integer$1({ valueHex: stringToArrayBuffer$2(fromBase64$1(json.qi, true, true)) });
			else
				throw new Error("Absent mandatory parameter \"qi\"");

			if("oth" in json)
				this.otherPrimeInfos = Array.from(json.oth, element => new OtherPrimeInfo({ json: element }));
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5208
	 */
	class PrivateKeyInfo$1
	{
		//**********************************************************************************
		/**
		 * Constructor for PrivateKeyInfo class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {number}
			 * @desc version
			 */
			this.version = getParametersValue$2(parameters, "version", PrivateKeyInfo$1.defaultValues("version"));
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc privateKeyAlgorithm
			 */
			this.privateKeyAlgorithm = getParametersValue$2(parameters, "privateKeyAlgorithm", PrivateKeyInfo$1.defaultValues("privateKeyAlgorithm"));
			/**
			 * @type {OctetString}
			 * @desc privateKey
			 */
			this.privateKey = getParametersValue$2(parameters, "privateKey", PrivateKeyInfo$1.defaultValues("privateKey"));

			if("attributes" in parameters)
				/**
				 * @type {Array.<Attribute>}
				 * @desc attributes
				 */
				this.attributes = getParametersValue$2(parameters, "attributes", PrivateKeyInfo$1.defaultValues("attributes"));

			if("parsedKey" in parameters)
				/**
				 * @type {ECPrivateKey|RSAPrivateKey}
				 * @desc Parsed public key value
				 */
				this.parsedKey = getParametersValue$2(parameters, "parsedKey", PrivateKeyInfo$1.defaultValues("parsedKey"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			//region If input argument array contains "json" for this object
			if("json" in parameters)
				this.fromJSON(parameters.json);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "version":
					return 0;
				case "privateKeyAlgorithm":
					return new AlgorithmIdentifier$1();
				case "privateKey":
					return new OctetString$1();
				case "attributes":
					return [];
				case "parsedKey":
					return {};
				default:
					throw new Error(`Invalid member name for PrivateKeyInfo class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PrivateKeyInfo ::= SEQUENCE {
		 *    version Version,
		 *    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
		 *    privateKey PrivateKey,
		 *    attributes [0] Attributes OPTIONAL }
		 *
		 * Version ::= INTEGER {v1(0)} (v1,...)
		 *
		 * PrivateKey ::= OCTET STRING
		 *
		 * Attributes ::= SET OF Attribute
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [version]
			 * @property {string} [privateKeyAlgorithm]
			 * @property {string} [privateKey]
			 * @property {string} [attributes]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Integer$1({ name: (names.version || "") }),
					AlgorithmIdentifier$1.schema(names.privateKeyAlgorithm || {}),
					new OctetString$1({ name: (names.privateKey || "") }),
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: [
							new Repeated({
								name: (names.attributes || ""),
								value: Attribute.schema()
							})
						]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"version",
				"privateKeyAlgorithm",
				"privateKey",
				"attributes"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PrivateKeyInfo$1.schema({
					names: {
						version: "version",
						privateKeyAlgorithm: {
							names: {
								blockName: "privateKeyAlgorithm"
							}
						},
						privateKey: "privateKey",
						attributes: "attributes"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");
			//endregion

			//region Get internal properties from parsed schema
			this.version = asn1.result.version.valueBlock.valueDec;
			this.privateKeyAlgorithm = new AlgorithmIdentifier$1({ schema: asn1.result.privateKeyAlgorithm });
			this.privateKey = asn1.result.privateKey;

			if("attributes" in asn1.result)
				this.attributes = Array.from(asn1.result.attributes, element => new Attribute({ schema: element }));

			switch(this.privateKeyAlgorithm.algorithmId)
			{
				case "1.2.840.113549.1.1.1": // RSA
					{
						const privateKeyASN1 = fromBER$1(this.privateKey.valueBlock.valueHex);
						if(privateKeyASN1.offset !== (-1))
							this.parsedKey = new RSAPrivateKey({ schema: privateKeyASN1.result });
					}
					break;
				case "1.2.840.10045.2.1": // ECDSA
					if("algorithmParams" in this.privateKeyAlgorithm)
					{
						if(this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier$2)
						{
							const privateKeyASN1 = fromBER$1(this.privateKey.valueBlock.valueHex);
							if(privateKeyASN1.offset !== (-1))
							{
								this.parsedKey = new ECPrivateKey({
									namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
									schema: privateKeyASN1.result
								});
							}
						}
					}
					break;
				default:
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [
				new Integer$1({ value: this.version }),
				this.privateKeyAlgorithm.toSchema(),
				this.privateKey
			];

			if("attributes" in this)
			{
				outputArray.push(new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: Array.from(this.attributes, element => element.toSchema())
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			//region Return common value in case we do not have enough info fo making JWK
			if(("parsedKey" in this) === false)
			{
				const object = {
					version: this.version,
					privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
					privateKey: this.privateKey.toJSON()
				};

				if("attributes" in this)
					object.attributes = Array.from(this.attributes, element => element.toJSON());

				return object;
			}
			//endregion

			//region Making JWK
			const jwk = {};

			switch(this.privateKeyAlgorithm.algorithmId)
			{
				case "1.2.840.10045.2.1": // ECDSA
					jwk.kty = "EC";
					break;
				case "1.2.840.113549.1.1.1": // RSA
					jwk.kty = "RSA";
					break;
				default:
			}

			const publicKeyJWK = this.parsedKey.toJSON();

			for(const key of Object.keys(publicKeyJWK))
				jwk[key] = publicKeyJWK[key];

			return jwk;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert JSON value into current object
		 * @param {Object} json
		 */
		fromJSON(json)
		{
			if("kty" in json)
			{
				switch(json.kty.toUpperCase())
				{
					case "EC":
						this.parsedKey = new ECPrivateKey({ json });

						this.privateKeyAlgorithm = new AlgorithmIdentifier$1({
							algorithmId: "1.2.840.10045.2.1",
							algorithmParams: new ObjectIdentifier$2({ value: this.parsedKey.namedCurve })
						});
						break;
					case "RSA":
						this.parsedKey = new RSAPrivateKey({ json });

						this.privateKeyAlgorithm = new AlgorithmIdentifier$1({
							algorithmId: "1.2.840.113549.1.1.1",
							algorithmParams: new Null$1()
						});
						break;
					default:
						throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
				}

				this.privateKey = new OctetString$1({ valueHex: this.parsedKey.toSchema().toBER(false) });
			}
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5652
	 */
	class EncryptedContentInfo
	{
		//**********************************************************************************
		/**
		 * Constructor for EncryptedContentInfo class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc contentType
			 */
			this.contentType = getParametersValue$2(parameters, "contentType", EncryptedContentInfo.defaultValues("contentType"));
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc contentEncryptionAlgorithm
			 */
			this.contentEncryptionAlgorithm = getParametersValue$2(parameters, "contentEncryptionAlgorithm", EncryptedContentInfo.defaultValues("contentEncryptionAlgorithm"));

			if("encryptedContent" in parameters)
			{
				/**
				 * @type {OctetString}
				 * @desc encryptedContent (!!!) could be contructive or primitive value (!!!)
				 */
				this.encryptedContent = parameters.encryptedContent;
				
				if((this.encryptedContent.idBlock.tagClass === 1) &&
					(this.encryptedContent.idBlock.tagNumber === 4))
				{
					//region Divide OCTETSTRING value down to small pieces
					if(this.encryptedContent.idBlock.isConstructed === false)
					{
						const constrString = new OctetString$1({
							idBlock: { isConstructed: true },
							isConstructed: true
						});
						
						let offset = 0;
						let length = this.encryptedContent.valueBlock.valueHex.byteLength;
						
						while(length > 0)
						{
							const pieceView = new Uint8Array(this.encryptedContent.valueBlock.valueHex, offset, ((offset + 1024) > this.encryptedContent.valueBlock.valueHex.byteLength) ? (this.encryptedContent.valueBlock.valueHex.byteLength - offset) : 1024);
							const _array = new ArrayBuffer(pieceView.length);
							const _view = new Uint8Array(_array);
							
							for(let i = 0; i < _view.length; i++)
								_view[i] = pieceView[i];
							
							constrString.valueBlock.value.push(new OctetString$1({ valueHex: _array }));
							
							length -= pieceView.length;
							offset += pieceView.length;
						}
						
						this.encryptedContent = constrString;
					}
					//endregion
				}
			}
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "contentType":
					return "";
				case "contentEncryptionAlgorithm":
					return new AlgorithmIdentifier$1();
				case "encryptedContent":
					return new OctetString$1();
				default:
					throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "contentType":
					return (memberValue === "");
				case "contentEncryptionAlgorithm":
					return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
				case "encryptedContent":
					return (memberValue.isEqual(EncryptedContentInfo.defaultValues(memberName)));
				default:
					throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * EncryptedContentInfo ::= SEQUENCE {
		 *    contentType ContentType,
		 *    contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
		 *    encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }
		 *
		 * Comment: Strange, but modern crypto engines create "encryptedContent" as "[0] EXPLICIT EncryptedContent"
		 *
		 * EncryptedContent ::= OCTET STRING
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [contentType]
			 * @property {string} [contentEncryptionAlgorithm]
			 * @property {string} [encryptedContent]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.contentType || "") }),
					AlgorithmIdentifier$1.schema(names.contentEncryptionAlgorithm || {}),
					// The CHOICE we need because "EncryptedContent" could have either "constructive"
					// or "primitive" form of encoding and we need to handle both variants
					new Choice({
						value: [
							new Constructed$1({
								name: (names.encryptedContent || ""),
								idBlock: {
									tagClass: 3, // CONTEXT-SPECIFIC
									tagNumber: 0 // [0]
								},
								value: [
									new Repeated({
										value: new OctetString$1()
									})
								]
							}),
							new Primitive$1({
								name: (names.encryptedContent || ""),
								idBlock: {
									tagClass: 3, // CONTEXT-SPECIFIC
									tagNumber: 0 // [0]
								}
							})
						]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"contentType",
				"contentEncryptionAlgorithm",
				"encryptedContent"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				EncryptedContentInfo.schema({
					names: {
						contentType: "contentType",
						contentEncryptionAlgorithm: {
							names: {
								blockName: "contentEncryptionAlgorithm"
							}
						},
						encryptedContent: "encryptedContent"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");
			//endregion

			//region Get internal properties from parsed schema
			this.contentType = asn1.result.contentType.valueBlock.toString();
			this.contentEncryptionAlgorithm = new AlgorithmIdentifier$1({ schema: asn1.result.contentEncryptionAlgorithm });

			if("encryptedContent" in asn1.result)
			{
				this.encryptedContent = asn1.result.encryptedContent;

				this.encryptedContent.idBlock.tagClass = 1; // UNIVERSAL
				this.encryptedContent.idBlock.tagNumber = 4; // OCTETSTRING (!!!) The value still has instance of "in_window.org.pkijs.asn1.ASN1_CONSTRUCTED / ASN1_PRIMITIVE"
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const sequenceLengthBlock = {
				isIndefiniteForm: false
			};

			const outputArray = [];

			outputArray.push(new ObjectIdentifier$2({ value: this.contentType }));
			outputArray.push(this.contentEncryptionAlgorithm.toSchema());

			if("encryptedContent" in this)
			{
				sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;

				const encryptedValue = this.encryptedContent;

				encryptedValue.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
				encryptedValue.idBlock.tagNumber = 0; // [0]

				encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;

				outputArray.push(encryptedValue);
			}
			//endregion

			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				lenBlock: sequenceLengthBlock,
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const _object = {
				contentType: this.contentType,
				contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
			};

			if("encryptedContent" in this)
				_object.encryptedContent = this.encryptedContent.toJSON();

			return _object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC4055
	 */
	class RSASSAPSSParams
	{
		//**********************************************************************************
		/**
		 * Constructor for RSASSAPSSParams class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc Algorithms of hashing (DEFAULT sha1)
			 */
			this.hashAlgorithm = getParametersValue$2(parameters, "hashAlgorithm", RSASSAPSSParams.defaultValues("hashAlgorithm"));
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc Algorithm of "mask generaion function (MGF)" (DEFAULT mgf1SHA1)
			 */
			this.maskGenAlgorithm = getParametersValue$2(parameters, "maskGenAlgorithm", RSASSAPSSParams.defaultValues("maskGenAlgorithm"));
			/**
			 * @type {number}
			 * @desc Salt length (DEFAULT 20)
			 */
			this.saltLength = getParametersValue$2(parameters, "saltLength", RSASSAPSSParams.defaultValues("saltLength"));
			/**
			 * @type {number}
			 * @desc (DEFAULT 1)
			 */
			this.trailerField = getParametersValue$2(parameters, "trailerField", RSASSAPSSParams.defaultValues("trailerField"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "hashAlgorithm":
					return new AlgorithmIdentifier$1({
						algorithmId: "1.3.14.3.2.26", // SHA-1
						algorithmParams: new Null$1()
					});
				case "maskGenAlgorithm":
					return new AlgorithmIdentifier$1({
						algorithmId: "1.2.840.113549.1.1.8", // MGF1
						algorithmParams: (new AlgorithmIdentifier$1({
							algorithmId: "1.3.14.3.2.26", // SHA-1
							algorithmParams: new Null$1()
						})).toSchema()
					});
				case "saltLength":
					return 20;
				case "trailerField":
					return 1;
				default:
					throw new Error(`Invalid member name for RSASSAPSSParams class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * RSASSA-PSS-params  ::=  Sequence  {
		 *    hashAlgorithm      [0] HashAlgorithm DEFAULT sha1Identifier,
		 *    maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1Identifier,
		 *    saltLength         [2] Integer DEFAULT 20,
		 *    trailerField       [3] Integer DEFAULT 1  }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [hashAlgorithm]
			 * @property {string} [maskGenAlgorithm]
			 * @property {string} [saltLength]
			 * @property {string} [trailerField]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						optional: true,
						value: [AlgorithmIdentifier$1.schema(names.hashAlgorithm || {})]
					}),
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						},
						optional: true,
						value: [AlgorithmIdentifier$1.schema(names.maskGenAlgorithm || {})]
					}),
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 2 // [2]
						},
						optional: true,
						value: [new Integer$1({ name: (names.saltLength || "") })]
					}),
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 3 // [3]
						},
						optional: true,
						value: [new Integer$1({ name: (names.trailerField || "") })]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"hashAlgorithm",
				"maskGenAlgorithm",
				"saltLength",
				"trailerField"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				RSASSAPSSParams.schema({
					names: {
						hashAlgorithm: {
							names: {
								blockName: "hashAlgorithm"
							}
						},
						maskGenAlgorithm: {
							names: {
								blockName: "maskGenAlgorithm"
							}
						},
						saltLength: "saltLength",
						trailerField: "trailerField"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");
			//endregion

			//region Get internal properties from parsed schema
			if("hashAlgorithm" in asn1.result)
				this.hashAlgorithm = new AlgorithmIdentifier$1({ schema: asn1.result.hashAlgorithm });

			if("maskGenAlgorithm" in asn1.result)
				this.maskGenAlgorithm = new AlgorithmIdentifier$1({ schema: asn1.result.maskGenAlgorithm });

			if("saltLength" in asn1.result)
				this.saltLength = asn1.result.saltLength.valueBlock.valueDec;

			if("trailerField" in asn1.result)
				this.trailerField = asn1.result.trailerField.valueBlock.valueDec;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if(!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm")))
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [this.hashAlgorithm.toSchema()]
				}));
			}
			
			if(!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm")))
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [this.maskGenAlgorithm.toSchema()]
				}));
			}
			
			if(this.saltLength !== RSASSAPSSParams.defaultValues("saltLength"))
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: [new Integer$1({ value: this.saltLength })]
				}));
			}
			
			if(this.trailerField !== RSASSAPSSParams.defaultValues("trailerField"))
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					value: [new Integer$1({ value: this.trailerField })]
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};

			if(!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm")))
				object.hashAlgorithm = this.hashAlgorithm.toJSON();

			if(!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm")))
				object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();

			if(this.saltLength !== RSASSAPSSParams.defaultValues("saltLength"))
				object.saltLength = this.saltLength;

			if(this.trailerField !== RSASSAPSSParams.defaultValues("trailerField"))
				object.trailerField = this.trailerField;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC2898
	 */
	class PBKDF2Params
	{
		//**********************************************************************************
		/**
		 * Constructor for PBKDF2Params class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Object}
			 * @desc salt
			 */
			this.salt = getParametersValue$2(parameters, "salt", PBKDF2Params.defaultValues("salt"));
			/**
			 * @type {number}
			 * @desc iterationCount
			 */
			this.iterationCount = getParametersValue$2(parameters, "iterationCount", PBKDF2Params.defaultValues("iterationCount"));
			
			if("keyLength" in parameters)
				/**
				 * @type {number}
				 * @desc keyLength
				 */
				this.keyLength = getParametersValue$2(parameters, "keyLength", PBKDF2Params.defaultValues("keyLength"));
			
			if("prf" in parameters)
				/**
				 * @type {AlgorithmIdentifier}
				 * @desc prf
				 */
				this.prf = getParametersValue$2(parameters, "prf", PBKDF2Params.defaultValues("prf"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "salt":
					return {};
				case "iterationCount":
					return (-1);
				case "keyLength":
					return 0;
				case "prf":
					return new AlgorithmIdentifier$1({
						algorithmId: "1.3.14.3.2.26", // SHA-1
						algorithmParams: new Null$1()
					});
				default:
					throw new Error(`Invalid member name for PBKDF2Params class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PBKDF2-params ::= SEQUENCE {
		 *    salt CHOICE {
		 *        specified OCTET STRING,
		 *        otherSource AlgorithmIdentifier },
		 *  iterationCount INTEGER (1..MAX),
		 *  keyLength INTEGER (1..MAX) OPTIONAL,
		 *  prf AlgorithmIdentifier
		 *    DEFAULT { algorithm hMAC-SHA1, parameters NULL } }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [saltPrimitive]
			 * @property {string} [saltConstructed]
			 * @property {string} [iterationCount]
			 * @property {string} [keyLength]
			 * @property {string} [prf]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Choice({
						value: [
							new OctetString$1({ name: (names.saltPrimitive || "") }),
							AlgorithmIdentifier$1.schema(names.saltConstructed || {})
						]
					}),
					new Integer$1({ name: (names.iterationCount || "") }),
					new Integer$1({
						name: (names.keyLength || ""),
						optional: true
					}),
					AlgorithmIdentifier$1.schema(names.prf || {
						names: {
							optional: true
						}
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"salt",
				"iterationCount",
				"keyLength",
				"prf"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PBKDF2Params.schema({
					names: {
						saltPrimitive: "salt",
						saltConstructed: {
							names: {
								blockName: "salt"
							}
						},
						iterationCount: "iterationCount",
						keyLength: "keyLength",
						prf: {
							names: {
								blockName: "prf",
								optional: true
							}
						}
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PBKDF2Params");
			//endregion

			//region Get internal properties from parsed schema
			this.salt = asn1.result.salt;
			this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;

			if("keyLength" in asn1.result)
				this.keyLength = asn1.result.keyLength.valueBlock.valueDec;

			if("prf" in asn1.result)
				this.prf = new AlgorithmIdentifier$1({ schema: asn1.result.prf });
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence 
			const outputArray = [];
			
			outputArray.push(this.salt);
			outputArray.push(new Integer$1({ value: this.iterationCount }));
			
			if("keyLength" in this)
			{
				if(PBKDF2Params.defaultValues("keyLength") !== this.keyLength)
					outputArray.push(new Integer$1({ value: this.keyLength }));
			}
			
			if("prf" in this)
			{
				if(PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false)
					outputArray.push(this.prf.toSchema());
			}
			//endregion 
			
			//region Construct and return new ASN.1 schema for this object 
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion 
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const _object = {
				salt: this.salt.toJSON(),
				iterationCount: this.iterationCount
			};
			
			if("keyLength" in this)
			{
				if(PBKDF2Params.defaultValues("keyLength") !== this.keyLength)
					_object.keyLength = this.keyLength;
			}
			
			if("prf" in this)
			{
				if(PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false)
					_object.prf = this.prf.toJSON();
			}

			return _object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC2898
	 */
	class PBES2Params
	{
		//**********************************************************************************
		/**
		 * Constructor for PBES2Params class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc keyDerivationFunc
			 */
			this.keyDerivationFunc = getParametersValue$2(parameters, "keyDerivationFunc", PBES2Params.defaultValues("keyDerivationFunc"));
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc encryptionScheme
			 */
			this.encryptionScheme = getParametersValue$2(parameters, "encryptionScheme", PBES2Params.defaultValues("encryptionScheme"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "keyDerivationFunc":
					return new AlgorithmIdentifier$1();
				case "encryptionScheme":
					return new AlgorithmIdentifier$1();
				default:
					throw new Error(`Invalid member name for PBES2Params class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PBES2-params ::= SEQUENCE {
		 *    keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
		 *    encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [keyDerivationFunc]
			 * @property {string} [encryptionScheme]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					AlgorithmIdentifier$1.schema(names.keyDerivationFunc || {}),
					AlgorithmIdentifier$1.schema(names.encryptionScheme || {})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"keyDerivationFunc",
				"encryptionScheme"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PBES2Params.schema({
					names: {
						keyDerivationFunc: {
							names: {
								blockName: "keyDerivationFunc"
							}
						},
						encryptionScheme: {
							names: {
								blockName: "encryptionScheme"
							}
						}
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PBES2Params");
			//endregion

			//region Get internal properties from parsed schema
			this.keyDerivationFunc = new AlgorithmIdentifier$1({ schema: asn1.result.keyDerivationFunc });
			this.encryptionScheme = new AlgorithmIdentifier$1({ schema: asn1.result.encryptionScheme });
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					this.keyDerivationFunc.toSchema(),
					this.encryptionScheme.toSchema()
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				keyDerivationFunc: this.keyDerivationFunc.toJSON(),
				encryptionScheme: this.encryptionScheme.toJSON()
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Making MAC key using algorithm described in B.2 of PKCS#12 standard.
	 */
	function makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount)
	{
		//region Initial variables
		let u;
		let v;
		
		const result = [];
		//endregion
		
		//region Get "u" and "v" values
		switch(hashAlgorithm.toUpperCase())
		{
			case "SHA-1":
				u = 20; // 160
				v = 64; // 512
				break;
			case "SHA-256":
				u = 32; // 256
				v = 64; // 512
				break;
			case "SHA-384":
				u = 48; // 384
				v = 128; // 1024
				break;
			case "SHA-512":
				u = 64; // 512
				v = 128; // 1024
				break;
			default:
				throw new Error("Unsupported hashing algorithm");
		}
		//endregion
		
		//region Main algorithm making key
		//region Transform password to UTF-8 like string
		const passwordViewInitial = new Uint8Array(password);
		
		const passwordTransformed = new ArrayBuffer((password.byteLength * 2) + 2);
		const passwordTransformedView = new Uint8Array(passwordTransformed);
		
		for(let i = 0; i < passwordViewInitial.length; i++)
		{
			passwordTransformedView[i * 2] = 0x00;
			passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];
		}
		
		passwordTransformedView[passwordTransformedView.length - 2] = 0x00;
		passwordTransformedView[passwordTransformedView.length - 1] = 0x00;
		
		password = passwordTransformed.slice(0);
		//endregion
		
		//region Construct a string D (the "diversifier") by concatenating v/8 copies of ID
		const D = new ArrayBuffer(v);
		const dView = new Uint8Array(D);
		
		for(let i = 0; i < D.byteLength; i++)
			dView[i] = 3; // The ID value equal to "3" for MACing (see B.3 of standard)
		//endregion
		
		//region Concatenate copies of the salt together to create a string S of length v * ceil(s / v) bytes (the final copy of the salt may be trunacted to create S)
		const saltLength = salt.byteLength;
		
		const sLen = v * Math.ceil(saltLength / v);
		const S = new ArrayBuffer(sLen);
		const sView = new Uint8Array(S);
		
		const saltView = new Uint8Array(salt);
		
		for(let i = 0; i < sLen; i++)
			sView[i] = saltView[i % saltLength];
		//endregion
		
		//region Concatenate copies of the password together to create a string P of length v * ceil(p / v) bytes (the final copy of the password may be truncated to create P)
		const passwordLength = password.byteLength;
		
		const pLen = v * Math.ceil(passwordLength / v);
		const P = new ArrayBuffer(pLen);
		const pView = new Uint8Array(P);
		
		const passwordView = new Uint8Array(password);
		
		for(let i = 0; i < pLen; i++)
			pView[i] = passwordView[i % passwordLength];
		//endregion
		
		//region Set I=S||P to be the concatenation of S and P
		const sPlusPLength = S.byteLength + P.byteLength;
		
		let I = new ArrayBuffer(sPlusPLength);
		let iView = new Uint8Array(I);
		
		iView.set(sView);
		iView.set(pView, sView.length);
		//endregion
		
		//region Set c=ceil(n / u)
		const c = Math.ceil((keyLength >> 3) / u);
		//endregion
		
		//region Initial variables
		let internalSequence = Promise.resolve(I);
		//endregion
		
		//region For i=1, 2, ..., c, do the following:
		for(let i = 0; i <= c; i++)
		{
			internalSequence = internalSequence.then(_I =>
			{
				//region Create contecanetion of D and I
				const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
				const dAndIView = new Uint8Array(dAndI);
				
				dAndIView.set(dView);
				dAndIView.set(iView, dView.length);
				//endregion
				
				return dAndI;
			});
			
			//region Make "iterationCount" rounds of hashing
			for(let j = 0; j < iterationCount; j++)
				internalSequence = internalSequence.then(roundBuffer => cryptoEngine.digest({ name: hashAlgorithm }, new Uint8Array(roundBuffer)));
			//endregion
			
			internalSequence = internalSequence.then(roundBuffer =>
			{
				//region Concatenate copies of Ai to create a string B of length v bits (the final copy of Ai may be truncated to create B)
				const B = new ArrayBuffer(v);
				const bView = new Uint8Array(B);
				
				for(let j = 0; j < B.byteLength; j++)
					bView[j] = roundBuffer[j % roundBuffer.length];
				//endregion
				
				//region Make new I value
				const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
				const iRound = [];
				
				let sliceStart = 0;
				let sliceLength = v;
				
				for(let j = 0; j < k; j++)
				{
					const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
					sliceStart += v;
					if((sliceStart + v) > I.byteLength)
						sliceLength = I.byteLength - sliceStart;
					
					let x = 0x1ff;
					
					for(let l = (B.byteLength - 1); l >= 0; l--)
					{
						x >>= 8;
						x += bView[l] + chunk[l];
						chunk[l] = (x & 0xff);
					}
					
					iRound.push(...chunk);
				}
				
				I = new ArrayBuffer(iRound.length);
				iView = new Uint8Array(I);
				
				iView.set(iRound);
				//endregion
				
				result.push(...(new Uint8Array(roundBuffer)));
				
				return I;
			});
		}
		//endregion
		
		//region Initialize final key
		internalSequence = internalSequence.then(() =>
		{
			const resultBuffer = new ArrayBuffer(keyLength >> 3);
			const resultView = new Uint8Array(resultBuffer);
			
			resultView.set((new Uint8Array(result)).slice(0, keyLength >> 3));
			
			return resultBuffer;
		});
		//endregion
		//endregion
		
		return internalSequence;
	}
	//**************************************************************************************
	/**
	 * Default cryptographic engine for Web Cryptography API
	 */
	class CryptoEngine
	{
		//**********************************************************************************
		/**
		 * Constructor for CryptoEngine class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Object}
			 * @desc Usually here we are expecting "window.crypto" or an equivalent from custom "crypto engine"
			 */
			this.crypto = getParametersValue$2(parameters, "crypto", {});
			/**
			 * @type {Object}
			 * @desc Usually here we are expecting "window.crypto.subtle" or an equivalent from custom "crypto engine"
			 */
			this.subtle = getParametersValue$2(parameters, "subtle", {});
			/**
			 * @type {string}
			 * @desc Name of the "crypto engine"
			 */
			this.name = getParametersValue$2(parameters, "name", "");
			//endregion
		}
		//**********************************************************************************
		/**
		 * Import WebCrypto keys from different formats
		 * @param {string} format
		 * @param {ArrayBuffer|Uint8Array} keyData
		 * @param {Object} algorithm
		 * @param {boolean} extractable
		 * @param {Array} keyUsages
		 * @returns {Promise}
		 */
		importKey(format, keyData, algorithm, extractable, keyUsages)
		{
			//region Initial variables
			let jwk = {};
			//endregion
			
			//region Change "keyData" type if needed
			if(keyData instanceof Uint8Array)
				keyData = keyData.buffer;
			//endregion
			
			switch(format.toLowerCase())
			{
				case "raw":
					return this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages);
				case "spki":
					{
						const asn1 = fromBER$1(keyData);
						if(asn1.offset === (-1))
							return Promise.reject("Incorrect keyData");

						const publicKeyInfo = new PublicKeyInfo$1();
						try
						{
							publicKeyInfo.fromSchema(asn1.result);
						}
						catch(ex)
						{
							return Promise.reject("Incorrect keyData");
						}


						// noinspection FallThroughInSwitchStatementJS
						switch(algorithm.name.toUpperCase())
						{
							case "RSA-PSS":
								{
									//region Get information about used hash function
									switch(algorithm.hash.name.toUpperCase())
									{
										case "SHA-1":
											jwk.alg = "PS1";
											break;
										case "SHA-256":
											jwk.alg = "PS256";
											break;
										case "SHA-384":
											jwk.alg = "PS384";
											break;
										case "SHA-512":
											jwk.alg = "PS512";
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
									//endregion
								}
								// break omitted
							case "RSASSA-PKCS1-V1_5":
								{
									keyUsages = ["verify"]; // Override existing keyUsages value since the key is a public key

									jwk.kty = "RSA";
									jwk.ext = extractable;
									jwk.key_ops = keyUsages;

									if(publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1")
										return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);

									//region Get information about used hash function
									if(("alg" in jwk) === false)
									{
										switch(algorithm.hash.name.toUpperCase())
										{
											case "SHA-1":
												jwk.alg = "RS1";
												break;
											case "SHA-256":
												jwk.alg = "RS256";
												break;
											case "SHA-384":
												jwk.alg = "RS384";
												break;
											case "SHA-512":
												jwk.alg = "RS512";
												break;
											default:
												return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
										}
									}
									//endregion

									//region Create RSA Public Key elements
									const publicKeyJSON = publicKeyInfo.toJSON();

									for(const key of Object.keys(publicKeyJSON))
										jwk[key] = publicKeyJSON[key];
									//endregion
								}
								break;
							case "ECDSA":
								keyUsages = ["verify"]; // Override existing keyUsages value since the key is a public key
								// break omitted
							case "ECDH":
								{
									//region Initial variables
									jwk = {
										kty: "EC",
										ext: extractable,
										key_ops: keyUsages
									};
									//endregion

									//region Get information about algorithm
									if(publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1")
										return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
									//endregion

									//region Create ECDSA Public Key elements
									const publicKeyJSON = publicKeyInfo.toJSON();

									for(const key of Object.keys(publicKeyJSON))
										jwk[key] = publicKeyJSON[key];
									//endregion
								}
								break;
							case "RSA-OAEP":
								{
									jwk.kty = "RSA";
									jwk.ext = extractable;
									jwk.key_ops = keyUsages;
									
									if(this.name.toLowerCase() === "safari")
										jwk.alg = "RSA-OAEP";
									else
									{
										switch(algorithm.hash.name.toUpperCase())
										{
											case "SHA-1":
												jwk.alg = "RSA-OAEP";
												break;
											case "SHA-256":
												jwk.alg = "RSA-OAEP-256";
												break;
											case "SHA-384":
												jwk.alg = "RSA-OAEP-384";
												break;
											case "SHA-512":
												jwk.alg = "RSA-OAEP-512";
												break;
											default:
												return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
										}
									}
									
									//region Create ECDSA Public Key elements
									const publicKeyJSON = publicKeyInfo.toJSON();
									
									for(const key of Object.keys(publicKeyJSON))
										jwk[key] = publicKeyJSON[key];
									//endregion
								}
								break;
							default:
								return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
						}
					}
					break;
				case "pkcs8":
					{
						const privateKeyInfo = new PrivateKeyInfo$1();

						//region Parse "PrivateKeyInfo" object
						const asn1 = fromBER$1(keyData);
						if(asn1.offset === (-1))
							return Promise.reject("Incorrect keyData");

						try
						{
							privateKeyInfo.fromSchema(asn1.result);
						}
						catch(ex)
						{
							return Promise.reject("Incorrect keyData");
						}
						
						if(("parsedKey" in privateKeyInfo) === false)
							return Promise.reject("Incorrect keyData");
						//endregion

						// noinspection FallThroughInSwitchStatementJS
						// noinspection FallThroughInSwitchStatementJS
						switch(algorithm.name.toUpperCase())
						{
							case "RSA-PSS":
								{
									//region Get information about used hash function
									switch(algorithm.hash.name.toUpperCase())
									{
										case "SHA-1":
											jwk.alg = "PS1";
											break;
										case "SHA-256":
											jwk.alg = "PS256";
											break;
										case "SHA-384":
											jwk.alg = "PS384";
											break;
										case "SHA-512":
											jwk.alg = "PS512";
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
									//endregion
								}
								// break omitted
							case "RSASSA-PKCS1-V1_5":
								{
									keyUsages = ["sign"]; // Override existing keyUsages value since the key is a private key

									jwk.kty = "RSA";
									jwk.ext = extractable;
									jwk.key_ops = keyUsages;

									//region Get information about used hash function
									if(privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1")
										return Promise.reject(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
									//endregion

									//region Get information about used hash function
									if(("alg" in jwk) === false)
									{
										switch(algorithm.hash.name.toUpperCase())
										{
											case "SHA-1":
												jwk.alg = "RS1";
												break;
											case "SHA-256":
												jwk.alg = "RS256";
												break;
											case "SHA-384":
												jwk.alg = "RS384";
												break;
											case "SHA-512":
												jwk.alg = "RS512";
												break;
											default:
												return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
										}
									}
									//endregion

									//region Create RSA Private Key elements
									const privateKeyJSON = privateKeyInfo.toJSON();

									for(const key of Object.keys(privateKeyJSON))
										jwk[key] = privateKeyJSON[key];
									//endregion
								}
								break;
							case "ECDSA":
								keyUsages = ["sign"]; // Override existing keyUsages value since the key is a private key
								// break omitted
							case "ECDH":
								{
									//region Initial variables
									jwk = {
										kty: "EC",
										ext: extractable,
										key_ops: keyUsages
									};
									//endregion

									//region Get information about used hash function
									if(privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1")
										return Promise.reject(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
									//endregion

									//region Create ECDSA Private Key elements
									const privateKeyJSON = privateKeyInfo.toJSON();

									for(const key of Object.keys(privateKeyJSON))
										jwk[key] = privateKeyJSON[key];
									//endregion
								}
								break;
							case "RSA-OAEP":
								{
									jwk.kty = "RSA";
									jwk.ext = extractable;
									jwk.key_ops = keyUsages;
									
									//region Get information about used hash function
									if(this.name.toLowerCase() === "safari")
										jwk.alg = "RSA-OAEP";
									else
									{
										switch(algorithm.hash.name.toUpperCase())
										{
											case "SHA-1":
												jwk.alg = "RSA-OAEP";
												break;
											case "SHA-256":
												jwk.alg = "RSA-OAEP-256";
												break;
											case "SHA-384":
												jwk.alg = "RSA-OAEP-384";
												break;
											case "SHA-512":
												jwk.alg = "RSA-OAEP-512";
												break;
											default:
												return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
										}
									}
									//endregion
									
									//region Create RSA Private Key elements
									const privateKeyJSON = privateKeyInfo.toJSON();
									
									for(const key of Object.keys(privateKeyJSON))
										jwk[key] = privateKeyJSON[key];
									//endregion
								}
								break;
							default:
								return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
						}
					}
					break;
				case "jwk":
					jwk = keyData;
					break;
				default:
					return Promise.reject(`Incorrect format: ${format}`);
			}
			
			//region Special case for Safari browser (since its acting not as WebCrypto standard describes)
			if(this.name.toLowerCase() === "safari")
			{
				// Try to use both ways - import using ArrayBuffer and pure JWK (for Safari Technology Preview)
				return Promise.resolve().then(() => this.subtle.importKey("jwk", stringToArrayBuffer$2(JSON.stringify(jwk)), algorithm, extractable, keyUsages))
					.then(result => result, () => this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages));
			}
			//endregion
			
			return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
		}
		//**********************************************************************************
		/**
		 * Export WebCrypto keys to different formats
		 * @param {string} format
		 * @param {Object} key
		 * @returns {Promise}
		 */
		exportKey(format, key)
		{
			let sequence = this.subtle.exportKey("jwk", key);
			
			//region Currently Safari returns ArrayBuffer as JWK thus we need an additional transformation
			if(this.name.toLowerCase() === "safari")
			{
				sequence = sequence.then(result =>
				{
					// Some additional checks for Safari Technology Preview
					if(result instanceof ArrayBuffer)
						return JSON.parse(arrayBufferToString$1(result));
					
					return result;
				});
			}
			//endregion
			
			switch(format.toLowerCase())
			{
				case "raw":
					return this.subtle.exportKey("raw", key);
				case "spki":
					sequence = sequence.then(result =>
					{
						const publicKeyInfo = new PublicKeyInfo$1();

						try
						{
							publicKeyInfo.fromJSON(result);
						}
						catch(ex)
						{
							return Promise.reject("Incorrect key data");
						}

						return publicKeyInfo.toSchema().toBER(false);
					});
					break;
				case "pkcs8":
					sequence = sequence.then(result =>
					{
						const privateKeyInfo = new PrivateKeyInfo$1();

						try
						{
							privateKeyInfo.fromJSON(result);
						}
						catch(ex)
						{
							return Promise.reject("Incorrect key data");
						}

						return privateKeyInfo.toSchema().toBER(false);
					});
					break;
				case "jwk":
					break;
				default:
					return Promise.reject(`Incorrect format: ${format}`);
			}

			return sequence;
		}
		//**********************************************************************************
		/**
		 * Convert WebCrypto keys between different export formats
		 * @param {string} inputFormat
		 * @param {string} outputFormat
		 * @param {ArrayBuffer|Object} keyData
		 * @param {Object} algorithm
		 * @param {boolean} extractable
		 * @param {Array} keyUsages
		 * @returns {Promise}
		 */
		convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages)
		{
			switch(inputFormat.toLowerCase())
			{
				case "raw":
					switch(outputFormat.toLowerCase())
					{
						case "raw":
							return Promise.resolve(keyData);
						case "spki":
							return Promise.resolve()
								.then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("spki", result));
						case "pkcs8":
							return Promise.resolve()
								.then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("pkcs8", result));
						case "jwk":
							return Promise.resolve()
								.then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("jwk", result));
						default:
							return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
					}
				case "spki":
					switch(outputFormat.toLowerCase())
					{
						case "raw":
							return Promise.resolve()
								.then(() => this.importKey("spki", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("raw", result));
						case "spki":
							return Promise.resolve(keyData);
						case "pkcs8":
							return Promise.reject("Impossible to convert between SPKI/PKCS8");
						case "jwk":
							return Promise.resolve()
								.then(() => this.importKey("spki", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("jwk", result));
						default:
							return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
					}
				case "pkcs8":
					switch(outputFormat.toLowerCase())
					{
						case "raw":
							return Promise.resolve()
								.then(() => this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("raw", result));
						case "spki":
							return Promise.reject("Impossible to convert between SPKI/PKCS8");
						case "pkcs8":
							return Promise.resolve(keyData);
						case "jwk":
							return Promise.resolve()
								.then(() => this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("jwk", result));
						default:
							return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
					}
				case "jwk":
					switch(outputFormat.toLowerCase())
					{
						case "raw":
							return Promise.resolve()
								.then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("raw", result));
						case "spki":
							return Promise.resolve()
								.then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("spki", result));
						case "pkcs8":
							return Promise.resolve()
								.then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages))
								.then(result => this.exportKey("pkcs8", result));
						case "jwk":
							return Promise.resolve(keyData);
						default:
							return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
					}
				default:
					return Promise.reject(`Incorrect inputFormat: ${inputFormat}`);
			}
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "encrypt"
		 * @param args
		 * @returns {Promise}
		 */
		encrypt(...args)
		{
			return this.subtle.encrypt(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "decrypt"
		 * @param args
		 * @returns {Promise}
		 */
		decrypt(...args)
		{
			return this.subtle.decrypt(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "sign"
		 * @param args
		 * @returns {Promise}
		 */
		sign(...args)
		{
			return this.subtle.sign(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "verify"
		 * @param args
		 * @returns {Promise}
		 */
		verify(...args)
		{
			return this.subtle.verify(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "digest"
		 * @param args
		 * @returns {Promise}
		 */
		digest(...args)
		{
			return this.subtle.digest(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "generateKey"
		 * @param args
		 * @returns {Promise}
		 */
		generateKey(...args)
		{
			return this.subtle.generateKey(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "deriveKey"
		 * @param args
		 * @returns {Promise}
		 */
		deriveKey(...args)
		{
			return this.subtle.deriveKey(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "deriveBits"
		 * @param args
		 * @returns {Promise}
		 */
		deriveBits(...args)
		{
			return this.subtle.deriveBits(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "wrapKey"
		 * @param args
		 * @returns {Promise}
		 */
		wrapKey(...args)
		{
			return this.subtle.wrapKey(...args);
		}
		//**********************************************************************************
		/**
		 * Wrapper for standard function "unwrapKey"
		 * @param args
		 * @returns {Promise}
		 */
		unwrapKey(...args)
		{
			return this.subtle.unwrapKey(...args);
		}
		//**********************************************************************************
		/**
		 * Initialize input Uint8Array by random values (with help from current "crypto engine")
		 * @param {!Uint8Array} view
		 * @returns {*}
		 */
		getRandomValues(view)
		{
			if(("getRandomValues" in this.crypto) === false)
				throw new Error("No support for getRandomValues");
			
			return this.crypto.getRandomValues(view);
		}
		//**********************************************************************************
		/**
		 * Get WebCrypto algorithm by wel-known OID
		 * @param {string} oid well-known OID to search for
		 * @returns {Object}
		 */
		getAlgorithmByOID(oid)
		{
			switch(oid)
			{
				case "1.2.840.113549.1.1.1":
				case "1.2.840.113549.1.1.5":
					return {
						name: "RSASSA-PKCS1-v1_5",
						hash: {
							name: "SHA-1"
						}
					};
				case "1.2.840.113549.1.1.11":
					return {
						name: "RSASSA-PKCS1-v1_5",
						hash: {
							name: "SHA-256"
						}
					};
				case "1.2.840.113549.1.1.12":
					return {
						name: "RSASSA-PKCS1-v1_5",
						hash: {
							name: "SHA-384"
						}
					};
				case "1.2.840.113549.1.1.13":
					return {
						name: "RSASSA-PKCS1-v1_5",
						hash: {
							name: "SHA-512"
						}
					};
				case "1.2.840.113549.1.1.10":
					return {
						name: "RSA-PSS"
					};
				case "1.2.840.113549.1.1.7":
					return {
						name: "RSA-OAEP"
					};
				case "1.2.840.10045.2.1":
				case "1.2.840.10045.4.1":
					return {
						name: "ECDSA",
						hash: {
							name: "SHA-1"
						}
					};
				case "1.2.840.10045.4.3.2":
					return {
						name: "ECDSA",
						hash: {
							name: "SHA-256"
						}
					};
				case "1.2.840.10045.4.3.3":
					return {
						name: "ECDSA",
						hash: {
							name: "SHA-384"
						}
					};
				case "1.2.840.10045.4.3.4":
					return {
						name: "ECDSA",
						hash: {
							name: "SHA-512"
						}
					};
				case "1.3.133.16.840.63.0.2":
					return {
						name: "ECDH",
						kdf: "SHA-1"
					};
				case "1.3.132.1.11.1":
					return {
						name: "ECDH",
						kdf: "SHA-256"
					};
				case "1.3.132.1.11.2":
					return {
						name: "ECDH",
						kdf: "SHA-384"
					};
				case "1.3.132.1.11.3":
					return {
						name: "ECDH",
						kdf: "SHA-512"
					};
				case "2.16.840.1.101.3.4.1.2":
					return {
						name: "AES-CBC",
						length: 128
					};
				case "2.16.840.1.101.3.4.1.22":
					return {
						name: "AES-CBC",
						length: 192
					};
				case "2.16.840.1.101.3.4.1.42":
					return {
						name: "AES-CBC",
						length: 256
					};
				case "2.16.840.1.101.3.4.1.6":
					return {
						name: "AES-GCM",
						length: 128
					};
				case "2.16.840.1.101.3.4.1.26":
					return {
						name: "AES-GCM",
						length: 192
					};
				case "2.16.840.1.101.3.4.1.46":
					return {
						name: "AES-GCM",
						length: 256
					};
				case "2.16.840.1.101.3.4.1.4":
					return {
						name: "AES-CFB",
						length: 128
					};
				case "2.16.840.1.101.3.4.1.24":
					return {
						name: "AES-CFB",
						length: 192
					};
				case "2.16.840.1.101.3.4.1.44":
					return {
						name: "AES-CFB",
						length: 256
					};
				case "2.16.840.1.101.3.4.1.5":
					return {
						name: "AES-KW",
						length: 128
					};
				case "2.16.840.1.101.3.4.1.25":
					return {
						name: "AES-KW",
						length: 192
					};
				case "2.16.840.1.101.3.4.1.45":
					return {
						name: "AES-KW",
						length: 256
					};
				case "1.2.840.113549.2.7":
					return {
						name: "HMAC",
						hash: {
							name: "SHA-1"
						}
					};
				case "1.2.840.113549.2.9":
					return {
						name: "HMAC",
						hash: {
							name: "SHA-256"
						}
					};
				case "1.2.840.113549.2.10":
					return {
						name: "HMAC",
						hash: {
							name: "SHA-384"
						}
					};
				case "1.2.840.113549.2.11":
					return {
						name: "HMAC",
						hash: {
							name: "SHA-512"
						}
					};
				case "1.2.840.113549.1.9.16.3.5":
					return {
						name: "DH"
					};
				case "1.3.14.3.2.26":
					return {
						name: "SHA-1"
					};
				case "2.16.840.1.101.3.4.2.1":
					return {
						name: "SHA-256"
					};
				case "2.16.840.1.101.3.4.2.2":
					return {
						name: "SHA-384"
					};
				case "2.16.840.1.101.3.4.2.3":
					return {
						name: "SHA-512"
					};
				case "1.2.840.113549.1.5.12":
					return {
						name: "PBKDF2"
					};
				//region Special case - OIDs for ECC curves
				case "1.2.840.10045.3.1.7":
					return {
						name: "P-256"
					};
				case "1.3.132.0.34":
					return {
						name: "P-384"
					};
				case "1.3.132.0.35":
					return {
						name: "P-521"
					};
				//endregion
				default:
			}
			
			return {};
		}
		//**********************************************************************************
		/**
		 * Get OID for each specific algorithm
		 * @param {Object} algorithm
		 * @returns {string}
		 */
		getOIDByAlgorithm(algorithm)
		{
			let result = "";
			
			switch(algorithm.name.toUpperCase())
			{
				case "RSASSA-PKCS1-V1_5":
					switch(algorithm.hash.name.toUpperCase())
					{
						case "SHA-1":
							result = "1.2.840.113549.1.1.5";
							break;
						case "SHA-256":
							result = "1.2.840.113549.1.1.11";
							break;
						case "SHA-384":
							result = "1.2.840.113549.1.1.12";
							break;
						case "SHA-512":
							result = "1.2.840.113549.1.1.13";
							break;
						default:
					}
					break;
				case "RSA-PSS":
					result = "1.2.840.113549.1.1.10";
					break;
				case "RSA-OAEP":
					result = "1.2.840.113549.1.1.7";
					break;
				case "ECDSA":
					switch(algorithm.hash.name.toUpperCase())
					{
						case "SHA-1":
							result = "1.2.840.10045.4.1";
							break;
						case "SHA-256":
							result = "1.2.840.10045.4.3.2";
							break;
						case "SHA-384":
							result = "1.2.840.10045.4.3.3";
							break;
						case "SHA-512":
							result = "1.2.840.10045.4.3.4";
							break;
						default:
					}
					break;
				case "ECDH":
					switch(algorithm.kdf.toUpperCase()) // Non-standard addition - hash algorithm of KDF function
					{
						case "SHA-1":
							result = "1.3.133.16.840.63.0.2"; // dhSinglePass-stdDH-sha1kdf-scheme
							break;
						case "SHA-256":
							result = "1.3.132.1.11.1"; // dhSinglePass-stdDH-sha256kdf-scheme
							break;
						case "SHA-384":
							result = "1.3.132.1.11.2"; // dhSinglePass-stdDH-sha384kdf-scheme
							break;
						case "SHA-512":
							result = "1.3.132.1.11.3"; // dhSinglePass-stdDH-sha512kdf-scheme
							break;
						default:
					}
					break;
				case "AES-CTR":
					break;
				case "AES-CBC":
					switch(algorithm.length)
					{
						case 128:
							result = "2.16.840.1.101.3.4.1.2";
							break;
						case 192:
							result = "2.16.840.1.101.3.4.1.22";
							break;
						case 256:
							result = "2.16.840.1.101.3.4.1.42";
							break;
						default:
					}
					break;
				case "AES-CMAC":
					break;
				case "AES-GCM":
					switch(algorithm.length)
					{
						case 128:
							result = "2.16.840.1.101.3.4.1.6";
							break;
						case 192:
							result = "2.16.840.1.101.3.4.1.26";
							break;
						case 256:
							result = "2.16.840.1.101.3.4.1.46";
							break;
						default:
					}
					break;
				case "AES-CFB":
					switch(algorithm.length)
					{
						case 128:
							result = "2.16.840.1.101.3.4.1.4";
							break;
						case 192:
							result = "2.16.840.1.101.3.4.1.24";
							break;
						case 256:
							result = "2.16.840.1.101.3.4.1.44";
							break;
						default:
					}
					break;
				case "AES-KW":
					switch(algorithm.length)
					{
						case 128:
							result = "2.16.840.1.101.3.4.1.5";
							break;
						case 192:
							result = "2.16.840.1.101.3.4.1.25";
							break;
						case 256:
							result = "2.16.840.1.101.3.4.1.45";
							break;
						default:
					}
					break;
				case "HMAC":
					switch(algorithm.hash.name.toUpperCase())
					{
						case "SHA-1":
							result = "1.2.840.113549.2.7";
							break;
						case "SHA-256":
							result = "1.2.840.113549.2.9";
							break;
						case "SHA-384":
							result = "1.2.840.113549.2.10";
							break;
						case "SHA-512":
							result = "1.2.840.113549.2.11";
							break;
						default:
					}
					break;
				case "DH":
					result = "1.2.840.113549.1.9.16.3.5";
					break;
				case "SHA-1":
					result = "1.3.14.3.2.26";
					break;
				case "SHA-256":
					result = "2.16.840.1.101.3.4.2.1";
					break;
				case "SHA-384":
					result = "2.16.840.1.101.3.4.2.2";
					break;
				case "SHA-512":
					result = "2.16.840.1.101.3.4.2.3";
					break;
				case "CONCAT":
					break;
				case "HKDF":
					break;
				case "PBKDF2":
					result = "1.2.840.113549.1.5.12";
					break;
				//region Special case - OIDs for ECC curves
				case "P-256":
					result = "1.2.840.10045.3.1.7";
					break;
				case "P-384":
					result = "1.3.132.0.34";
					break;
				case "P-521":
					result = "1.3.132.0.35";
					break;
				//endregion
				default:
			}
			
			return result;
		}
		//**********************************************************************************
		/**
		 * Get default algorithm parameters for each kind of operation
		 * @param {string} algorithmName Algorithm name to get common parameters for
		 * @param {string} operation Kind of operation: "sign", "encrypt", "generatekey", "importkey", "exportkey", "verify"
		 * @returns {*}
		 */
		getAlgorithmParameters(algorithmName, operation)
		{
			let result = {
				algorithm: {},
				usages: []
			};
			
			switch(algorithmName.toUpperCase())
			{
				case "RSASSA-PKCS1-V1_5":
					switch(operation.toLowerCase())
					{
						case "generatekey":
							result = {
								algorithm: {
									name: "RSASSA-PKCS1-v1_5",
									modulusLength: 2048,
									publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
									hash: {
										name: "SHA-256"
									}
								},
								usages: ["sign", "verify"]
							};
							break;
						case "verify":
						case "sign":
						case "importkey":
							result = {
								algorithm: {
									name: "RSASSA-PKCS1-v1_5",
									hash: {
										name: "SHA-256"
									}
								},
								usages: ["verify"] // For importKey("pkcs8") usage must be "sign" only
							};
							break;
						case "exportkey":
						default:
							return {
								algorithm: {
									name: "RSASSA-PKCS1-v1_5"
								},
								usages: []
							};
					}
					break;
				case "RSA-PSS":
					switch(operation.toLowerCase())
					{
						case "sign":
						case "verify":
							result = {
								algorithm: {
									name: "RSA-PSS",
									hash: {
										name: "SHA-1"
									},
									saltLength: 20
								},
								usages: ["sign", "verify"]
							};
							break;
						case "generatekey":
							result = {
								algorithm: {
									name: "RSA-PSS",
									modulusLength: 2048,
									publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
									hash: {
										name: "SHA-1"
									}
								},
								usages: ["sign", "verify"]
							};
							break;
						case "importkey":
							result = {
								algorithm: {
									name: "RSA-PSS",
									hash: {
										name: "SHA-1"
									}
								},
								usages: ["verify"] // For importKey("pkcs8") usage must be "sign" only
							};
							break;
						case "exportkey":
						default:
							return {
								algorithm: {
									name: "RSA-PSS"
								},
								usages: []
							};
					}
					break;
				case "RSA-OAEP":
					switch(operation.toLowerCase())
					{
						case "encrypt":
						case "decrypt":
							result = {
								algorithm: {
									name: "RSA-OAEP"
								},
								usages: ["encrypt", "decrypt"]
							};
							break;
						case "generatekey":
							result = {
								algorithm: {
									name: "RSA-OAEP",
									modulusLength: 2048,
									publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
									hash: {
										name: "SHA-256"
									}
								},
								usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
							};
							break;
						case "importkey":
							result = {
								algorithm: {
									name: "RSA-OAEP",
									hash: {
										name: "SHA-256"
									}
								},
								usages: ["encrypt"] // encrypt for "spki" and decrypt for "pkcs8"
							};
							break;
						case "exportkey":
						default:
							return {
								algorithm: {
									name: "RSA-OAEP"
								},
								usages: []
							};
					}
					break;
				case "ECDSA":
					switch(operation.toLowerCase())
					{
						case "generatekey":
							result = {
								algorithm: {
									name: "ECDSA",
									namedCurve: "P-256"
								},
								usages: ["sign", "verify"]
							};
							break;
						case "importkey":
							result = {
								algorithm: {
									name: "ECDSA",
									namedCurve: "P-256"
								},
								usages: ["verify"] // "sign" for "pkcs8"
							};
							break;
						case "verify":
						case "sign":
							result = {
								algorithm: {
									name: "ECDSA",
									hash: {
										name: "SHA-256"
									}
								},
								usages: ["sign"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "ECDSA"
								},
								usages: []
							};
					}
					break;
				case "ECDH":
					switch(operation.toLowerCase())
					{
						case "exportkey":
						case "importkey":
						case "generatekey":
							result = {
								algorithm: {
									name: "ECDH",
									namedCurve: "P-256"
								},
								usages: ["deriveKey", "deriveBits"]
							};
							break;
						case "derivekey":
						case "derivebits":
							result = {
								algorithm: {
									name: "ECDH",
									namedCurve: "P-256",
									public: [] // Must be a "publicKey"
								},
								usages: ["encrypt", "decrypt"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "ECDH"
								},
								usages: []
							};
					}
					break;
				case "AES-CTR":
					switch(operation.toLowerCase())
					{
						case "importkey":
						case "exportkey":
						case "generatekey":
							result = {
								algorithm: {
									name: "AES-CTR",
									length: 256
								},
								usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
							};
							break;
						case "decrypt":
						case "encrypt":
							result = {
								algorithm: {
									name: "AES-CTR",
									counter: new Uint8Array(16),
									length: 10
								},
								usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "AES-CTR"
								},
								usages: []
							};
					}
					break;
				case "AES-CBC":
					switch(operation.toLowerCase())
					{
						case "importkey":
						case "exportkey":
						case "generatekey":
							result = {
								algorithm: {
									name: "AES-CBC",
									length: 256
								},
								usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
							};
							break;
						case "decrypt":
						case "encrypt":
							result = {
								algorithm: {
									name: "AES-CBC",
									iv: this.getRandomValues(new Uint8Array(16)) // For "decrypt" the value should be replaced with value got on "encrypt" step
								},
								usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "AES-CBC"
								},
								usages: []
							};
					}
					break;
				case "AES-GCM":
					switch(operation.toLowerCase())
					{
						case "importkey":
						case "exportkey":
						case "generatekey":
							result = {
								algorithm: {
									name: "AES-GCM",
									length: 256
								},
								usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
							};
							break;
						case "decrypt":
						case "encrypt":
							result = {
								algorithm: {
									name: "AES-GCM",
									iv: this.getRandomValues(new Uint8Array(16)) // For "decrypt" the value should be replaced with value got on "encrypt" step
								},
								usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "AES-GCM"
								},
								usages: []
							};
					}
					break;
				case "AES-KW":
					switch(operation.toLowerCase())
					{
						case "importkey":
						case "exportkey":
						case "generatekey":
						case "wrapkey":
						case "unwrapkey":
							result = {
								algorithm: {
									name: "AES-KW",
									length: 256
								},
								usages: ["wrapKey", "unwrapKey"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "AES-KW"
								},
								usages: []
							};
					}
					break;
				case "HMAC":
					switch(operation.toLowerCase())
					{
						case "sign":
						case "verify":
							result = {
								algorithm: {
									name: "HMAC"
								},
								usages: ["sign", "verify"]
							};
							break;
						case "importkey":
						case "exportkey":
						case "generatekey":
							result = {
								algorithm: {
									name: "HMAC",
									length: 32,
									hash: {
										name: "SHA-256"
									}
								},
								usages: ["sign", "verify"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "HMAC"
								},
								usages: []
							};
					}
					break;
				case "HKDF":
					switch(operation.toLowerCase())
					{
						case "derivekey":
							result = {
								algorithm: {
									name: "HKDF",
									hash: "SHA-256",
									salt: new Uint8Array([]),
									info: new Uint8Array([])
								},
								usages: ["encrypt", "decrypt"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "HKDF"
								},
								usages: []
							};
					}
					break;
				case "PBKDF2":
					switch(operation.toLowerCase())
					{
						case "derivekey":
							result = {
								algorithm: {
									name: "PBKDF2",
									hash: { name: "SHA-256" },
									salt: new Uint8Array([]),
									iterations: 10000
								},
								usages: ["encrypt", "decrypt"]
							};
							break;
						default:
							return {
								algorithm: {
									name: "PBKDF2"
								},
								usages: []
							};
					}
					break;
				default:
			}
			
			return result;
		}
		//**********************************************************************************
		/**
		 * Getting hash algorithm by signature algorithm
		 * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm
		 * @returns {string}
		 */
		getHashAlgorithm(signatureAlgorithm)
		{
			let result = "";
			
			switch(signatureAlgorithm.algorithmId)
			{
				case "1.2.840.10045.4.1": // ecdsa-with-SHA1
				case "1.2.840.113549.1.1.5":
					result = "SHA-1";
					break;
				case "1.2.840.10045.4.3.2": // ecdsa-with-SHA256
				case "1.2.840.113549.1.1.11":
					result = "SHA-256";
					break;
				case "1.2.840.10045.4.3.3": // ecdsa-with-SHA384
				case "1.2.840.113549.1.1.12":
					result = "SHA-384";
					break;
				case "1.2.840.10045.4.3.4": // ecdsa-with-SHA512
				case "1.2.840.113549.1.1.13":
					result = "SHA-512";
					break;
				case "1.2.840.113549.1.1.10": // RSA-PSS
					{
						try
						{
							const params = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
							if("hashAlgorithm" in params)
							{
								const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
								if(("name" in algorithm) === false)
									return "";
								
								result = algorithm.name;
							}
							else
								result = "SHA-1";
						}
						catch(ex)
						{
						}
					}
					break;
				default:
			}
			
			return result;
		}
		//**********************************************************************************
		/**
		 * Specialized function encrypting "EncryptedContentInfo" object using parameters
		 * @param {Object} parameters
		 * @returns {Promise}
		 */
		encryptEncryptedContentInfo(parameters)
		{
			//region Check for input parameters
			if((parameters instanceof Object) === false)
				return Promise.reject("Parameters must have type \"Object\"");
			
			if(("password" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"password\"");
			
			if(("contentEncryptionAlgorithm" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"contentEncryptionAlgorithm\"");
			
			if(("hmacHashAlgorithm" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"hmacHashAlgorithm\"");
			
			if(("iterationCount" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"iterationCount\"");
			
			if(("contentToEncrypt" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"contentToEncrypt\"");
			
			if(("contentType" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"contentType\"");

			const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);
			if(contentEncryptionOID === "")
				return Promise.reject("Wrong \"contentEncryptionAlgorithm\" value");
			
			const pbkdf2OID = this.getOIDByAlgorithm({
				name: "PBKDF2"
			});
			if(pbkdf2OID === "")
				return Promise.reject("Can not find OID for PBKDF2");
			
			const hmacOID = this.getOIDByAlgorithm({
				name: "HMAC",
				hash: {
					name: parameters.hmacHashAlgorithm
				}
			});
			if(hmacOID === "")
				return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${parameters.hmacHashAlgorithm}`);
			//endregion
			
			//region Initial variables
			let sequence = Promise.resolve();
			
			const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long
			const ivView = new Uint8Array(ivBuffer);
			this.getRandomValues(ivView);
			
			const saltBuffer = new ArrayBuffer(64);
			const saltView = new Uint8Array(saltBuffer);
			this.getRandomValues(saltView);
			
			const contentView = new Uint8Array(parameters.contentToEncrypt);
			
			const pbkdf2Params = new PBKDF2Params({
				salt: new OctetString$1({ valueHex: saltBuffer }),
				iterationCount: parameters.iterationCount,
				prf: new AlgorithmIdentifier$1({
					algorithmId: hmacOID,
					algorithmParams: new Null$1()
				})
			});
			//endregion
			
			//region Derive PBKDF2 key from "password" buffer
			sequence = sequence.then(() =>
			{
				const passwordView = new Uint8Array(parameters.password);
				
				return this.importKey("raw",
					passwordView,
					"PBKDF2",
					false,
					["deriveKey"]);
			}, error =>
				Promise.reject(error)
			);
			//endregion
			
			//region Derive key for "contentEncryptionAlgorithm"
			sequence = sequence.then(result =>
				this.deriveKey({
					name: "PBKDF2",
					hash: {
						name: parameters.hmacHashAlgorithm
					},
					salt: saltView,
					iterations: parameters.iterationCount
				},
				result,
				parameters.contentEncryptionAlgorithm,
				false,
				["encrypt"]),
			error =>
				Promise.reject(error)
			);
			//endregion
			
			//region Encrypt content
			sequence = sequence.then(result =>
				this.encrypt({
					name: parameters.contentEncryptionAlgorithm.name,
					iv: ivView
				},
				result,
				contentView),
			error =>
				Promise.reject(error)
			);
			//endregion
			
			//region Store all parameters in EncryptedData object
			sequence = sequence.then(result =>
			{
				const pbes2Parameters = new PBES2Params({
					keyDerivationFunc: new AlgorithmIdentifier$1({
						algorithmId: pbkdf2OID,
						algorithmParams: pbkdf2Params.toSchema()
					}),
					encryptionScheme: new AlgorithmIdentifier$1({
						algorithmId: contentEncryptionOID,
						algorithmParams: new OctetString$1({ valueHex: ivBuffer })
					})
				});
				
				return new EncryptedContentInfo({
					contentType: parameters.contentType,
					contentEncryptionAlgorithm: new AlgorithmIdentifier$1({
						algorithmId: "1.2.840.113549.1.5.13", // pkcs5PBES2
						algorithmParams: pbes2Parameters.toSchema()
					}),
					encryptedContent: new OctetString$1({ valueHex: result })
				});
			}, error =>
				Promise.reject(error)
			);
			//endregion

			return sequence;
		}
		//**********************************************************************************
		/**
		 * Decrypt data stored in "EncryptedContentInfo" object using parameters
		 * @param parameters
		 * @return {Promise}
		 */
		decryptEncryptedContentInfo(parameters)
		{
			//region Check for input parameters
			if((parameters instanceof Object) === false)
				return Promise.reject("Parameters must have type \"Object\"");
			
			if(("password" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"password\"");
			
			if(("encryptedContentInfo" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"encryptedContentInfo\"");

			if(parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13") // pkcs5PBES2
				return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
			//endregion
			
			//region Initial variables
			let sequence = Promise.resolve();
			
			let pbes2Parameters;
			
			try
			{
				pbes2Parameters = new PBES2Params({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });
			}
			catch(ex)
			{
				return Promise.reject("Incorrectly encoded \"pbes2Parameters\"");
			}
			
			let pbkdf2Params;
			
			try
			{
				pbkdf2Params = new PBKDF2Params({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });
			}
			catch(ex)
			{
				return Promise.reject("Incorrectly encoded \"pbkdf2Params\"");
			}
			
			const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);
			if(("name" in contentEncryptionAlgorithm) === false)
				return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${pbes2Parameters.encryptionScheme.algorithmId}`);
			
			const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
			const ivView = new Uint8Array(ivBuffer);
			
			const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
			const saltView = new Uint8Array(saltBuffer);
			
			const iterationCount = pbkdf2Params.iterationCount;
			
			let hmacHashAlgorithm = "SHA-1";
			
			if("prf" in pbkdf2Params)
			{
				const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
				if(("name" in algorithm) === false)
					return Promise.reject("Incorrect OID for HMAC hash algorithm");
				
				hmacHashAlgorithm = algorithm.hash.name;
			}
			//endregion
			
			//region Derive PBKDF2 key from "password" buffer
			sequence = sequence.then(() =>
				this.importKey("raw",
					parameters.password,
					"PBKDF2",
					false,
					["deriveKey"]),
			error =>
				Promise.reject(error)
			);
			//endregion
			
			//region Derive key for "contentEncryptionAlgorithm"
			sequence = sequence.then(result =>
				this.deriveKey({
					name: "PBKDF2",
					hash: {
						name: hmacHashAlgorithm
					},
					salt: saltView,
					iterations: iterationCount
				},
				result,
				contentEncryptionAlgorithm,
				false,
				["decrypt"]),
			error =>
				Promise.reject(error)
			);
			//endregion
			
			//region Decrypt internal content using derived key
			sequence = sequence.then(result =>
			{
				//region Create correct data block for decryption
				let dataBuffer = new ArrayBuffer(0);
				
				if(parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false)
					dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;
				else
				{
					for(const content of parameters.encryptedContentInfo.encryptedContent.valueBlock.value)
						dataBuffer = utilConcatBuf$2(dataBuffer, content.valueBlock.valueHex);
				}
				//endregion
				
				return this.decrypt({
					name: contentEncryptionAlgorithm.name,
					iv: ivView
				},
				result,
				dataBuffer);
			}, error =>
				Promise.reject(error)
			);
			//endregion
			
			return sequence;
		}
		//**********************************************************************************
		/**
		 * Stamping (signing) data using algorithm simular to HMAC
		 * @param {Object} parameters
		 * @return {Promise.<T>|Promise}
		 */
		stampDataWithPassword(parameters)
		{
			//region Check for input parameters
			if((parameters instanceof Object) === false)
				return Promise.reject("Parameters must have type \"Object\"");
			
			if(("password" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"password\"");
			
			if(("hashAlgorithm" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
			
			if(("salt" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"iterationCount\"");
			
			if(("iterationCount" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"salt\"");
			
			if(("contentToStamp" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"contentToStamp\"");
			//endregion
			
			//region Choose correct length for HMAC key
			let length;
			
			switch(parameters.hashAlgorithm.toLowerCase())
			{
				case "sha-1":
					length = 160;
					break;
				case "sha-256":
					length = 256;
					break;
				case "sha-384":
					length = 384;
					break;
				case "sha-512":
					length = 512;
					break;
				default:
					return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
			}
			//endregion
			
			//region Initial variables
			let sequence = Promise.resolve();
			
			const hmacAlgorithm = {
				name: "HMAC",
				length,
				hash: {
					name: parameters.hashAlgorithm
				}
			};
			//endregion

			//region Create PKCS#12 key for integrity checking
			sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
			//endregion
			
			//region Import HMAC key
			// noinspection JSCheckFunctionSignatures
			sequence = sequence.then(
				result =>
					this.importKey("raw",
						new Uint8Array(result),
						hmacAlgorithm,
						false,
						["sign"])
			);
			//endregion
			
			//region Make signed HMAC value
			sequence = sequence.then(
				result =>
					this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp)),
				error => Promise.reject(error)
			);
			//endregion

			return sequence;
		}
		//**********************************************************************************
		verifyDataStampedWithPassword(parameters)
		{
			//region Check for input parameters
			if((parameters instanceof Object) === false)
				return Promise.reject("Parameters must have type \"Object\"");
			
			if(("password" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"password\"");
			
			if(("hashAlgorithm" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
			
			if(("salt" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"iterationCount\"");
			
			if(("iterationCount" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"salt\"");
			
			if(("contentToVerify" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"contentToVerify\"");
			
			if(("signatureToVerify" in parameters) === false)
				return Promise.reject("Absent mandatory parameter \"signatureToVerify\"");
			//endregion
			
			//region Choose correct length for HMAC key
			let length;
			
			switch(parameters.hashAlgorithm.toLowerCase())
			{
				case "sha-1":
					length = 160;
					break;
				case "sha-256":
					length = 256;
					break;
				case "sha-384":
					length = 384;
					break;
				case "sha-512":
					length = 512;
					break;
				default:
					return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
			}
			//endregion
			
			//region Initial variables
			let sequence = Promise.resolve();
			
			const hmacAlgorithm = {
				name: "HMAC",
				length,
				hash: {
					name: parameters.hashAlgorithm
				}
			};
			//endregion
			
			//region Create PKCS#12 key for integrity checking
			sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
			//endregion
			
			//region Import HMAC key
			// noinspection JSCheckFunctionSignatures
			sequence = sequence.then(result =>
				this.importKey("raw",
					new Uint8Array(result),
					hmacAlgorithm,
					false,
					["verify"])
			);
			//endregion
			
			//region Make signed HMAC value
			sequence = sequence.then(
				result =>
					this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)),
				error => Promise.reject(error)
			);
			//endregion
			
			return sequence;
		}
		//**********************************************************************************
		/**
		 * Get signature parameters by analyzing private key algorithm
		 * @param {Object} privateKey The private key user would like to use
		 * @param {string} [hashAlgorithm="SHA-1"] Hash algorithm user would like to use
		 * @return {Promise.<T>|Promise}
		 */
		getSignatureParameters(privateKey, hashAlgorithm = "SHA-1")
		{
			//region Check hashing algorithm
			const oid = this.getOIDByAlgorithm({ name: hashAlgorithm });
			if(oid === "")
				return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
			//endregion
			
			//region Initial variables
			const signatureAlgorithm = new AlgorithmIdentifier$1();
			//endregion
			
			//region Get a "default parameters" for current algorithm
			const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
			parameters.algorithm.hash.name = hashAlgorithm;
			//endregion
			
			//region Fill internal structures base on "privateKey" and "hashAlgorithm"
			switch(privateKey.algorithm.name.toUpperCase())
			{
				case "RSASSA-PKCS1-V1_5":
				case "ECDSA":
					signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);
					break;
				case "RSA-PSS":
					{
						//region Set "saltLength" as a length (in octets) of hash function result
						switch(hashAlgorithm.toUpperCase())
						{
							case "SHA-256":
								parameters.algorithm.saltLength = 32;
								break;
							case "SHA-384":
								parameters.algorithm.saltLength = 48;
								break;
							case "SHA-512":
								parameters.algorithm.saltLength = 64;
								break;
							default:
						}
						//endregion
						
						//region Fill "RSASSA_PSS_params" object
						const paramsObject = {};
						
						if(hashAlgorithm.toUpperCase() !== "SHA-1")
						{
							const hashAlgorithmOID = this.getOIDByAlgorithm({ name: hashAlgorithm });
							if(hashAlgorithmOID === "")
								return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
							
							paramsObject.hashAlgorithm = new AlgorithmIdentifier$1({
								algorithmId: hashAlgorithmOID,
								algorithmParams: new Null$1()
							});
							
							paramsObject.maskGenAlgorithm = new AlgorithmIdentifier$1({
								algorithmId: "1.2.840.113549.1.1.8", // MGF1
								algorithmParams: paramsObject.hashAlgorithm.toSchema()
							});
						}
						
						if(parameters.algorithm.saltLength !== 20)
							paramsObject.saltLength = parameters.algorithm.saltLength;
						
						const pssParameters = new RSASSAPSSParams(paramsObject);
						//endregion
						
						//region Automatically set signature algorithm
						signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
						signatureAlgorithm.algorithmParams = pssParameters.toSchema();
						//endregion
					}
					break;
				default:
					return Promise.reject(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
			}
			//endregion

			return Promise.resolve().then(() => ({
				signatureAlgorithm,
				parameters
			}));
		}
		//**********************************************************************************
		/**
		 * Sign data with pre-defined private key
		 * @param {ArrayBuffer} data Data to be signed
		 * @param {Object} privateKey Private key to use
		 * @param {Object} parameters Parameters for used algorithm
		 * @return {Promise.<T>|Promise}
		 */
		signWithPrivateKey(data, privateKey, parameters)
		{
			return this.sign(parameters.algorithm,
				privateKey,
				new Uint8Array(data))
				.then(result =>
				{
					//region Special case for ECDSA algorithm
					if(parameters.algorithm.name === "ECDSA")
						result = createCMSECDSASignature(result);
					//endregion
					
					return result;
				}, error =>
					Promise.reject(`Signing error: ${error}`)
				);
		}
		//**********************************************************************************
		fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm)
		{
			const parameters = {};
			
			//region Find signer's hashing algorithm
			const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
			if(shaAlgorithm === "")
				return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
			//endregion
			
			//region Get information about public key algorithm and default parameters for import
			let algorithmId;
			if(signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
				algorithmId = signatureAlgorithm.algorithmId;
			else
				algorithmId = publicKeyInfo.algorithm.algorithmId;
			
			const algorithmObject = this.getAlgorithmByOID(algorithmId);
			if(("name" in algorithmObject) === "")
				return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
			
			parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
			if("hash" in parameters.algorithm.algorithm)
				parameters.algorithm.algorithm.hash.name = shaAlgorithm;
			
			//region Special case for ECDSA
			if(algorithmObject.name === "ECDSA")
			{
				//region Get information about named curve
				let algorithmParamsChecked = false;
				
				if(("algorithmParams" in publicKeyInfo.algorithm) === true)
				{
					if("idBlock" in publicKeyInfo.algorithm.algorithmParams)
					{
						if((publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1) && (publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6))
							algorithmParamsChecked = true;
					}
				}
				
				if(algorithmParamsChecked === false)
					return Promise.reject("Incorrect type for ECDSA public key parameters");
				
				const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
				if(("name" in curveObject) === false)
					return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
				//endregion
				
				parameters.algorithm.algorithm.namedCurve = curveObject.name;
			}
			//endregion
			//endregion
			
			return parameters;
		}
		//**********************************************************************************
		getPublicKey(publicKeyInfo, signatureAlgorithm, parameters = null)
		{
			if(parameters === null)
				parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
			
			const publicKeyInfoSchema = publicKeyInfo.toSchema();
			const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
			const publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);
			
			return this.importKey("spki",
				publicKeyInfoView,
				parameters.algorithm.algorithm,
				true,
				parameters.algorithm.usages
			);
		}
		//**********************************************************************************
		verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm = null)
		{
			//region Initial variables
			let sequence = Promise.resolve();
			//endregion
			
			//region Find signer's hashing algorithm
			if(shaAlgorithm === null)
			{
				shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
				if(shaAlgorithm === "")
					return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
				
				//region Import public key
				sequence = sequence.then(() =>
					this.getPublicKey(publicKeyInfo, signatureAlgorithm));
				//endregion
			}
			else
			{
				const parameters = {};
				
				//region Get information about public key algorithm and default parameters for import
				let algorithmId;
				if(signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
					algorithmId = signatureAlgorithm.algorithmId;
				else
					algorithmId = publicKeyInfo.algorithm.algorithmId;
				
				const algorithmObject = this.getAlgorithmByOID(algorithmId);
				if(("name" in algorithmObject) === "")
					return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
				
				parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
				if("hash" in parameters.algorithm.algorithm)
					parameters.algorithm.algorithm.hash.name = shaAlgorithm;
				
				//region Special case for ECDSA
				if(algorithmObject.name === "ECDSA")
				{
					//region Get information about named curve
					let algorithmParamsChecked = false;
					
					if(("algorithmParams" in publicKeyInfo.algorithm) === true)
					{
						if("idBlock" in publicKeyInfo.algorithm.algorithmParams)
						{
							if((publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1) && (publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6))
								algorithmParamsChecked = true;
						}
					}
					
					if(algorithmParamsChecked === false)
						return Promise.reject("Incorrect type for ECDSA public key parameters");
					
					const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
					if(("name" in curveObject) === false)
						return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
					//endregion
					
					parameters.algorithm.algorithm.namedCurve = curveObject.name;
				}
				//endregion
				//endregion

				//region Import public key
				sequence = sequence.then(() =>
					this.getPublicKey(publicKeyInfo, null, parameters));
				//endregion
			}
			//endregion
			
			//region Verify signature
			sequence = sequence.then(publicKey =>
			{
				//region Get default algorithm parameters for verification
				const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
				if("hash" in algorithm.algorithm)
					algorithm.algorithm.hash.name = shaAlgorithm;
				//endregion
				
				//region Special case for ECDSA signatures
				let signatureValue = signature.valueBlock.valueHex;
				
				if(publicKey.algorithm.name === "ECDSA")
				{
					const asn1 = fromBER$1(signatureValue);
					// noinspection JSCheckFunctionSignatures
					signatureValue = createECDSASignatureFromCMS(asn1.result);
				}
				//endregion
				
				//region Special case for RSA-PSS
				if(publicKey.algorithm.name === "RSA-PSS")
				{
					let pssParameters;
					
					try
					{
						pssParameters = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
					}
					catch(ex)
					{
						return Promise.reject(ex);
					}
					
					if("saltLength" in pssParameters)
						algorithm.algorithm.saltLength = pssParameters.saltLength;
					else
						algorithm.algorithm.saltLength = 20;
					
					let hashAlgo = "SHA-1";
					
					if("hashAlgorithm" in pssParameters)
					{
						const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);
						if(("name" in hashAlgorithm) === false)
							return Promise.reject(`Unrecognized hash algorithm: ${pssParameters.hashAlgorithm.algorithmId}`);
						
						hashAlgo = hashAlgorithm.name;
					}
					
					algorithm.algorithm.hash.name = hashAlgo;
				}
				//endregion
				
				return this.verify(algorithm.algorithm,
					publicKey,
					new Uint8Array(signatureValue),
					new Uint8Array(data)
				);
			});
			//endregion
			
			return sequence;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	//region Crypto engine related function
	//**************************************************************************************
	let engine = {
		name: "none",
		crypto: null,
		subtle: null
	};
	//**************************************************************************************
	function setEngine(name, crypto, subtle)
	{
		//region We are in Node
		// noinspection JSUnresolvedVariable
		if((typeof process !== "undefined") && ("pid" in process) && (typeof global !== "undefined") && (typeof window === "undefined"))
		{
			// noinspection ES6ModulesDependencies, JSUnresolvedVariable
			if(typeof global[process.pid] === "undefined")
			{
				// noinspection JSUnresolvedVariable
				global[process.pid] = {};
			}
			else
			{
				// noinspection JSUnresolvedVariable
				if(typeof global[process.pid] !== "object")
				{
					// noinspection JSUnresolvedVariable
					throw new Error(`Name global.${process.pid} already exists and it is not an object`);
				}
			}
			
			// noinspection JSUnresolvedVariable
			if(typeof global[process.pid].pkijs === "undefined")
			{
				// noinspection JSUnresolvedVariable
				global[process.pid].pkijs = {};
			}
			else
			{
				// noinspection JSUnresolvedVariable
				if(typeof global[process.pid].pkijs !== "object")
				{
					// noinspection JSUnresolvedVariable
					throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);
				}
			}
			
			// noinspection JSUnresolvedVariable
			global[process.pid].pkijs.engine = {
				name: name,
				crypto: crypto,
				subtle: subtle
			};
		}
		//endregion
		//region We are in browser
		else
		{
			engine = {
				name: name,
				crypto: crypto,
				subtle: subtle
			};
		}
		//endregion
	}
	//**************************************************************************************
	function getEngine()
	{
		//region We are in Node
		// noinspection JSUnresolvedVariable
		if((typeof process !== "undefined") && ("pid" in process) && (typeof global !== "undefined") && (typeof window === "undefined"))
		{
			let _engine;
			
			try
			{
				// noinspection JSUnresolvedVariable
				_engine = global[process.pid].pkijs.engine;
			}
			catch(ex)
			{
				throw new Error("Please call \"setEngine\" before call to \"getEngine\"");
			}
			
			return _engine;
		}
		//endregion
		
		return engine;
	}
	//**************************************************************************************
	(function initCryptoEngine()
	{
		if(typeof self !== "undefined")
		{
			if("crypto" in self)
			{
				let engineName = "webcrypto";
				
				/**
				 * Standard crypto object
				 * @type {Object}
				 * @property {Object} [webkitSubtle] Subtle object from Apple
				 */
				const cryptoObject = self.crypto;
				let subtleObject;
				
				// Apple Safari support
				if("webkitSubtle" in self.crypto)
				{
					try
					{
						subtleObject = self.crypto.webkitSubtle;
					}
					catch(ex)
					{
						subtleObject = self.crypto.subtle;
					}
					
					engineName = "safari";
				}
				
				if("subtle" in self.crypto)
					subtleObject = self.crypto.subtle;


				if(typeof subtleObject === "undefined")
				{
					engine = {
						name: engineName,
						crypto: cryptoObject,
						subtle: null
					};
				}
				else
				{
					engine = {
						name: engineName,
						crypto: cryptoObject,
						subtle: new CryptoEngine({name: engineName, crypto: self.crypto, subtle: subtleObject})
					};
				}
			}
		}
		
		setEngine(engine.name, engine.crypto, engine.subtle);
	})();
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	//region Declaration of common functions
	//**************************************************************************************
	/**
	 * Get crypto subtle from current "crypto engine" or "undefined"
	 * @returns {({decrypt, deriveKey, digest, encrypt, exportKey, generateKey, importKey, sign, unwrapKey, verify, wrapKey}|null)}
	 */
	function getCrypto()
	{
		const _engine = getEngine();
		
		if(_engine.subtle !== null)
			return _engine.subtle;
		
		return undefined;
	}
	//**************************************************************************************
	/**
	 * Get default algorithm parameters for each kind of operation
	 * @param {string} algorithmName Algorithm name to get common parameters for
	 * @param {string} operation Kind of operation: "sign", "encrypt", "generatekey", "importkey", "exportkey", "verify"
	 * @returns {*}
	 */
	function getAlgorithmParameters(algorithmName, operation)
	{
		return getEngine().subtle.getAlgorithmParameters(algorithmName, operation);
	}
	//**************************************************************************************
	/**
	 * Create CMS ECDSA signature from WebCrypto ECDSA signature
	 * @param {ArrayBuffer} signatureBuffer WebCrypto result of "sign" function
	 * @returns {ArrayBuffer}
	 */
	function createCMSECDSASignature(signatureBuffer)
	{
		//region Initial check for correct length
		if((signatureBuffer.byteLength % 2) !== 0)
			return new ArrayBuffer(0);
		//endregion
		
		//region Initial variables
		const length = signatureBuffer.byteLength / 2; // There are two equal parts inside incoming ArrayBuffer
		
		const rBuffer = new ArrayBuffer(length);
		const rView = new Uint8Array(rBuffer);
		rView.set(new Uint8Array(signatureBuffer, 0, length));
		
		const rInteger = new Integer$1({ valueHex: rBuffer });
		
		const sBuffer = new ArrayBuffer(length);
		const sView = new Uint8Array(sBuffer);
		sView.set(new Uint8Array(signatureBuffer, length, length));
		
		const sInteger = new Integer$1({ valueHex: sBuffer });
		//endregion
		
		return (new Sequence$1({
			value: [
				rInteger.convertToDER(),
				sInteger.convertToDER()
			]
		})).toBER(false);
	}
	//**************************************************************************************
	/**
	 * String preparation function. In a future here will be realization of algorithm from RFC4518
	 * @param {string} inputString JavaScript string. As soon as for each ASN.1 string type we have a specific transformation function here we will work with pure JavaScript string
	 * @returns {string} Formated string
	 */
	function stringPrep(inputString)
	{
		//region Initial variables
		let isSpace = false;
		let cuttedResult = "";
		//endregion
		
		const result = inputString.trim(); // Trim input string
		
		//region Change all sequence of SPACE down to SPACE char
		for(let i = 0; i < result.length; i++)
		{
			if(result.charCodeAt(i) === 32)
			{
				if(isSpace === false)
					isSpace = true;
			}
			else
			{
				if(isSpace)
				{
					cuttedResult += " ";
					isSpace = false;
				}
				
				cuttedResult += result[i];
			}
		}
		//endregion
		
		return cuttedResult.toLowerCase();
	}
	//**************************************************************************************
	/**
	 * Create a single ArrayBuffer from CMS ECDSA signature
	 * @param {Sequence} cmsSignature ASN.1 SEQUENCE contains CMS ECDSA signature
	 * @returns {ArrayBuffer}
	 */
	function createECDSASignatureFromCMS(cmsSignature)
	{
		//region Check input variables
		if((cmsSignature instanceof Sequence$1) === false)
			return new ArrayBuffer(0);
		
		if(cmsSignature.valueBlock.value.length !== 2)
			return new ArrayBuffer(0);
		
		if((cmsSignature.valueBlock.value[0] instanceof Integer$1) === false)
			return new ArrayBuffer(0);
		
		if((cmsSignature.valueBlock.value[1] instanceof Integer$1) === false)
			return new ArrayBuffer(0);
		//endregion
		
		const rValue = cmsSignature.valueBlock.value[0].convertFromDER();
		const sValue = cmsSignature.valueBlock.value[1].convertFromDER();
		
		//region Check the lengths of two parts are equal
		switch(true)
		{
			case (rValue.valueBlock.valueHex.byteLength < sValue.valueBlock.valueHex.byteLength):
				{
					if((sValue.valueBlock.valueHex.byteLength - rValue.valueBlock.valueHex.byteLength) !== 1)
						throw new Error("Incorrect DER integer decoding");
					
					const correctedLength = sValue.valueBlock.valueHex.byteLength;
					
					const rValueView = new Uint8Array(rValue.valueBlock.valueHex);
					
					const rValueBufferCorrected = new ArrayBuffer(correctedLength);
					const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);
					
					rValueViewCorrected.set(rValueView, 1);
					rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
					
					return utilConcatBuf$2(rValueBufferCorrected, sValue.valueBlock.valueHex);
				}
			case (rValue.valueBlock.valueHex.byteLength > sValue.valueBlock.valueHex.byteLength):
				{
					if((rValue.valueBlock.valueHex.byteLength - sValue.valueBlock.valueHex.byteLength) !== 1)
						throw new Error("Incorrect DER integer decoding");
					
					const correctedLength = rValue.valueBlock.valueHex.byteLength;
					
					const sValueView = new Uint8Array(sValue.valueBlock.valueHex);
					
					const sValueBufferCorrected = new ArrayBuffer(correctedLength);
					const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);
					
					sValueViewCorrected.set(sValueView, 1);
					sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
					
					return utilConcatBuf$2(rValue.valueBlock.valueHex, sValueBufferCorrected);
				}
			default:
				{
					//region In case we have equal length and the length is not even with 2
					if(rValue.valueBlock.valueHex.byteLength % 2)
					{
						const correctedLength = (rValue.valueBlock.valueHex.byteLength + 1);
						
						const rValueView = new Uint8Array(rValue.valueBlock.valueHex);
						
						const rValueBufferCorrected = new ArrayBuffer(correctedLength);
						const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);
						
						rValueViewCorrected.set(rValueView, 1);
						rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
						
						const sValueView = new Uint8Array(sValue.valueBlock.valueHex);
						
						const sValueBufferCorrected = new ArrayBuffer(correctedLength);
						const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);
						
						sValueViewCorrected.set(sValueView, 1);
						sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
						
						return utilConcatBuf$2(rValueBufferCorrected, sValueBufferCorrected);
					}
					//endregion
				}
		}
		//endregion
		
		return utilConcatBuf$2(rValue.valueBlock.valueHex, sValue.valueBlock.valueHex);
	}
	//**************************************************************************************
	/**
	 * Get WebCrypto algorithm by wel-known OID
	 * @param {string} oid well-known OID to search for
	 * @returns {Object}
	 */
	function getAlgorithmByOID(oid)
	{
		return getEngine().subtle.getAlgorithmByOID(oid);
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class AttributeTypeAndValue
	{
		//**********************************************************************************
		/**
		 * Constructor for AttributeTypeAndValue class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc type
			 */
			this.type = getParametersValue$2(parameters, "type", AttributeTypeAndValue.defaultValues("type"));
			/**
			 * @type {Object}
			 * @desc Value of the AttributeTypeAndValue class
			 */
			this.value = getParametersValue$2(parameters, "value", AttributeTypeAndValue.defaultValues("value"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "type":
					return "";
				case "value":
					return {};
				default:
					throw new Error(`Invalid member name for AttributeTypeAndValue class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * AttributeTypeAndValue ::= Sequence {
		 *    type     AttributeType,
		 *    value    AttributeValue }
		 *
		 * AttributeType ::= OBJECT IDENTIFIER
		 *
		 * AttributeValue ::= ANY -- DEFINED BY AttributeType
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName] Name for entire block
			 * @property {string} [type] Name for "type" element
			 * @property {string} [value] Name for "value" element
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.type || "") }),
					new Any({ name: (names.value || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"type",
				"typeValue"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				AttributeTypeAndValue.schema({
					names: {
						type: "type",
						value: "typeValue"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");
			//endregion

			//region Get internal properties from parsed schema
			this.type = asn1.result.type.valueBlock.toString();
			// noinspection JSUnresolvedVariable
			this.value = asn1.result.typeValue;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					new ObjectIdentifier$2({ value: this.type }),
					this.value
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const _object = {
				type: this.type
			};

			if(Object.keys(this.value).length !== 0)
				_object.value = this.value.toJSON();
			else
				_object.value = this.value;

			return _object;
		}
		//**********************************************************************************
		/**
		 * Compare two AttributeTypeAndValue values, or AttributeTypeAndValue with ArrayBuffer value
		 * @param {(AttributeTypeAndValue|ArrayBuffer)} compareTo The value compare to current
		 * @returns {boolean}
		 */
		isEqual(compareTo)
		{
			if(compareTo instanceof AttributeTypeAndValue)
			{
				if(this.type !== compareTo.type)
					return false;
				
				// noinspection OverlyComplexBooleanExpressionJS
				if(((this.value instanceof Utf8String$1) && (compareTo.value instanceof Utf8String$1)) ||
					((this.value instanceof BmpString$1) && (compareTo.value instanceof BmpString$1)) ||
					((this.value instanceof UniversalString$1) && (compareTo.value instanceof UniversalString$1)) ||
					((this.value instanceof NumericString$1) && (compareTo.value instanceof NumericString$1)) ||
					((this.value instanceof PrintableString$1) && (compareTo.value instanceof PrintableString$1)) ||
					((this.value instanceof TeletexString$1) && (compareTo.value instanceof TeletexString$1)) ||
					((this.value instanceof VideotexString$1) && (compareTo.value instanceof VideotexString$1)) ||
					((this.value instanceof IA5String$1) && (compareTo.value instanceof IA5String$1)) ||
					((this.value instanceof GraphicString$1) && (compareTo.value instanceof GraphicString$1)) ||
					((this.value instanceof VisibleString$1) && (compareTo.value instanceof VisibleString$1)) ||
					((this.value instanceof GeneralString$1) && (compareTo.value instanceof GeneralString$1)) ||
					((this.value instanceof CharacterString$1) && (compareTo.value instanceof CharacterString$1)))
				{
					const value1 = stringPrep(this.value.valueBlock.value);
					const value2 = stringPrep(compareTo.value.valueBlock.value);
					
					if(value1.localeCompare(value2) !== 0)
						return false;
				}
				else // Comparing as two ArrayBuffers
				{
					if(isEqualBuffer$2(this.value.valueBeforeDecode, compareTo.value.valueBeforeDecode) === false)
						return false;
				}
				
				return true;
			}
			
			if(compareTo instanceof ArrayBuffer)
				return isEqualBuffer$2(this.value.valueBeforeDecode, compareTo);

			return false;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class RelativeDistinguishedNames
	{
		//**********************************************************************************
		/**
		 * Constructor for RelativeDistinguishedNames class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 * @property {Array.<AttributeTypeAndValue>} [typesAndValues] Array of "type and value" objects
		 * @property {ArrayBuffer} [valueBeforeDecode] Value of the RDN before decoding from schema
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<AttributeTypeAndValue>}
			 * @desc Array of "type and value" objects
			 */
			this.typesAndValues = getParametersValue$2(parameters, "typesAndValues", RelativeDistinguishedNames.defaultValues("typesAndValues"));
			/**
			 * @type {ArrayBuffer}
			 * @desc Value of the RDN before decoding from schema
			 */
			this.valueBeforeDecode = getParametersValue$2(parameters, "valueBeforeDecode", RelativeDistinguishedNames.defaultValues("valueBeforeDecode"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "typesAndValues":
					return [];
				case "valueBeforeDecode":
					return new ArrayBuffer(0);
				default:
					throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "typesAndValues":
					return (memberValue.length === 0);
				case "valueBeforeDecode":
					return (memberValue.byteLength === 0);
				default:
					throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * RDNSequence ::= Sequence OF RelativeDistinguishedName
		 *
		 * RelativeDistinguishedName ::=
		 * SET SIZE (1..MAX) OF AttributeTypeAndValue
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName] Name for entire block
			 * @property {string} [repeatedSequence] Name for "repeatedSequence" block
			 * @property {string} [repeatedSet] Name for "repeatedSet" block
			 * @property {string} [typeAndValue] Name for "typeAndValue" block
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.repeatedSequence || ""),
						value: new Set$1({
							value: [
								new Repeated({
									name: (names.repeatedSet || ""),
									value: AttributeTypeAndValue.schema(names.typeAndValue || {})
								})
							]
						})
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"RDN",
				"typesAndValues"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				RelativeDistinguishedNames.schema({
					names: {
						blockName: "RDN",
						repeatedSet: "typesAndValues"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");
			//endregion

			//region Get internal properties from parsed schema
			if("typesAndValues" in asn1.result) // Could be a case when there is no "types and values"
				this.typesAndValues = Array.from(asn1.result.typesAndValues, element => new AttributeTypeAndValue({ schema: element }));

			// noinspection JSUnresolvedVariable
			this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecode;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Decode stored TBS value
			if(this.valueBeforeDecode.byteLength === 0) // No stored encoded array, create "from scratch"
			{
				return (new Sequence$1({
					value: [new Set$1({
						value: Array.from(this.typesAndValues, element => element.toSchema())
					})]
				}));
			}

			const asn1 = fromBER$1(this.valueBeforeDecode);
			//endregion

			//region Construct and return new ASN.1 schema for this object
			return asn1.result;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				typesAndValues: Array.from(this.typesAndValues, element => element.toJSON())
			};
		}
		//**********************************************************************************
		/**
		 * Compare two RDN values, or RDN with ArrayBuffer value
		 * @param {(RelativeDistinguishedNames|ArrayBuffer)} compareTo The value compare to current
		 * @returns {boolean}
		 */
		isEqual(compareTo)
		{
			if(compareTo instanceof RelativeDistinguishedNames)
			{
				if(this.typesAndValues.length !== compareTo.typesAndValues.length)
					return false;

				for(const [index, typeAndValue] of this.typesAndValues.entries())
				{
					if(typeAndValue.isEqual(compareTo.typesAndValues[index]) === false)
						return false;
				}

				return true;
			}

			if(compareTo instanceof ArrayBuffer)
				return isEqualBuffer$2(this.valueBeforeDecode, compareTo);

			return false;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class Time
	{
		//**********************************************************************************
		/**
		 * Constructor for Time class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 * @property {number} [type] 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value
		 * @property {Date} [value] Value of the TIME class
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {number}
			 * @desc 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value
			 */
			this.type = getParametersValue$2(parameters, "type", Time.defaultValues("type"));
			/**
			 * @type {Date}
			 * @desc Value of the TIME class
			 */
			this.value = getParametersValue$2(parameters, "value", Time.defaultValues("value"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "type":
					return 0;
				case "value":
					return new Date(0, 0, 0);
				default:
					throw new Error(`Invalid member name for Time class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * Time ::= CHOICE {
	     *   utcTime        UTCTime,
	     *   generalTime    GeneralizedTime }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @param {boolean} optional Flag that current schema should be optional
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {}, optional = false)
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [utcTimeName] Name for "utcTimeName" choice
			 * @property {string} [generalTimeName] Name for "generalTimeName" choice
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Choice({
				optional,
				value: [
					new UTCTime$1({ name: (names.utcTimeName || "") }),
					new GeneralizedTime$1({ name: (names.generalTimeName || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"utcTimeName",
				"generalTimeName"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema, schema, Time.schema({
				names: {
					utcTimeName: "utcTimeName",
					generalTimeName: "generalTimeName"
				}
			}));

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for Time");
			//endregion

			//region Get internal properties from parsed schema
			if("utcTimeName" in asn1.result)
			{
				this.type = 0;
				this.value = asn1.result.utcTimeName.toDate();
			}
			if("generalTimeName" in asn1.result)
			{
				this.type = 1;
				this.value = asn1.result.generalTimeName.toDate();
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			let result = {};

			if(this.type === 0)
				result = new UTCTime$1({ valueDate: this.value });
			if(this.type === 1)
				result = new GeneralizedTime$1({ valueDate: this.value });

			return result;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				type: this.type,
				value: this.value
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class SubjectDirectoryAttributes
	{
		//**********************************************************************************
		/**
		 * Constructor for SubjectDirectoryAttributes class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<Attribute>}
			 * @desc attributes
			 */
			this.attributes = getParametersValue$2(parameters, "attributes", SubjectDirectoryAttributes.defaultValues("attributes"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "attributes":
					return [];
				default:
					throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * SubjectDirectoryAttributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [utcTimeName] Name for "utcTimeName" choice
			 * @property {string} [generalTimeName] Name for "generalTimeName" choice
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.attributes || ""),
						value: Attribute.schema()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"attributes"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				SubjectDirectoryAttributes.schema({
					names: {
						attributes: "attributes"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");
			//endregion

			//region Get internal properties from parsed schema
			this.attributes = Array.from(asn1.result.attributes, element => new Attribute({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.attributes, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				attributes: Array.from(this.attributes, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class PrivateKeyUsagePeriod
	{
		//**********************************************************************************
		/**
		 * Constructor for PrivateKeyUsagePeriod class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			if("notBefore" in parameters)
				/**
				 * @type {Date}
				 * @desc notBefore
				 */
				this.notBefore = getParametersValue$2(parameters, "notBefore", PrivateKeyUsagePeriod.defaultValues("notBefore"));

			if("notAfter" in parameters)
				/**
				 * @type {Date}
				 * @desc notAfter
				 */
				this.notAfter = getParametersValue$2(parameters, "notAfter", PrivateKeyUsagePeriod.defaultValues("notAfter"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "notBefore":
					return new Date();
				case "notAfter":
					return new Date();
				default:
					throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PrivateKeyUsagePeriod OID ::= 2.5.29.16
		 *
		 * PrivateKeyUsagePeriod ::= SEQUENCE {
		 *    notBefore       [0]     GeneralizedTime OPTIONAL,
		 *    notAfter        [1]     GeneralizedTime OPTIONAL }
		 * -- either notBefore or notAfter MUST be present
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [notBefore]
			 * @property {string} [notAfter]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Primitive$1({
						name: (names.notBefore || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						}
					}),
					new Primitive$1({
						name: (names.notAfter || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						}
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"notBefore",
				"notAfter"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PrivateKeyUsagePeriod.schema({
					names: {
						notBefore: "notBefore",
						notAfter: "notAfter"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");
			//endregion

			//region Get internal properties from parsed schema
			if("notBefore" in asn1.result)
			{
				const localNotBefore = new GeneralizedTime$1();
				localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
				this.notBefore = localNotBefore.toDate();
			}

			if("notAfter" in asn1.result)
			{
				const localNotAfter = new GeneralizedTime$1({ valueHex: asn1.result.notAfter.valueBlock.valueHex });
				localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
				this.notAfter = localNotAfter.toDate();
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if("notBefore" in this)
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					valueHex: (new GeneralizedTime$1({ valueDate: this.notBefore })).valueBlock.valueHex
				}));
			}
			
			if("notAfter" in this)
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					valueHex: (new GeneralizedTime$1({ valueDate: this.notAfter })).valueBlock.valueHex
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};

			if("notBefore" in this)
				object.notBefore = this.notBefore;

			if("notAfter" in this)
				object.notAfter = this.notAfter;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	//region Additional asn1js schema elements existing inside GeneralName schema
	//**************************************************************************************
	/**
	 * Schema for "builtInStandardAttributes" of "ORAddress"
	 * @param {Object} parameters
	 * @property {Object} [names]
	 * @param {boolean} optional
	 * @returns {Sequence}
	 */
	function builtInStandardAttributes(parameters = {}, optional = false)
	{
		//builtInStandardAttributes ::= Sequence {
		//    country-name                  CountryName OPTIONAL,
		//    administration-domain-name    AdministrationDomainName OPTIONAL,
		//    network-address           [0] IMPLICIT NetworkAddress OPTIONAL,
		//    terminal-identifier       [1] IMPLICIT TerminalIdentifier OPTIONAL,
		//    private-domain-name       [2] PrivateDomainName OPTIONAL,
		//    organization-name         [3] IMPLICIT OrganizationName OPTIONAL,
		//    numeric-user-identifier   [4] IMPLICIT NumericUserIdentifier OPTIONAL,
		//    personal-name             [5] IMPLICIT PersonalName OPTIONAL,
		//    organizational-unit-names [6] IMPLICIT OrganizationalUnitNames OPTIONAL }

		/**
		 * @type {Object}
		 * @property {string} [country_name]
		 * @property {string} [administration_domain_name]
		 * @property {string} [network_address]
		 * @property {string} [terminal_identifier]
		 * @property {string} [private_domain_name]
		 * @property {string} [organization_name]
		 * @property {string} [numeric_user_identifier]
		 * @property {string} [personal_name]
		 * @property {string} [organizational_unit_names]
		 */
		const names = getParametersValue$2(parameters, "names", {});

		return (new Sequence$1({
			optional,
			value: [
				new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 2, // APPLICATION-SPECIFIC
						tagNumber: 1 // [1]
					},
					name: (names.country_name || ""),
					value: [
						new Choice({
							value: [
								new NumericString$1(),
								new PrintableString$1()
							]
						})
					]
				}),
				new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 2, // APPLICATION-SPECIFIC
						tagNumber: 2 // [2]
					},
					name: (names.administration_domain_name || ""),
					value: [
						new Choice({
							value: [
								new NumericString$1(),
								new PrintableString$1()
							]
						})
					]
				}),
				new Primitive$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					name: (names.network_address || ""),
					isHexOnly: true
				}),
				new Primitive$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					name: (names.terminal_identifier || ""),
					isHexOnly: true
				}),
				new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					name: (names.private_domain_name || ""),
					value: [
						new Choice({
							value: [
								new NumericString$1(),
								new PrintableString$1()
							]
						})
					]
				}),
				new Primitive$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					name: (names.organization_name || ""),
					isHexOnly: true
				}),
				new Primitive$1({
					optional: true,
					name: (names.numeric_user_identifier || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 4 // [4]
					},
					isHexOnly: true
				}),
				new Constructed$1({
					optional: true,
					name: (names.personal_name || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 5 // [5]
					},
					value: [
						new Primitive$1({
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 0 // [0]
							},
							isHexOnly: true
						}),
						new Primitive$1({
							optional: true,
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 1 // [1]
							},
							isHexOnly: true
						}),
						new Primitive$1({
							optional: true,
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 2 // [2]
							},
							isHexOnly: true
						}),
						new Primitive$1({
							optional: true,
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 3 // [3]
							},
							isHexOnly: true
						})
					]
				}),
				new Constructed$1({
					optional: true,
					name: (names.organizational_unit_names || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 6 // [6]
					},
					value: [
						new Repeated({
							value: new PrintableString$1()
						})
					]
				})
			]
		}));
	}
	//**************************************************************************************
	/**
	 * Schema for "builtInDomainDefinedAttributes" of "ORAddress"
	 * @param {boolean} optional
	 * @returns {Sequence}
	 */
	function builtInDomainDefinedAttributes(optional = false)
	{
		return (new Sequence$1({
			optional,
			value: [
				new PrintableString$1(),
				new PrintableString$1()
			]
		}));
	}
	//**************************************************************************************
	/**
	 * Schema for "builtInDomainDefinedAttributes" of "ORAddress"
	 * @param {boolean} optional
	 * @returns {Set}
	 */
	function extensionAttributes(optional = false)
	{
		return (new Set$1({
			optional,
			value: [
				new Primitive$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					isHexOnly: true
				}),
				new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [new Any()]
				})
			]
		}));
	}
	//**************************************************************************************
	//endregion
	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class GeneralName
	{
		//**********************************************************************************
		/**
		 * Constructor for GeneralName class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 * @property {number} [type] value type - from a tagged value (0 for "otherName", 1 for "rfc822Name" etc.)
		 * @property {Object} [value] asn1js object having GeneralName value (type depends on "type" value)
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {number}
			 * @desc value type - from a tagged value (0 for "otherName", 1 for "rfc822Name" etc.)
			 */
			this.type = getParametersValue$2(parameters, "type", GeneralName.defaultValues("type"));
			/**
			 * @type {Object}
			 * @desc asn1js object having GeneralName value (type depends on "type" value)
			 */
			this.value = getParametersValue$2(parameters, "value", GeneralName.defaultValues("value"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "type":
					return 9;
				case "value":
					return {};
				default:
					throw new Error(`Invalid member name for GeneralName class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "type":
					return (memberValue === GeneralName.defaultValues(memberName));
				case "value":
					return (Object.keys(memberValue).length === 0);
				default:
					throw new Error(`Invalid member name for GeneralName class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * GeneralName ::= Choice {
		 *    otherName                       [0]     OtherName,
		 *    rfc822Name                      [1]     IA5String,
		 *    dNSName                         [2]     IA5String,
		 *    x400Address                     [3]     ORAddress,
		 *    directoryName                   [4]     value,
		 *    ediPartyName                    [5]     EDIPartyName,
		 *    uniformResourceIdentifier       [6]     IA5String,
		 *    iPAddress                       [7]     OCTET STRING,
		 *    registeredID                    [8]     OBJECT IDENTIFIER }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {Object} [directoryName]
			 * @property {Object} [builtInStandardAttributes]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Choice({
				value: [
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						name: (names.blockName || ""),
						value: [
							new ObjectIdentifier$2(),
							new Constructed$1({
								idBlock: {
									tagClass: 3, // CONTEXT-SPECIFIC
									tagNumber: 0 // [0]
								},
								value: [new Any()]
							})
						]
					}),
					new Primitive$1({
						name: (names.blockName || ""),
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						}
					}),
					new Primitive$1({
						name: (names.blockName || ""),
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 2 // [2]
						}
					}),
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 3 // [3]
						},
						name: (names.blockName || ""),
						value: [
							builtInStandardAttributes((names.builtInStandardAttributes || {}), false),
							builtInDomainDefinedAttributes(true),
							extensionAttributes(true)
						]
					}),
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 4 // [4]
						},
						name: (names.blockName || ""),
						value: [RelativeDistinguishedNames.schema(names.directoryName || {})]
					}),
					new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 5 // [5]
						},
						name: (names.blockName || ""),
						value: [
							new Constructed$1({
								optional: true,
								idBlock: {
									tagClass: 3, // CONTEXT-SPECIFIC
									tagNumber: 0 // [0]
								},
								value: [
									new Choice({
										value: [
											new TeletexString$1(),
											new PrintableString$1(),
											new UniversalString$1(),
											new Utf8String$1(),
											new BmpString$1()
										]
									})
								]
							}),
							new Constructed$1({
								idBlock: {
									tagClass: 3, // CONTEXT-SPECIFIC
									tagNumber: 1 // [1]
								},
								value: [
									new Choice({
										value: [
											new TeletexString$1(),
											new PrintableString$1(),
											new UniversalString$1(),
											new Utf8String$1(),
											new BmpString$1()
										]
									})
								]
							})
						]
					}),
					new Primitive$1({
						name: (names.blockName || ""),
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 6 // [6]
						}
					}),
					new Primitive$1({
						name: (names.blockName || ""),
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 7 // [7]
						}
					}),
					new Primitive$1({
						name: (names.blockName || ""),
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 8 // [8]
						}
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"blockName",
				"otherName",
				"rfc822Name",
				"dNSName",
				"x400Address",
				"directoryName",
				"ediPartyName",
				"uniformResourceIdentifier",
				"iPAddress",
				"registeredID"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				GeneralName.schema({
					names: {
						blockName: "blockName",
						otherName: "otherName",
						rfc822Name: "rfc822Name",
						dNSName: "dNSName",
						x400Address: "x400Address",
						directoryName: {
							names: {
								blockName: "directoryName"
							}
						},
						ediPartyName: "ediPartyName",
						uniformResourceIdentifier: "uniformResourceIdentifier",
						iPAddress: "iPAddress",
						registeredID: "registeredID"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for GeneralName");
			//endregion

			//region Get internal properties from parsed schema
			this.type = asn1.result.blockName.idBlock.tagNumber;

			switch(this.type)
			{
				case 0: // otherName
					this.value = asn1.result.blockName;
					break;
				case 1: // rfc822Name + dNSName + uniformResourceIdentifier
				case 2:
				case 6:
					{
						const value = asn1.result.blockName;

						value.idBlock.tagClass = 1; // UNIVERSAL
						value.idBlock.tagNumber = 22; // IA5STRING

						const valueBER = value.toBER(false);

						this.value = fromBER$1(valueBER).result.valueBlock.value;
					}
					break;
				case 3: // x400Address
					this.value = asn1.result.blockName;
					break;
				case 4: // directoryName
					this.value = new RelativeDistinguishedNames({ schema: asn1.result.directoryName });
					break;
				case 5: // ediPartyName
					this.value = asn1.result.ediPartyName;
					break;
				case 7: // iPAddress
					this.value = new OctetString$1({ valueHex: asn1.result.blockName.valueBlock.valueHex });
					break;
				case 8: // registeredID
					{
						const value = asn1.result.blockName;

						value.idBlock.tagClass = 1; // UNIVERSAL
						value.idBlock.tagNumber = 6; // ObjectIdentifier

						const valueBER = value.toBER(false);

						this.value = fromBER$1(valueBER).result.valueBlock.toString(); // Getting a string representation of the ObjectIdentifier
					}
					break;
				default:
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			switch(this.type)
			{
				case 0:
				case 3:
				case 5:
					return new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: this.type
						},
						value: [
							this.value
						]
					});
				case 1:
				case 2:
				case 6:
					{
						const value = new IA5String$1({ value: this.value });

						value.idBlock.tagClass = 3;
						value.idBlock.tagNumber = this.type;

						return value;
					}
				case 4:
					return new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 4
						},
						value: [this.value.toSchema()]
					});
				case 7:
					{
						const value = this.value;

						value.idBlock.tagClass = 3;
						value.idBlock.tagNumber = this.type;

						return value;
					}
				case 8:
					{
						const value = new ObjectIdentifier$2({ value: this.value });

						value.idBlock.tagClass = 3;
						value.idBlock.tagNumber = this.type;

						return value;
					}
				default:
					return GeneralName.schema();
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const _object = {
				type: this.type,
				value: ""
			};

			if((typeof this.value) === "string")
				_object.value = this.value;
			else
			{
				try
				{
					_object.value = this.value.toJSON();
				}
				catch(ex){}
			}

			return _object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class AltName
	{
		//**********************************************************************************
		/**
		 * Constructor for AltName class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<GeneralName>}
			 * @desc Array of alternative names in GeneralName type
			 */
			this.altNames = getParametersValue$2(parameters, "altNames", AltName.defaultValues("altNames"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "altNames":
					return [];
				default:
					throw new Error(`Invalid member name for AltName class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * AltName ::= GeneralNames
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [altNames]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.altNames || ""),
						value: GeneralName.schema()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"altNames"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				AltName.schema({
					names: {
						altNames: "altNames"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for AltName");
			//endregion

			//region Get internal properties from parsed schema
			if("altNames" in asn1.result)
				this.altNames = Array.from(asn1.result.altNames, element => new GeneralName({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.altNames, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				altNames: Array.from(this.altNames, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class BasicConstraints
	{
		//**********************************************************************************
		/**
		 * Constructor for BasicConstraints class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 * @property {Object} [cA]
		 * @property {Object} [pathLenConstraint]
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {boolean}
			 * @desc cA
			 */
			this.cA = getParametersValue$2(parameters, "cA", false);

			if("pathLenConstraint" in parameters)
				/**
				 * @type {number|Integer}
				 * @desc pathLenConstraint
				 */
				this.pathLenConstraint = getParametersValue$2(parameters, "pathLenConstraint", 0);
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "cA":
					return false;
				default:
					throw new Error(`Invalid member name for BasicConstraints class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * BasicConstraints ::= SEQUENCE {
		 *    cA                      BOOLEAN DEFAULT FALSE,
		 *    pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [cA]
			 * @property {string} [pathLenConstraint]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Boolean$1({
						optional: true,
						name: (names.cA || "")
					}),
					new Integer$1({
						optional: true,
						name: (names.pathLenConstraint || "")
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"cA",
				"pathLenConstraint"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				BasicConstraints.schema({
					names: {
						cA: "cA",
						pathLenConstraint: "pathLenConstraint"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for BasicConstraints");
			//endregion

			//region Get internal properties from parsed schema
			if("cA" in asn1.result)
				this.cA = asn1.result.cA.valueBlock.value;

			if("pathLenConstraint" in asn1.result)
			{
				if(asn1.result.pathLenConstraint.valueBlock.isHexOnly)
					this.pathLenConstraint = asn1.result.pathLenConstraint;
				else
					this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if(this.cA !== BasicConstraints.defaultValues("cA"))
				outputArray.push(new Boolean$1({ value: this.cA }));
			
			if("pathLenConstraint" in this)
			{
				if(this.pathLenConstraint instanceof Integer$1)
					outputArray.push(this.pathLenConstraint);
				else
					outputArray.push(new Integer$1({ value: this.pathLenConstraint }));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};

			if(this.cA !== BasicConstraints.defaultValues("cA"))
				object.cA = this.cA;

			if("pathLenConstraint" in this)
			{
				if(this.pathLenConstraint instanceof Integer$1)
					object.pathLenConstraint = this.pathLenConstraint.toJSON();
				else
					object.pathLenConstraint = this.pathLenConstraint;
			}

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class IssuingDistributionPoint
	{
		//**********************************************************************************
		/**
		 * Constructor for IssuingDistributionPoint class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			if("distributionPoint" in parameters)
				/**
				 * @type {Array.<GeneralName>|RelativeDistinguishedNames}
				 * @desc distributionPoint
				 */
				this.distributionPoint = getParametersValue$2(parameters, "distributionPoint", IssuingDistributionPoint.defaultValues("distributionPoint"));

			/**
			 * @type {boolean}
			 * @desc onlyContainsUserCerts
			 */
			this.onlyContainsUserCerts = getParametersValue$2(parameters, "onlyContainsUserCerts", IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"));

			/**
			 * @type {boolean}
			 * @desc onlyContainsCACerts
			 */
			this.onlyContainsCACerts = getParametersValue$2(parameters, "onlyContainsCACerts", IssuingDistributionPoint.defaultValues("onlyContainsCACerts"));

			if("onlySomeReasons" in parameters)
				/**
				 * @type {number}
				 * @desc onlySomeReasons
				 */
				this.onlySomeReasons = getParametersValue$2(parameters, "onlySomeReasons", IssuingDistributionPoint.defaultValues("onlySomeReasons"));

			/**
			 * @type {boolean}
			 * @desc indirectCRL
			 */
			this.indirectCRL = getParametersValue$2(parameters, "indirectCRL", IssuingDistributionPoint.defaultValues("indirectCRL"));

			/**
			 * @type {boolean}
			 * @desc onlyContainsAttributeCerts
			 */
			this.onlyContainsAttributeCerts = getParametersValue$2(parameters, "onlyContainsAttributeCerts", IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "distributionPoint":
					return [];
				case "onlyContainsUserCerts":
					return false;
				case "onlyContainsCACerts":
					return false;
				case "onlySomeReasons":
					return 0;
				case "indirectCRL":
					return false;
				case "onlyContainsAttributeCerts":
					return false;
				default:
					throw new Error(`Invalid member name for IssuingDistributionPoint class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * IssuingDistributionPoint ::= SEQUENCE {
		 *    distributionPoint          [0] DistributionPointName OPTIONAL,
		 *    onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,
		 *    onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,
		 *    onlySomeReasons            [3] ReasonFlags OPTIONAL,
		 *    indirectCRL                [4] BOOLEAN DEFAULT FALSE,
		 *    onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
		 *
		 * ReasonFlags ::= BIT STRING {
		 *    unused                  (0),
		 *    keyCompromise           (1),
		 *    cACompromise            (2),
		 *    affiliationChanged      (3),
		 *    superseded              (4),
		 *    cessationOfOperation    (5),
		 *    certificateHold         (6),
		 *    privilegeWithdrawn      (7),
		 *    aACompromise            (8) }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [distributionPoint]
			 * @property {string} [distributionPointNames]
			 * @property {string} [onlyContainsUserCerts]
			 * @property {string} [onlyContainsCACerts]
			 * @property {string} [onlySomeReasons]
			 * @property {string} [indirectCRL]
			 * @property {string} [onlyContainsAttributeCerts]
			 */
			const names = getParametersValue$2(parameters, "names", {});
			
			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: [
							new Choice({
								value: [
									new Constructed$1({
										name: (names.distributionPoint || ""),
										idBlock: {
											tagClass: 3, // CONTEXT-SPECIFIC
											tagNumber: 0 // [0]
										},
										value: [
											new Repeated({
												name: (names.distributionPointNames || ""),
												value: GeneralName.schema()
											})
										]
									}),
									new Constructed$1({
										name: (names.distributionPoint || ""),
										idBlock: {
											tagClass: 3, // CONTEXT-SPECIFIC
											tagNumber: 1 // [1]
										},
										value: RelativeDistinguishedNames.schema().valueBlock.value
									})
								]
							})
						]
					}),
					new Primitive$1({
						name: (names.onlyContainsUserCerts || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						}
					}), // IMPLICIT boolean value
					new Primitive$1({
						name: (names.onlyContainsCACerts || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 2 // [2]
						}
					}), // IMPLICIT boolean value
					new Primitive$1({
						name: (names.onlySomeReasons || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 3 // [3]
						}
					}), // IMPLICIT bitstring value
					new Primitive$1({
						name: (names.indirectCRL || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 4 // [4]
						}
					}), // IMPLICIT boolean value
					new Primitive$1({
						name: (names.onlyContainsAttributeCerts || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 5 // [5]
						}
					}) // IMPLICIT boolean value
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"distributionPoint",
				"distributionPointNames",
				"onlyContainsUserCerts",
				"onlyContainsCACerts",
				"onlySomeReasons",
				"indirectCRL",
				"onlyContainsAttributeCerts"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				IssuingDistributionPoint.schema({
					names: {
						distributionPoint: "distributionPoint",
						distributionPointNames: "distributionPointNames",
						onlyContainsUserCerts: "onlyContainsUserCerts",
						onlyContainsCACerts: "onlyContainsCACerts",
						onlySomeReasons: "onlySomeReasons",
						indirectCRL: "indirectCRL",
						onlyContainsAttributeCerts: "onlyContainsAttributeCerts"
					}
				})
			);
			
			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");
			//endregion
			
			//region Get internal properties from parsed schema
			if("distributionPoint" in asn1.result)
			{
				switch(true)
				{
					case (asn1.result.distributionPoint.idBlock.tagNumber === 0): // GENERAL_NAMES variant
						this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({ schema: element }));
						break;
					case (asn1.result.distributionPoint.idBlock.tagNumber === 1): // RDN variant
						{
							this.distributionPoint = new RelativeDistinguishedNames({
								schema: new Sequence$1({
									value: asn1.result.distributionPoint.valueBlock.value
								})
							});
						}
						break;
					default:
						throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
				}
			}
			
			if("onlyContainsUserCerts" in asn1.result)
			{
				const view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
				this.onlyContainsUserCerts = (view[0] !== 0x00);
			}
			
			if("onlyContainsCACerts" in asn1.result)
			{
				const view = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);
				this.onlyContainsCACerts = (view[0] !== 0x00);
			}
			
			if("onlySomeReasons" in asn1.result)
			{
				const view = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);
				this.onlySomeReasons = view[0];
			}
			
			if("indirectCRL" in asn1.result)
			{
				const view = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);
				this.indirectCRL = (view[0] !== 0x00);
			}
			
			if("onlyContainsAttributeCerts" in asn1.result)
			{
				const view = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);
				this.onlyContainsAttributeCerts = (view[0] !== 0x00);
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if("distributionPoint" in this)
			{
				let value;
				
				if(this.distributionPoint instanceof Array)
				{
					value = new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: Array.from(this.distributionPoint, element => element.toSchema())
					});
				}
				else
				{
					value = this.distributionPoint.toSchema();
					
					value.idBlock.tagClass = 3; // CONTEXT - SPECIFIC
					value.idBlock.tagNumber = 1; // [1]
				}
				
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [value]
				}));
			}
			
			if(this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"))
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					valueHex: (new Uint8Array([0xFF])).buffer
				}));
			}
			
			if(this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts"))
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					valueHex: (new Uint8Array([0xFF])).buffer
				}));
			}
			
			if("onlySomeReasons" in this)
			{
				const buffer = new ArrayBuffer(1);
				const view = new Uint8Array(buffer);
				
				view[0] = this.onlySomeReasons;
				
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					valueHex: buffer
				}));
			}
			
			if(this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL"))
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 4 // [4]
					},
					valueHex: (new Uint8Array([0xFF])).buffer
				}));
			}
			
			if(this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts"))
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 5 // [5]
					},
					valueHex: (new Uint8Array([0xFF])).buffer
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};
			
			if("distributionPoint" in this)
			{
				if(this.distributionPoint instanceof Array)
					object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());
				else
					object.distributionPoint = this.distributionPoint.toJSON();
			}
			
			if(this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"))
				object.onlyContainsUserCerts = this.onlyContainsUserCerts;
			
			if(this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts"))
				object.onlyContainsCACerts = this.onlyContainsCACerts;
			
			if("onlySomeReasons" in this)
				object.onlySomeReasons = this.onlySomeReasons;
			
			if(this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL"))
				object.indirectCRL = this.indirectCRL;
			
			if(this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts"))
				object.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
			
			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class GeneralNames
	{
		//**********************************************************************************
		/**
		 * Constructor for GeneralNames class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<GeneralName>}
			 * @desc Array of "general names"
			 */
			this.names = getParametersValue$2(parameters, "names", GeneralNames.defaultValues("names"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "names":
					return [];
				default:
					throw new Error(`Invalid member name for GeneralNames class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @param {boolean} [optional=false] Flag would be element optional or not
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {}, optional = false)
		{
			/**
			 * @type {Object}
			 * @property {string} utcTimeName Name for "utcTimeName" choice
			 * @property {string} generalTimeName Name for "generalTimeName" choice
			 */
			const names = getParametersValue$2(parameters, "names", {});
			
			return (new Sequence$1({
				optional,
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.generalNames || ""),
						value: GeneralName.schema()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"names",
				"generalNames"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				GeneralNames.schema({
					names: {
						blockName: "names",
						generalNames: "generalNames"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for GeneralNames");
			//endregion

			//region Get internal properties from parsed schema
			this.names = Array.from(asn1.result.generalNames, element => new GeneralName({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.names, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				names: Array.from(this.names, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class GeneralSubtree
	{
		//**********************************************************************************
		/**
		 * Constructor for GeneralSubtree class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {GeneralName}
			 * @desc base
			 */
			this.base = getParametersValue$2(parameters, "base", GeneralSubtree.defaultValues("base"));

			/**
			 * @type {number|Integer}
			 * @desc base
			 */
			this.minimum = getParametersValue$2(parameters, "minimum", GeneralSubtree.defaultValues("minimum"));

			if("maximum" in parameters)
				/**
				 * @type {number|Integer}
				 * @desc minimum
				 */
				this.maximum = getParametersValue$2(parameters, "maximum", GeneralSubtree.defaultValues("maximum"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "base":
					return new GeneralName();
				case "minimum":
					return 0;
				case "maximum":
					return 0;
				default:
					throw new Error(`Invalid member name for GeneralSubtree class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * GeneralSubtree ::= SEQUENCE {
		 *    base                    GeneralName,
		 *    minimum         [0]     BaseDistance DEFAULT 0,
		 *    maximum         [1]     BaseDistance OPTIONAL }
		 *
		 * BaseDistance ::= INTEGER (0..MAX)
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [base]
			 * @property {string} [minimum]
			 * @property {string} [maximum]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					GeneralName.schema(names.base || {}),
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: [new Integer$1({ name: (names.minimum || "") })]
					}),
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						},
						value: [new Integer$1({ name: (names.maximum || "") })]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"base",
				"minimum",
				"maximum"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				GeneralSubtree.schema({
					names: {
						base: {
							names: {
								blockName: "base"
							}
						},
						minimum: "minimum",
						maximum: "maximum"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for GeneralSubtree");
			//endregion

			//region Get internal properties from parsed schema
			this.base = new GeneralName({ schema: asn1.result.base });

			if("minimum" in asn1.result)
			{
				if(asn1.result.minimum.valueBlock.isHexOnly)
					this.minimum = asn1.result.minimum;
				else
					this.minimum = asn1.result.minimum.valueBlock.valueDec;
			}

			if("maximum" in asn1.result)
			{
				if(asn1.result.maximum.valueBlock.isHexOnly)
					this.maximum = asn1.result.maximum;
				else
					this.maximum = asn1.result.maximum.valueBlock.valueDec;
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			outputArray.push(this.base.toSchema());
			
			if(this.minimum !== 0)
			{
				let valueMinimum = 0;
				
				if(this.minimum instanceof Integer$1)
					valueMinimum = this.minimum;
				else
					valueMinimum = new Integer$1({ value: this.minimum });
				
				outputArray.push(new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [valueMinimum]
				}));
			}
			
			if("maximum" in this)
			{
				let valueMaximum = 0;
				
				if(this.maximum instanceof Integer$1)
					valueMaximum = this.maximum;
				else
					valueMaximum = new Integer$1({ value: this.maximum });
				
				outputArray.push(new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [valueMaximum]
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				base: this.base.toJSON()
			};
			
			if(this.minimum !== 0)
			{
				if((typeof this.minimum) === "number")
					object.minimum = this.minimum;
				else
					object.minimum = this.minimum.toJSON();
			}
			
			if("maximum" in this)
			{
				if((typeof this.maximum) === "number")
					object.maximum = this.maximum;
				else
					object.maximum = this.maximum.toJSON();
			}
			
			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class NameConstraints
	{
		//**********************************************************************************
		/**
		 * Constructor for NameConstraints class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			if("permittedSubtrees" in parameters)
				/**
				 * @type {Array.<GeneralSubtree>}
				 * @desc permittedSubtrees
				 */
				this.permittedSubtrees = getParametersValue$2(parameters, "permittedSubtrees", NameConstraints.defaultValues("permittedSubtrees"));

			if("excludedSubtrees" in parameters)
				/**
				 * @type {Array.<GeneralSubtree>}
				 * @desc excludedSubtrees
				 */
				this.excludedSubtrees = getParametersValue$2(parameters, "excludedSubtrees", NameConstraints.defaultValues("excludedSubtrees"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "permittedSubtrees":
					return [];
				case "excludedSubtrees":
					return [];
				default:
					throw new Error(`Invalid member name for NameConstraints class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * NameConstraints ::= SEQUENCE {
		 *    permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
		 *    excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [permittedSubtrees]
			 * @property {string} [excludedSubtrees]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: [
							new Repeated({
								name: (names.permittedSubtrees || ""),
								value: GeneralSubtree.schema()
							})
						]
					}),
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						},
						value: [
							new Repeated({
								name: (names.excludedSubtrees || ""),
								value: GeneralSubtree.schema()
							})
						]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"permittedSubtrees",
				"excludedSubtrees"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				NameConstraints.schema({
					names: {
						permittedSubtrees: "permittedSubtrees",
						excludedSubtrees: "excludedSubtrees"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for NameConstraints");
			//endregion

			//region Get internal properties from parsed schema
			if("permittedSubtrees" in asn1.result)
				this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, element => new GeneralSubtree({ schema: element }));

			if("excludedSubtrees" in asn1.result)
				this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, element => new GeneralSubtree({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if("permittedSubtrees" in this)
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: Array.from(this.permittedSubtrees, element => element.toSchema())
				}));
			}
			
			if("excludedSubtrees" in this)
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: Array.from(this.excludedSubtrees, element => element.toSchema())
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};
			
			if("permittedSubtrees" in this)
				object.permittedSubtrees = Array.from(this.permittedSubtrees, element => element.toJSON());

			if("excludedSubtrees" in this)
				object.excludedSubtrees = Array.from(this.excludedSubtrees, element => element.toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class DistributionPoint
	{
		//**********************************************************************************
		/**
		 * Constructor for DistributionPoint class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 * @property {Object} [distributionPoint]
		 * @property {Object} [reasons]
		 * @property {Object} [cRLIssuer]
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			if("distributionPoint" in parameters)
				/**
				 * @type {Array.<GeneralName>}
				 * @desc distributionPoint
				 */
				this.distributionPoint = getParametersValue$2(parameters, "distributionPoint", DistributionPoint.defaultValues("distributionPoint"));

			if("reasons" in parameters)
				/**
				 * @type {BitString}
				 * @desc values
				 */
				this.reasons = getParametersValue$2(parameters, "reasons", DistributionPoint.defaultValues("reasons"));

			if("cRLIssuer" in parameters)
				/**
				 * @type {Array.<GeneralName>}
				 * @desc cRLIssuer
				 */
				this.cRLIssuer = getParametersValue$2(parameters, "cRLIssuer", DistributionPoint.defaultValues("cRLIssuer"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "distributionPoint":
					return [];
				case "reasons":
					return new BitString$1();
				case "cRLIssuer":
					return [];
				default:
					throw new Error(`Invalid member name for DistributionPoint class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * DistributionPoint ::= SEQUENCE {
		 *    distributionPoint       [0]     DistributionPointName OPTIONAL,
		 *    reasons                 [1]     ReasonFlags OPTIONAL,
		 *    cRLIssuer               [2]     GeneralNames OPTIONAL }
		 *
		 * DistributionPointName ::= CHOICE {
		 *    fullName                [0]     GeneralNames,
		 *    nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }
		 *
		 * ReasonFlags ::= BIT STRING {
		 *    unused                  (0),
		 *    keyCompromise           (1),
		 *    cACompromise            (2),
		 *    affiliationChanged      (3),
		 *    superseded              (4),
		 *    cessationOfOperation    (5),
		 *    certificateHold         (6),
		 *    privilegeWithdrawn      (7),
		 *    aACompromise            (8) }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [distributionPoint]
			 * @property {string} [distributionPointNames]
			 * @property {string} [reasons]
			 * @property {string} [cRLIssuer]
			 * @property {string} [cRLIssuerNames]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: [
							new Choice({
								value: [
									new Constructed$1({
										name: (names.distributionPoint || ""),
										optional: true,
										idBlock: {
											tagClass: 3, // CONTEXT-SPECIFIC
											tagNumber: 0 // [0]
										},
										value: [
											new Repeated({
												name: (names.distributionPointNames || ""),
												value: GeneralName.schema()
											})
										]
									}),
									new Constructed$1({
										name: (names.distributionPoint || ""),
										optional: true,
										idBlock: {
											tagClass: 3, // CONTEXT-SPECIFIC
											tagNumber: 1 // [1]
										},
										value: RelativeDistinguishedNames.schema().valueBlock.value
									})
								]
							})
						]
					}),
					new Primitive$1({
						name: (names.reasons || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						}
					}), // IMPLICIT bitstring value
					new Constructed$1({
						name: (names.cRLIssuer || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 2 // [2]
						},
						value: [
							new Repeated({
								name: (names.cRLIssuerNames || ""),
								value: GeneralName.schema()
							})
						]
					}) // IMPLICIT bitstring value
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"distributionPoint",
				"distributionPointNames",
				"reasons",
				"cRLIssuer",
				"cRLIssuerNames"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				DistributionPoint.schema({
					names: {
						distributionPoint: "distributionPoint",
						distributionPointNames: "distributionPointNames",
						reasons: "reasons",
						cRLIssuer: "cRLIssuer",
						cRLIssuerNames: "cRLIssuerNames"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for DistributionPoint");
			//endregion

			//region Get internal properties from parsed schema
			if("distributionPoint" in asn1.result)
			{
				if(asn1.result.distributionPoint.idBlock.tagNumber === 0) // GENERAL_NAMES variant
					this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({ schema: element }));

				if(asn1.result.distributionPoint.idBlock.tagNumber === 1) // RDN variant
				{
					this.distributionPoint = new RelativeDistinguishedNames({
						schema: new Sequence$1({
							value: asn1.result.distributionPoint.valueBlock.value
						})
					});
				}
			}

			if("reasons" in asn1.result)
				this.reasons = new BitString$1({ valueHex: asn1.result.reasons.valueBlock.valueHex });

			if("cRLIssuer" in asn1.result)
				this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, element => new GeneralName({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if("distributionPoint" in this)
			{
				let internalValue;
				
				if(this.distributionPoint instanceof Array)
				{
					internalValue = new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						value: Array.from(this.distributionPoint, element => element.toSchema())
					});
				}
				else
				{
					internalValue = new Constructed$1({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						},
						value: [this.distributionPoint.toSchema()]
					});
				}
				
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [internalValue]
				}));
			}
			
			if("reasons" in this)
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					valueHex: this.reasons.valueBlock.valueHex
				}));
			}
			
			if("cRLIssuer" in this)
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: Array.from(this.cRLIssuer, element => element.toSchema())
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};

			if("distributionPoint" in this)
			{
				if(this.distributionPoint instanceof Array)
					object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());
				else
					object.distributionPoint = this.distributionPoint.toJSON();
			}

			if("reasons" in this)
				object.reasons = this.reasons.toJSON();

			if("cRLIssuer" in this)
				object.cRLIssuer = Array.from(this.cRLIssuer, element => element.toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class CRLDistributionPoints
	{
		//**********************************************************************************
		/**
		 * Constructor for CRLDistributionPoints class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<DistributionPoint>}
			 * @desc distributionPoints
			 */
			this.distributionPoints = getParametersValue$2(parameters, "distributionPoints", CRLDistributionPoints.defaultValues("distributionPoints"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "distributionPoints":
					return [];
				default:
					throw new Error(`Invalid member name for CRLDistributionPoints class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [distributionPoints]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.distributionPoints || ""),
						value: DistributionPoint.schema()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"distributionPoints"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				CRLDistributionPoints.schema({
					names: {
						distributionPoints: "distributionPoints"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");
			//endregion

			//region Get internal properties from parsed schema
			this.distributionPoints = Array.from(asn1.result.distributionPoints, element => new DistributionPoint({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.distributionPoints, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				distributionPoints: Array.from(this.distributionPoints, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class PolicyQualifierInfo
	{
		//**********************************************************************************
		/**
		 * Constructor for PolicyQualifierInfo class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc policyQualifierId
			 */
			this.policyQualifierId = getParametersValue$2(parameters, "policyQualifierId", PolicyQualifierInfo.defaultValues("policyQualifierId"));
			/**
			 * @type {Object}
			 * @desc qualifier
			 */
			this.qualifier = getParametersValue$2(parameters, "qualifier", PolicyQualifierInfo.defaultValues("qualifier"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "policyQualifierId":
					return "";
				case "qualifier":
					return new Any();
				default:
					throw new Error(`Invalid member name for PolicyQualifierInfo class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PolicyQualifierInfo ::= SEQUENCE {
		 *    policyQualifierId  PolicyQualifierId,
		 *    qualifier          ANY DEFINED BY policyQualifierId }
		 *
		 * id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
		 * id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
		 * id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
		 *
		 * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [policyQualifierId]
			 * @property {string} [qualifier]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.policyQualifierId || "") }),
					new Any({ name: (names.qualifier || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"policyQualifierId",
				"qualifier"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PolicyQualifierInfo.schema({
					names: {
						policyQualifierId: "policyQualifierId",
						qualifier: "qualifier"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");
			//endregion

			//region Get internal properties from parsed schema
			this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
			this.qualifier = asn1.result.qualifier;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					new ObjectIdentifier$2({ value: this.policyQualifierId }),
					this.qualifier
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				policyQualifierId: this.policyQualifierId,
				qualifier: this.qualifier.toJSON()
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class PolicyInformation
	{
		//**********************************************************************************
		/**
		 * Constructor for PolicyInformation class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc policyIdentifier
			 */
			this.policyIdentifier = getParametersValue$2(parameters, "policyIdentifier", PolicyInformation.defaultValues("policyIdentifier"));

			if("policyQualifiers" in parameters)
				/**
				 * @type {Array.<PolicyQualifierInfo>}
				 * @desc Value of the TIME class
				 */
				this.policyQualifiers = getParametersValue$2(parameters, "policyQualifiers", PolicyInformation.defaultValues("policyQualifiers"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "policyIdentifier":
					return "";
				case "policyQualifiers":
					return [];
				default:
					throw new Error(`Invalid member name for PolicyInformation class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PolicyInformation ::= SEQUENCE {
		 *    policyIdentifier   CertPolicyId,
		 *    policyQualifiers   SEQUENCE SIZE (1..MAX) OF
		 *    PolicyQualifierInfo OPTIONAL }
		 *
		 * CertPolicyId ::= OBJECT IDENTIFIER
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [policyIdentifier]
			 * @property {string} [policyQualifiers]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.policyIdentifier || "") }),
					new Sequence$1({
						optional: true,
						value: [
							new Repeated({
								name: (names.policyQualifiers || ""),
								value: PolicyQualifierInfo.schema()
							})
						]
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"policyIdentifier",
				"policyQualifiers"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PolicyInformation.schema({
					names: {
						policyIdentifier: "policyIdentifier",
						policyQualifiers: "policyQualifiers"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PolicyInformation");
			//endregion

			//region Get internal properties from parsed schema
			this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();

			if("policyQualifiers" in asn1.result)
				this.policyQualifiers = Array.from(asn1.result.policyQualifiers, element => new PolicyQualifierInfo({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			outputArray.push(new ObjectIdentifier$2({ value: this.policyIdentifier }));
			
			if("policyQualifiers" in this)
			{
				outputArray.push(new Sequence$1({
					value: Array.from(this.policyQualifiers, element => element.toSchema())
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				policyIdentifier: this.policyIdentifier
			};

			if("policyQualifiers" in this)
				object.policyQualifiers = Array.from(this.policyQualifiers, element => element.toJSON());

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class CertificatePolicies
	{
		//**********************************************************************************
		/**
		 * Constructor for CertificatePolicies class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<PolicyInformation>}
			 * @desc certificatePolicies
			 */
			this.certificatePolicies = getParametersValue$2(parameters, "certificatePolicies", CertificatePolicies.defaultValues("certificatePolicies"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "certificatePolicies":
					return [];
				default:
					throw new Error(`Invalid member name for CertificatePolicies class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [certificatePolicies]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.certificatePolicies || ""),
						value: PolicyInformation.schema()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"certificatePolicies"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				CertificatePolicies.schema({
					names: {
						certificatePolicies: "certificatePolicies"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for CertificatePolicies");
			//endregion

			//region Get internal properties from parsed schema
			this.certificatePolicies = Array.from(asn1.result.certificatePolicies, element => new PolicyInformation({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.certificatePolicies, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				certificatePolicies: Array.from(this.certificatePolicies, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class PolicyMapping
	{
		//**********************************************************************************
		/**
		 * Constructor for PolicyMapping class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc issuerDomainPolicy
			 */
			this.issuerDomainPolicy = getParametersValue$2(parameters, "issuerDomainPolicy", PolicyMapping.defaultValues("issuerDomainPolicy"));
			/**
			 * @type {string}
			 * @desc subjectDomainPolicy
			 */
			this.subjectDomainPolicy = getParametersValue$2(parameters, "subjectDomainPolicy", PolicyMapping.defaultValues("subjectDomainPolicy"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "issuerDomainPolicy":
					return "";
				case "subjectDomainPolicy":
					return "";
				default:
					throw new Error(`Invalid member name for PolicyMapping class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PolicyMapping ::= SEQUENCE {
		 *    issuerDomainPolicy      CertPolicyId,
		 *    subjectDomainPolicy     CertPolicyId }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [issuerDomainPolicy]
			 * @property {string} [subjectDomainPolicy]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.issuerDomainPolicy || "") }),
					new ObjectIdentifier$2({ name: (names.subjectDomainPolicy || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"issuerDomainPolicy",
				"subjectDomainPolicy"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PolicyMapping.schema({
					names: {
						issuerDomainPolicy: "issuerDomainPolicy",
						subjectDomainPolicy: "subjectDomainPolicy"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PolicyMapping");
			//endregion

			//region Get internal properties from parsed schema
			this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
			this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					new ObjectIdentifier$2({ value: this.issuerDomainPolicy }),
					new ObjectIdentifier$2({ value: this.subjectDomainPolicy })
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				issuerDomainPolicy: this.issuerDomainPolicy,
				subjectDomainPolicy: this.subjectDomainPolicy
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class PolicyMappings
	{
		//**********************************************************************************
		/**
		 * Constructor for PolicyMappings class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<PolicyMapping>}
			 * @desc mappings
			 */
			this.mappings = getParametersValue$2(parameters, "mappings", PolicyMappings.defaultValues("mappings"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "mappings":
					return [];
				default:
					throw new Error(`Invalid member name for PolicyMappings class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF PolicyMapping
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [utcTimeName] Name for "utcTimeName" choice
			 * @property {string} [generalTimeName] Name for "generalTimeName" choice
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.mappings || ""),
						value: PolicyMapping.schema()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"mappings"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PolicyMappings.schema({
					names: {
						mappings: "mappings"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PolicyMappings");
			//endregion

			//region Get internal properties from parsed schema
			this.mappings = Array.from(asn1.result.mappings, element => new PolicyMapping({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.mappings, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				mappings: Array.from(this.mappings, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class AuthorityKeyIdentifier
	{
		//**********************************************************************************
		/**
		 * Constructor for AuthorityKeyIdentifier class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			if("keyIdentifier" in parameters)
				/**
				 * @type {OctetString}
				 * @desc keyIdentifier
				 */
				this.keyIdentifier = getParametersValue$2(parameters, "keyIdentifier", AuthorityKeyIdentifier.defaultValues("keyIdentifier"));

			if("authorityCertIssuer" in parameters)
				/**
				 * @type {Array.<GeneralName>}
				 * @desc authorityCertIssuer
				 */
				this.authorityCertIssuer = getParametersValue$2(parameters, "authorityCertIssuer", AuthorityKeyIdentifier.defaultValues("authorityCertIssuer"));

			if("authorityCertSerialNumber" in parameters)
				/**
				 * @type {Integer}
				 * @desc authorityCertIssuer
				 */
				this.authorityCertSerialNumber = getParametersValue$2(parameters, "authorityCertSerialNumber", AuthorityKeyIdentifier.defaultValues("authorityCertSerialNumber"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "keyIdentifier":
					return new OctetString$1();
				case "authorityCertIssuer":
					return [];
				case "authorityCertSerialNumber":
					return new Integer$1();
				default:
					throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * AuthorityKeyIdentifier OID ::= 2.5.29.35
		 *
		 * AuthorityKeyIdentifier ::= SEQUENCE {
		 *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,
		 *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,
		 *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
		 *
		 * KeyIdentifier ::= OCTET STRING
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [keyIdentifier]
			 * @property {string} [authorityCertIssuer]
			 * @property {string} [authorityCertSerialNumber]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Primitive$1({
						name: (names.keyIdentifier || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						}
					}),
					new Constructed$1({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						},
						value: [
							new Repeated({
								name: (names.authorityCertIssuer || ""),
								value: GeneralName.schema()
							})
						]
					}),
					new Primitive$1({
						name: (names.authorityCertSerialNumber || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 2 // [2]
						}
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"keyIdentifier",
				"authorityCertIssuer",
				"authorityCertSerialNumber"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				AuthorityKeyIdentifier.schema({
					names: {
						keyIdentifier: "keyIdentifier",
						authorityCertIssuer: "authorityCertIssuer",
						authorityCertSerialNumber: "authorityCertSerialNumber"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");
			//endregion

			//region Get internal properties from parsed schema
			if("keyIdentifier" in asn1.result)
				this.keyIdentifier = new OctetString$1({ valueHex: asn1.result.keyIdentifier.valueBlock.valueHex });

			if("authorityCertIssuer" in asn1.result)
				this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, element => new GeneralName({ schema: element }));

			if("authorityCertSerialNumber" in asn1.result)
				this.authorityCertSerialNumber = new Integer$1({ valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex });
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if("keyIdentifier" in this)
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					valueHex: this.keyIdentifier.valueBlock.valueHex
				}));
			}
			
			if("authorityCertIssuer" in this)
			{
				outputArray.push(new Constructed$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: Array.from(this.authorityCertIssuer, element => element.toSchema())
				}));
			}
			
			if("authorityCertSerialNumber" in this)
			{
				outputArray.push(new Primitive$1({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					valueHex: this.authorityCertSerialNumber.valueBlock.valueHex
				}));
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};

			if("keyIdentifier" in this)
				object.keyIdentifier = this.keyIdentifier.toJSON();

			if("authorityCertIssuer" in this)
				object.authorityCertIssuer = Array.from(this.authorityCertIssuer, element => element.toJSON());

			if("authorityCertSerialNumber" in this)
				object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class PolicyConstraints
	{
		//**********************************************************************************
		/**
		 * Constructor for PolicyConstraints class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			if("requireExplicitPolicy" in parameters)
				/**
				 * @type {number}
				 * @desc requireExplicitPolicy
				 */
				this.requireExplicitPolicy = getParametersValue$2(parameters, "requireExplicitPolicy", PolicyConstraints.defaultValues("requireExplicitPolicy"));

			if("inhibitPolicyMapping" in parameters)
				/**
				 * @type {number}
				 * @desc Value of the TIME class
				 */
				this.inhibitPolicyMapping = getParametersValue$2(parameters, "inhibitPolicyMapping", PolicyConstraints.defaultValues("inhibitPolicyMapping"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "requireExplicitPolicy":
					return 0;
				case "inhibitPolicyMapping":
					return 0;
				default:
					throw new Error(`Invalid member name for PolicyConstraints class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * PolicyConstraints ::= SEQUENCE {
		 *    requireExplicitPolicy           [0] SkipCerts OPTIONAL,
		 *    inhibitPolicyMapping            [1] SkipCerts OPTIONAL }
		 *
		 * SkipCerts ::= INTEGER (0..MAX)
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [requireExplicitPolicy]
			 * @property {string} [inhibitPolicyMapping]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Primitive$1({
						name: (names.requireExplicitPolicy || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						}
					}), // IMPLICIT integer value
					new Primitive$1({
						name: (names.inhibitPolicyMapping || ""),
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						}
					}) // IMPLICIT integer value
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"requireExplicitPolicy",
				"inhibitPolicyMapping"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				PolicyConstraints.schema({
					names: {
						requireExplicitPolicy: "requireExplicitPolicy",
						inhibitPolicyMapping: "inhibitPolicyMapping"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for PolicyConstraints");
			//endregion

			//region Get internal properties from parsed schema
			if("requireExplicitPolicy" in asn1.result)
			{
				const field1 = asn1.result.requireExplicitPolicy;

				field1.idBlock.tagClass = 1; // UNIVERSAL
				field1.idBlock.tagNumber = 2; // INTEGER

				const ber1 = field1.toBER(false);
				const int1 = fromBER$1(ber1);

				this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
			}

			if("inhibitPolicyMapping" in asn1.result)
			{
				const field2 = asn1.result.inhibitPolicyMapping;

				field2.idBlock.tagClass = 1; // UNIVERSAL
				field2.idBlock.tagNumber = 2; // INTEGER

				const ber2 = field2.toBER(false);
				const int2 = fromBER$1(ber2);

				this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
			}
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create correct values for output sequence
			const outputArray = [];
			
			if("requireExplicitPolicy" in this)
			{
				const int1 = new Integer$1({ value: this.requireExplicitPolicy });
				
				int1.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
				int1.idBlock.tagNumber = 0; // [0]
				
				outputArray.push(int1);
			}
			
			if("inhibitPolicyMapping" in this)
			{
				const int2 = new Integer$1({ value: this.inhibitPolicyMapping });
				
				int2.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
				int2.idBlock.tagNumber = 1; // [1]
				
				outputArray.push(int2);
			}
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {};

			if("requireExplicitPolicy" in this)
				object.requireExplicitPolicy = this.requireExplicitPolicy;

			if("inhibitPolicyMapping" in this)
				object.inhibitPolicyMapping = this.inhibitPolicyMapping;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class ExtKeyUsage
	{
		//**********************************************************************************
		/**
		 * Constructor for ExtKeyUsage class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<string>}
			 * @desc keyPurposes
			 */
			this.keyPurposes = getParametersValue$2(parameters, "keyPurposes", ExtKeyUsage.defaultValues("keyPurposes"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "keyPurposes":
					return [];
				default:
					throw new Error(`Invalid member name for ExtKeyUsage class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * ExtKeyUsage ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
		 *
		 * KeyPurposeId ::= OBJECT IDENTIFIER
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [keyPurposes]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.keyPurposes || ""),
						value: new ObjectIdentifier$2()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"keyPurposes"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				ExtKeyUsage.schema({
					names: {
						keyPurposes: "keyPurposes"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for ExtKeyUsage");
			//endregion

			//region Get internal properties from parsed schema
			this.keyPurposes = Array.from(asn1.result.keyPurposes, element => element.valueBlock.toString());
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.keyPurposes, element => new ObjectIdentifier$2({ value: element }))
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				keyPurposes: Array.from(this.keyPurposes)
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class AccessDescription
	{
		//**********************************************************************************
		/**
		 * Constructor for AccessDescription class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc The type and format of the information are specified by the accessMethod field. This profile defines two accessMethod OIDs: id-ad-caIssuers and id-ad-ocsp
			 */
			this.accessMethod = getParametersValue$2(parameters, "accessMethod", AccessDescription.defaultValues("accessMethod"));
			/**
			 * @type {GeneralName}
			 * @desc The accessLocation field specifies the location of the information
			 */
			this.accessLocation = getParametersValue$2(parameters, "accessLocation", AccessDescription.defaultValues("accessLocation"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "accessMethod":
					return "";
				case "accessLocation":
					return new GeneralName();
				default:
					throw new Error(`Invalid member name for AccessDescription class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * AccessDescription  ::=  SEQUENCE {
		 *    accessMethod          OBJECT IDENTIFIER,
		 *    accessLocation        GeneralName  }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [accessMethod]
			 * @property {string} [accessLocation]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.accessMethod || "") }),
					GeneralName.schema(names.accessLocation || {})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"accessMethod",
				"accessLocation"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				AccessDescription.schema({
					names: {
						accessMethod: "accessMethod",
						accessLocation: {
							names: {
								blockName: "accessLocation"
							}
						}
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for AccessDescription");
			//endregion

			//region Get internal properties from parsed schema
			this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
			this.accessLocation = new GeneralName({ schema: asn1.result.accessLocation });
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					new ObjectIdentifier$2({ value: this.accessMethod }),
					this.accessLocation.toSchema()
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				accessMethod: this.accessMethod,
				accessLocation: this.accessLocation.toJSON()
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class InfoAccess
	{
		//**********************************************************************************
		/**
		 * Constructor for InfoAccess class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<AccessDescription>}
			 * @desc accessDescriptions
			 */
			this.accessDescriptions = getParametersValue$2(parameters, "accessDescriptions", InfoAccess.defaultValues("accessDescriptions"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "accessDescriptions":
					return [];
				default:
					throw new Error(`Invalid member name for InfoAccess class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * AuthorityInfoAccessSyntax  ::=
		 * SEQUENCE SIZE (1..MAX) OF AccessDescription
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [accessDescriptions]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.accessDescriptions || ""),
						value: AccessDescription.schema()
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"accessDescriptions"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				InfoAccess.schema({
					names: {
						accessDescriptions: "accessDescriptions"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for InfoAccess");
			//endregion

			//region Get internal properties from parsed schema
			this.accessDescriptions = Array.from(asn1.result.accessDescriptions, element => new AccessDescription({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.accessDescriptions, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				accessDescriptions: Array.from(this.accessDescriptions, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	/*
	 * Copyright (c) 2016-2018, Peculiar Ventures
	 * All rights reserved.
	 *
	 * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.
	 *
	 */
	//**************************************************************************************
	class ByteStream
	{
		//**********************************************************************************
		// noinspection FunctionWithMultipleLoopsJS
		/**
		 * Constructor for ByteStream class
		 * @param {{[length]: number, [stub]: number, [view]: Uint8Array, [buffer]: ArrayBuffer, [string]: string, [hexstring]: string}} parameters
		 */
		constructor(parameters = {})
		{
			this.clear();
			
			for(const key of Object.keys(parameters))
			{
				switch(key)
				{
					case "length":
						this.length = parameters.length;
						break;
					case "stub":
						// noinspection NonBlockStatementBodyJS
						for(let i = 0; i < this._view.length; i++)
							this._view[i] = parameters.stub;
						break;
					case "view":
						this.fromUint8Array(parameters.view);
						break;
					case "buffer":
						this.fromArrayBuffer(parameters.buffer);
						break;
					case "string":
						this.fromString(parameters.string);
						break;
					case "hexstring":
						this.fromHexString(parameters.hexstring);
						break;
					default:
				}
			}
		}
		//**********************************************************************************
		/**
		 * Setter for "buffer"
		 * @param {ArrayBuffer} value
		 */
		set buffer(value)
		{
			this._buffer = value.slice(0);
			this._view = new Uint8Array(this._buffer);
		}
		//**********************************************************************************
		/**
		 * Getter for "buffer"
		 * @returns {ArrayBuffer}
		 */
		get buffer()
		{
			return this._buffer;
		}
		//**********************************************************************************
		/**
		 * Setter for "view"
		 * @param {Uint8Array} value
		 */
		set view(value)
		{
			this._buffer = new ArrayBuffer(value.length);
			this._view = new Uint8Array(this._buffer);
			
			this._view.set(value);
		}
		//**********************************************************************************
		/**
		 * Getter for "view"
		 * @returns {Uint8Array}
		 */
		get view()
		{
			return this._view;
		}
		//**********************************************************************************
		/**
		 * Getter for "length"
		 * @returns {number}
		 */
		get length()
		{
			return this._buffer.byteLength;
		}
		//**********************************************************************************
		/**
		 * Setter for "length"
		 * @param {number} value
		 */
		set length(value)
		{
			this._buffer = new ArrayBuffer(value);
			this._view = new Uint8Array(this._buffer);
		}
		//**********************************************************************************
		/**
		 * Clear existing stream
		 */
		clear()
		{
			this._buffer = new ArrayBuffer(0);
			this._view = new Uint8Array(this._buffer);
		}
		//**********************************************************************************
		/**
		 * Initialize "Stream" object from existing "ArrayBuffer"
		 * @param {!ArrayBuffer} array The ArrayBuffer to copy from
		 */
		fromArrayBuffer(array)
		{
			this.buffer = array;
		}
		//**********************************************************************************
		// noinspection FunctionNamingConventionJS
		/**
		 * Initialize "Stream" object from existing "Uint8Array"
		 * @param {!Uint8Array} array The Uint8Array to copy from
		 */
		fromUint8Array(array)
		{
			this._buffer = new ArrayBuffer(array.length);
			this._view = new Uint8Array(this._buffer);
			
			this._view.set(array);
		}
		//**********************************************************************************
		/**
		 * Initialize "Stream" object from existing string
		 * @param {string} string The string to initialize from
		 */
		fromString(string)
		{
			const stringLength = string.length;
			
			this.length = stringLength;
			
			// noinspection NonBlockStatementBodyJS
			for(let i = 0; i < stringLength; i++)
				this.view[i] = string.charCodeAt(i);
		}
		//**********************************************************************************
		/**
		 * Represent "Stream" object content as a string
		 * @param {number} [start] Start position to convert to string
		 * @param {number} [length] Length of array to convert to string
		 * @returns {string}
		 */
		toString(start = 0, length = (this.view.length - start))
		{
			//region Initial variables
			let result = "";
			//endregion
			
			//region Check input parameters
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((start >= this.view.length) || (start < 0))
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((length >= this.view.length) || (length < 0))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.view.length - start;
			}
			//endregion
			
			//region Convert array of bytes to string
			// noinspection NonBlockStatementBodyJS
			for(let i = start; i < (start + length); i++)
				result += String.fromCharCode(this.view[i]);
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionTooLongJS
		/**
		 * Initialize "Stream" object from existing hexdecimal string
		 * @param {string} hexString String to initialize from
		 */
		fromHexString(hexString)
		{
			//region Initial variables
			const stringLength = hexString.length;
			
			this.buffer = new ArrayBuffer(stringLength >> 1);
			this.view = new Uint8Array(this.buffer);
			
			const hexMap = new Map();
			
			// noinspection MagicNumberJS
			hexMap.set("0", 0x00);
			// noinspection MagicNumberJS
			hexMap.set("1", 0x01);
			// noinspection MagicNumberJS
			hexMap.set("2", 0x02);
			// noinspection MagicNumberJS
			hexMap.set("3", 0x03);
			// noinspection MagicNumberJS
			hexMap.set("4", 0x04);
			// noinspection MagicNumberJS
			hexMap.set("5", 0x05);
			// noinspection MagicNumberJS
			hexMap.set("6", 0x06);
			// noinspection MagicNumberJS
			hexMap.set("7", 0x07);
			// noinspection MagicNumberJS
			hexMap.set("8", 0x08);
			// noinspection MagicNumberJS
			hexMap.set("9", 0x09);
			// noinspection MagicNumberJS
			hexMap.set("A", 0x0A);
			// noinspection MagicNumberJS
			hexMap.set("a", 0x0A);
			// noinspection MagicNumberJS
			hexMap.set("B", 0x0B);
			// noinspection MagicNumberJS
			hexMap.set("b", 0x0B);
			// noinspection MagicNumberJS
			hexMap.set("C", 0x0C);
			// noinspection MagicNumberJS
			hexMap.set("c", 0x0C);
			// noinspection MagicNumberJS
			hexMap.set("D", 0x0D);
			// noinspection MagicNumberJS
			hexMap.set("d", 0x0D);
			// noinspection MagicNumberJS
			hexMap.set("E", 0x0E);
			// noinspection MagicNumberJS
			hexMap.set("e", 0x0E);
			// noinspection MagicNumberJS
			hexMap.set("F", 0x0F);
			// noinspection MagicNumberJS
			hexMap.set("f", 0x0F);
			
			let j = 0;
			// noinspection MagicNumberJS
			let temp = 0x00;
			//endregion
			
			//region Convert char-by-char
			for(let i = 0; i < stringLength; i++)
			{
				// noinspection NegatedIfStatementJS
				if(!(i % 2))
				{
					// noinspection NestedFunctionCallJS
					temp = hexMap.get(hexString.charAt(i)) << 4;
				}
				else
				{
					// noinspection NestedFunctionCallJS
					temp |= hexMap.get(hexString.charAt(i));
					
					this.view[j] = temp;
					j++;
				}
			}
			//endregion
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Represent "Stream" object content as a hexdecimal string
		 * @param {number} [start=0] Start position to convert to string
		 * @param {number} [length=(this.view.length - start)] Length of array to convert to string
		 * @returns {string}
		 */
		toHexString(start = 0, length = (this.view.length - start))
		{
			//region Initial variables
			let result = "";
			//endregion
			
			//region Check input parameters
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((start >= this.view.length) || (start < 0))
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((length >= this.view.length) || (length < 0))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.view.length - start;
			}
			//endregion

			for(let i = start; i < (start + length); i++)
			{
				// noinspection ChainedFunctionCallJS
				const str = this.view[i].toString(16).toUpperCase();
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS
				result = result + ((str.length == 1) ? "0" : "") + str;
			}
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Return copy of existing "Stream"
		 * @param {number} [start=0] Start position of the copy
		 * @param {number} [length=this.view.length] Length of the copy
		 * @returns {ByteStream}
		 */
		copy(start = 0, length = (this._buffer.byteLength - start))
		{
			//region Check input parameters
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if((start === 0) && (this._buffer.byteLength === 0))
				return new ByteStream();
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if((start < 0) || (start > (this._buffer.byteLength - 1)))
				throw new Error(`Wrong start position: ${start}`);
			//endregion
			
			const stream = new ByteStream();
			
			stream._buffer = this._buffer.slice(start, start + length);
			stream._view = new Uint8Array(stream._buffer);
			
			return stream;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Return slice of existing "Stream"
		 * @param {number} [start=0] Start position of the slice
		 * @param {number} [end=this._buffer.byteLength] End position of the slice
		 * @returns {ByteStream}
		 */
		slice(start = 0, end = this._buffer.byteLength)
		{
			//region Check input parameters
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if((start === 0) && (this._buffer.byteLength === 0))
				return new ByteStream();
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if((start < 0) || (start > (this._buffer.byteLength - 1)))
				throw new Error(`Wrong start position: ${start}`);
			//endregion
			
			const stream = new ByteStream();
			
			stream._buffer = this._buffer.slice(start, end);
			stream._view = new Uint8Array(stream._buffer);
			
			return stream;
		}
		//**********************************************************************************
		/**
		 * Change size of existing "Stream"
		 * @param {!number} size Size for new "Stream"
		 */
		realloc(size)
		{
			//region Initial variables
			const buffer = new ArrayBuffer(size);
			const view = new Uint8Array(buffer);
			//endregion
			
			//region Create a new ArrayBuffer content
			// noinspection NonBlockStatementBodyJS
			if(size > this._view.length)
				view.set(this._view);
			else
			{
				// noinspection NestedFunctionCallJS
				view.set(new Uint8Array(this._buffer, 0, size));
			}
			//endregion
			
			//region Initialize "Stream" with new "ArrayBuffer"
			this._buffer = buffer.slice(0);
			this._view = new Uint8Array(this._buffer);
			//endregion
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Append a new "Stream" content to the current "Stream"
		 * @param {ByteStream} stream A new "stream" to append to current "stream"
		 */
		append(stream)
		{
			//region Initial variables
			const initialSize = this._buffer.byteLength;
			const streamViewLength = stream._buffer.byteLength;
			
			const copyView = stream._view.slice();
			//endregion
			
			//region Re-allocate current internal buffer
			this.realloc(initialSize + streamViewLength);
			//endregion
			
			//region Copy input stream content to a new place
			this._view.set(copyView, initialSize);
			//endregion
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Insert "Stream" content to the current "Stream" at specific position
		 * @param {ByteStream} stream A new "stream" to insert to current "stream"
		 * @param {number} [start=0] Start position to insert to
		 * @param {number} [length]
		 * @returns {boolean}
		 */
		insert(stream, start = 0, length = (this._buffer.byteLength - start))
		{
			//region Initial variables
			// noinspection NonBlockStatementBodyJS
			if(start > (this._buffer.byteLength - 1))
				return false;
			
			if(length > (this._buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this._buffer.byteLength - start;
			}
			//endregion
			
			//region Check input variables
			if(length > stream._buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = stream._buffer.byteLength;
			}
			//endregion
			
			//region Update content of the current stream
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(length == stream._buffer.byteLength)
				this._view.set(stream._view, start);
			else
			{
				// noinspection NestedFunctionCallJS
				this._view.set(stream._view.slice(0, length), start);
			}
			//endregion
			
			return true;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Check that two "Stream" objects has equal content
		 * @param {ByteStream} stream Stream to compare with
		 * @returns {boolean}
		 */
		isEqual(stream)
		{
			//region Check length of both buffers
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(this._buffer.byteLength != stream._buffer.byteLength)
				return false;
			//endregion
			
			//region Compare each byte of both buffers
			for(let i = 0; i < stream._buffer.byteLength; i++)
			{
				// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
				if(this.view[i] != stream.view[i])
					return false;
			}
			//endregion
			
			return true;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Check that current "Stream" objects has equal content with input "Uint8Array"
		 * @param {Uint8Array} view View to compare with
		 * @returns {boolean}
		 */
		isEqualView(view)
		{
			//region Check length of both buffers
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(view.length != this.view.length)
				return false;
			//endregion
			
			//region Compare each byte of both buffers
			for(let i = 0; i < view.length; i++)
			{
				// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
				if(this.view[i] != view[i])
					return false;
			}
			//endregion
			
			return true;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
		/**
		 * Find any byte pattern in "Stream"
		 * @param {ByteStream} pattern Stream having pattern value
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @param {boolean} [backward] Flag to search in backward order
		 * @returns {number}
		 */
		findPattern(pattern, start = null, length = null, backward = false)
		{
			//region Check input variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
				start = (backward) ? this.buffer.byteLength : 0;
			}
			
			if(start > this.buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = this.buffer.byteLength;
			}
			
			if(backward)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
				
				if(length > start)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
				
				if(length > (this.buffer.byteLength - start))
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
			}
			//endregion
			
			//region Initial variables
			const patternLength = pattern.buffer.byteLength;
			// noinspection NonBlockStatementBodyJS
			if(patternLength > length)
				return (-1);
			//endregion
			
			//region Make a "pre-read" array for pattern
			const patternArray = [];
			// noinspection NonBlockStatementBodyJS
			for(let i = 0; i < patternLength; i++)
				patternArray.push(pattern.view[i]);
			//endregion
			
			//region Search for pattern
			for(let i = 0; i <= (length - patternLength); i++)
			{
				let equal = true;
				// noinspection ConditionalExpressionJS
				const equalStart = (backward) ? (start - patternLength - i) : (start + i);
				
				for(let j = 0; j < patternLength; j++)
				{
					// noinspection EqualityComparisonWithCoercionJS
					if(this.view[j + equalStart] != patternArray[j])
					{
						equal = false;
						// noinspection BreakStatementJS
						break;
					}
				}
				
				if(equal)
				{
					// noinspection ConditionalExpressionJS
					return (backward) ? (start - patternLength - i) : (start + patternLength + i); // Position after the pattern found
				}
			}
			//endregion
			
			return (-1);
		}
		//**********************************************************************************
		// noinspection OverlyComplexFunctionJS
		/**
		 * Find first position of any pattern from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @param {boolean} [backward=false] Flag to search in backward order
		 * @returns {{id: number, position: number}}
		 */
		findFirstIn(patterns, start = null, length = null, backward = false)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
				start = (backward) ? this.buffer.byteLength : 0;
			}
			
			if(start > this.buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = this.buffer.byteLength;
			}
			
			if(backward)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
				
				if(length > start)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
				
				if(length > (this.buffer.byteLength - start))
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
			}
			
			// noinspection ConditionalExpressionJS
			const result = {
				id: (-1),
				position: (backward) ? 0 : (start + length),
				length: 0
			};
			//endregion
			
			for(let i = 0; i < patterns.length; i++)
			{
				const position = this.findPattern(patterns[i], start, length, backward);
				// noinspection EqualityComparisonWithCoercionJS
				if(position != (-1))
				{
					let valid = false;
					const patternLength = patterns[i].length;

					if(backward)
					{
						// noinspection NonBlockStatementBodyJS
						if((position - patternLength) >= (result.position - result.length))
							valid = true;
					}
					else
					{
						// noinspection NonBlockStatementBodyJS
						if((position - patternLength) <= (result.position - result.length))
							valid = true;
					}
					
					if(valid)
					{
						result.position = position;
						result.id = i;
						result.length = patternLength;
					}
				}
			}
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Find all positions of any pattern from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @returns {Array}
		 */
		findAllIn(patterns, start = 0, length = (this.buffer.byteLength - start))
		{
			//region Initial variables
			const result = [];
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection NonBlockStatementBodyJS
			if(start > (this.buffer.byteLength - 1))
				return result;
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}

			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			let patternFound = {
				id: (-1),
				position: start
			};
			//endregion
			
			//region Find all accurences of patterns
			do
			{
				const position = patternFound.position;
				
				patternFound = this.findFirstIn(patterns, patternFound.position, length);
				
				// noinspection EqualityComparisonWithCoercionJS
				if(patternFound.id == (-1))
				{
					// noinspection BreakStatementJS
					break;
				}
				
				// noinspection AssignmentToFunctionParameterJS
				length -= (patternFound.position - position);
				
				result.push({
					id: patternFound.id,
					position: patternFound.position
				});
			} while(true); // eslint-disable-line
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
		/**
		 * Find all positions of a pattern
		 * @param {ByteStream} pattern Stream having pattern value
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @returns {Array|number} Array with all pattern positions or (-1) if failed
		 */
		findAllPatternIn(pattern, start = 0, length = (this.buffer.byteLength - start))
		{
			//region Check input variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			if(start > this.buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = this.buffer.byteLength;
			}
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			//endregion
			
			//region Initial variables
			const result = [];
			
			const patternLength = pattern.buffer.byteLength;
			// noinspection NonBlockStatementBodyJS
			if(patternLength > length)
				return (-1);
			//endregion
			
			//region Make a "pre-read" array for pattern
			const patternArray = Array.from(pattern.view);
			//endregion
			
			//region Search for pattern
			for(let i = 0; i <= (length - patternLength); i++)
			{
				let equal = true;
				const equalStart = start + i;
				
				for(let j = 0; j < patternLength; j++)
				{
					// noinspection EqualityComparisonWithCoercionJS
					if(this.view[j + equalStart] != patternArray[j])
					{
						equal = false;
						// noinspection BreakStatementJS
						break;
					}
				}
				
				if(equal)
				{
					result.push(start + patternLength + i); // Position after the pattern found
					i += (patternLength - 1); // On next step of "for" we will have "i++"
				}
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection OverlyComplexFunctionJS, FunctionTooLongJS
		/**
		 * Find first position of data, not included in patterns from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @param {boolean} [backward=false] Flag to search in backward order
		 * @returns {{left: {id: number, position: *}, right: {id: number, position: number}, value: ByteStream}}
		 */
		findFirstNotIn(patterns, start = null, length = null, backward = false)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
				start = (backward) ? this.buffer.byteLength : 0;
			}
			
			if(start > this.buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = this.buffer.byteLength;
			}
			
			if(backward)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
				
				if(length > start)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
				
				if(length > (this.buffer.byteLength - start))
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
			}
			
			const result = {
				left: {
					id: (-1),
					position: start
				},
				right: {
					id: (-1),
					position: 0
				},
				value: new ByteStream()
			};
			
			let currentLength = length;
			//endregion
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			while(currentLength > 0)
			{
				//region Search for nearest "pattern"
				// noinspection ConditionalExpressionJS
				result.right = this.findFirstIn(patterns,
					(backward) ? (start - length + currentLength) : (start + length - currentLength),
					currentLength,
					backward);
				//endregion
				
				//region No pattern at all
				// noinspection EqualityComparisonWithCoercionJS
				if(result.right.id == (-1))
				{
					// noinspection AssignmentToFunctionParameterJS
					length = currentLength;
					
					if(backward)
					{
						// noinspection AssignmentToFunctionParameterJS
						start -= length;
					}
					else
					{
						// noinspection AssignmentToFunctionParameterJS
						start = result.left.position;
					}
					
					result.value = new ByteStream();
					
					result.value._buffer = this._buffer.slice(start, start + length);
					result.value._view = new Uint8Array(result.value._buffer);
					
					// noinspection BreakStatementJS
					break;
				}
				//endregion
				
				//region Check distance between two patterns
				// noinspection ConditionalExpressionJS, EqualityComparisonWithCoercionJS
				if(result.right.position != ((backward) ? (result.left.position - patterns[result.right.id].buffer.byteLength) : (result.left.position + patterns[result.right.id].buffer.byteLength)))
				{
					if(backward)
					{
						// noinspection AssignmentToFunctionParameterJS
						start = result.right.position + patterns[result.right.id].buffer.byteLength;
						// noinspection AssignmentToFunctionParameterJS
						length = result.left.position - result.right.position - patterns[result.right.id].buffer.byteLength;
					}
					else
					{
						// noinspection AssignmentToFunctionParameterJS
						start = result.left.position;
						// noinspection AssignmentToFunctionParameterJS
						length = result.right.position - result.left.position - patterns[result.right.id].buffer.byteLength;
					}
					
					result.value = new ByteStream();
					
					result.value._buffer = this._buffer.slice(start, start + length);
					result.value._view = new Uint8Array(result.value._buffer);
					
					// noinspection BreakStatementJS
					break;
				}
				//endregion
				
				//region Store information about previous pattern
				result.left = result.right;
				//endregion
				
				//region Change current length
				currentLength -= patterns[result.right.id]._buffer.byteLength;
				//endregion
			}
			
			//region Swap "patterns" in case of backward order
			if(backward)
			{
				const temp = result.right;
				result.right = result.left;
				result.left = temp;
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Find all positions of data, not included in patterns from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @returns {Array}
		 */
		findAllNotIn(patterns, start = null, length = null)
		{
			//region Initial variables
			const result = [];
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection NonBlockStatementBodyJS
			if(start > (this.buffer.byteLength - 1))
				return result;
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			let patternFound = {
				left: {
					id: (-1),
					position: start
				},
				right: {
					id: (-1),
					position: start
				},
				value: new ByteStream()
			};
			//endregion
			
			//region Find all accurences of patterns
			// noinspection EqualityComparisonWithCoercionJS
			do
			{
				const position = patternFound.right.position;
				
				patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);
				
				// noinspection AssignmentToFunctionParameterJS
				length -= (patternFound.right.position - position);
				
				result.push({
					left: {
						id: patternFound.left.id,
						position: patternFound.left.position
					},
					right: {
						id: patternFound.right.id,
						position: patternFound.right.position
					},
					value: patternFound.value
				});
			} while(patternFound.right.id != (-1));
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS
		/**
		 * Find position of a sequence of any patterns from input array
		 * @param {Array.<ByteStream>} patterns Array of pattern to look for
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @param {boolean} [backward=false] Flag to search in backward order
		 * @returns {*}
		 */
		findFirstSequence(patterns, start = null, length = null, backward = false)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
				start = (backward) ? this.buffer.byteLength : 0;
			}
			
			if(start > this.buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = this.buffer.byteLength;
			}
			
			if(backward)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
				
				if(length > start)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
				
				if(length > (this.buffer.byteLength - start))
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
			}
			//endregion
			
			//region Find first byte from sequence
			const firstIn = this.skipNotPatterns(patterns, start, length, backward);
			// noinspection EqualityComparisonWithCoercionJS
			if(firstIn == (-1))
			{
				return {
					position: (-1),
					value: new ByteStream()
				};
			}
			//endregion
			
			//region Find first byte not in sequence
			// noinspection ConditionalExpressionJS
			const firstNotIn = this.skipPatterns(patterns,
				firstIn,
				length - ((backward) ? (start - firstIn) : (firstIn - start)),
				backward);
			//endregion
			
			//region Make output value
			if(backward)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = firstNotIn;
				// noinspection AssignmentToFunctionParameterJS
				length = (firstIn - firstNotIn);
			}
			else
			{
				// noinspection AssignmentToFunctionParameterJS
				start = firstIn;
				// noinspection AssignmentToFunctionParameterJS
				length = (firstNotIn - firstIn);
			}
			
			const value = new ByteStream();
			
			value._buffer = this._buffer.slice(start, start + length);
			value._view = new Uint8Array(value._buffer);
			//endregion
			
			return {
				position: firstNotIn,
				value
			};
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Find all positions of a sequence of any patterns from input array
		 * @param {Array.<ByteStream>} patterns Array of patterns to search for
		 * @param {?number} [start] Start position to search from
		 * @param {?number} [length] Length of byte block to search at
		 * @returns {Array}
		 */
		findAllSequences(patterns, start = null, length = null)
		{
			//region Initial variables
			const result = [];
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection NonBlockStatementBodyJS
			if(start > (this.buffer.byteLength - 1))
				return result;
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			let patternFound = {
				position: start,
				value: new ByteStream()
			};
			//endregion
			
			//region Find all accurences of patterns
			// noinspection EqualityComparisonWithCoercionJS
			do
			{
				const position = patternFound.position;
				
				patternFound = this.findFirstSequence(patterns, patternFound.position, length);
				
				// noinspection EqualityComparisonWithCoercionJS
				if(patternFound.position != (-1))
				{
					// noinspection AssignmentToFunctionParameterJS
					length -= (patternFound.position - position);
					
					result.push({
						position: patternFound.position,
						value: patternFound.value
					});
				}
				
			} while(patternFound.position != (-1));
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
		/**
		 * Find all paired patterns in the stream
		 * @param {ByteStream} leftPattern Left pattern to search for
		 * @param {ByteStream} rightPattern Right pattern to search for
		 * @param {?number} [start=null] Start position to search from
		 * @param {?number} [length=null] Length of byte block to search at
		 * @returns {Array}
		 */
		findPairedPatterns(leftPattern, rightPattern, start = null, length = null)
		{
			//region Initial variables
			const result = [];
			
			// noinspection NonBlockStatementBodyJS
			if(leftPattern.isEqual(rightPattern))
				return result;
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection NonBlockStatementBodyJS
			if(start > (this.buffer.byteLength - 1))
				return result;
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			let currentPositionLeft = 0;
			//endregion
			
			//region Find all "left patterns" as sorted array
			const leftPatterns = this.findAllPatternIn(leftPattern, start, length);
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(leftPatterns.length == 0)
				return result;
			//endregion
			
			//region Find all "right patterns" as sorted array
			const rightPatterns = this.findAllPatternIn(rightPattern, start, length);
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(rightPatterns.length == 0)
				return result;
			//endregion
			
			//region Combine patterns
			while(currentPositionLeft < leftPatterns.length)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS
				if(rightPatterns.length == 0)
				{
					// noinspection BreakStatementJS
					break;
				}
				
				// noinspection EqualityComparisonWithCoercionJS
				if(leftPatterns[0] == rightPatterns[0])
				{
					// Possible situation when one pattern is a part of another
					// For example "stream" and "endstream"
					// In case when we have only "endstream" in fact "stream" will be also found at the same position
					// (position of the pattern is an index AFTER the pattern)
					
					result.push({
						left: leftPatterns[0],
						right: rightPatterns[0]
					});
					
					leftPatterns.splice(0, 1);
					rightPatterns.splice(0, 1);
					
					// noinspection ContinueStatementJS
					continue;
				}
				
				if(leftPatterns[currentPositionLeft] > rightPatterns[0])
				{
					// noinspection BreakStatementJS
					break;
				}
				
				while(leftPatterns[currentPositionLeft] < rightPatterns[0])
				{
					currentPositionLeft++;
					
					if(currentPositionLeft >= leftPatterns.length)
					{
						// noinspection BreakStatementJS
						break;
					}
				}
				
				result.push({
					left: leftPatterns[currentPositionLeft - 1],
					right: rightPatterns[0]
				});
				
				leftPatterns.splice(currentPositionLeft - 1, 1);
				rightPatterns.splice(0, 1);
				
				currentPositionLeft = 0;
			}
			//endregion
			
			//region Sort result
			result.sort((a, b) => (a.left - b.left));
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
		/**
		 * Find all paired patterns in the stream
		 * @param {Array.<ByteStream>} inputLeftPatterns Array of left patterns to search for
		 * @param {Array.<ByteStream>} inputRightPatterns Array of right patterns to search for
		 * @param {?number} [start=null] Start position to search from
		 * @param {?number} [length=null] Length of byte block to search at
		 * @returns {Array}
		 */
		findPairedArrays(inputLeftPatterns, inputRightPatterns, start = null, length = null)
		{
			//region Initial variables
			const result = [];
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection NonBlockStatementBodyJS
			if(start > (this.buffer.byteLength - 1))
				return result;
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			let currentPositionLeft = 0;
			//endregion
			
			//region Find all "left patterns" as sorted array
			const leftPatterns = this.findAllIn(inputLeftPatterns, start, length);
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(leftPatterns.length == 0)
				return result;
			//endregion
			
			//region Find all "right patterns" as sorted array
			const rightPatterns = this.findAllIn(inputRightPatterns, start, length);
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(rightPatterns.length == 0)
				return result;
			//endregion
			
			//region Combine patterns
			while(currentPositionLeft < leftPatterns.length)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS
				if(rightPatterns.length == 0)
				{
					// noinspection BreakStatementJS
					break;
				}
				
				// noinspection EqualityComparisonWithCoercionJS
				if(leftPatterns[0].position == rightPatterns[0].position)
				{
					// Possible situation when one pattern is a part of another
					// For example "stream" and "endstream"
					// In case when we have only "endstream" in fact "stream" will be also found at the same position
					// (position of the pattern is an index AFTER the pattern)
					
					result.push({
						left: leftPatterns[0],
						right: rightPatterns[0]
					});
					
					leftPatterns.splice(0, 1);
					rightPatterns.splice(0, 1);
					
					// noinspection ContinueStatementJS
					continue;
				}
				
				if(leftPatterns[currentPositionLeft].position > rightPatterns[0].position)
				{
					// noinspection BreakStatementJS
					break;
				}
				
				while(leftPatterns[currentPositionLeft].position < rightPatterns[0].position)
				{
					currentPositionLeft++;
					
					if(currentPositionLeft >= leftPatterns.length)
					{
						// noinspection BreakStatementJS
						break;
					}
				}
				
				result.push({
					left: leftPatterns[currentPositionLeft - 1],
					right: rightPatterns[0]
				});
				
				leftPatterns.splice(currentPositionLeft - 1, 1);
				rightPatterns.splice(0, 1);
				
				currentPositionLeft = 0;
			}
			//endregion
			
			//region Sort result
			result.sort((a, b) => (a.left.position - b.left.position));
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS, FunctionTooLongJS
		/**
		 * Replace one patter with other
		 * @param {ByteStream} searchPattern The pattern to search for
		 * @param {ByteStream} replacePattern The pattern to replace initial pattern
		 * @param {?number} [start=null] Start position to search from
		 * @param {?number} [length=null] Length of byte block to search at
		 * @param {Array|null} [findAllResult=null] Pre-calculated results of "findAllIn"
		 * @returns {*}
		 */
		replacePattern(searchPattern, replacePattern, start = null, length = null, findAllResult = null)
		{
			//region Initial variables
			let result;
			
			let i;
			const output = {
				status: (-1),
				searchPatternPositions: [],
				replacePatternPositions: []
			};
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = 0;
			}
			
			// noinspection NonBlockStatementBodyJS
			if(start > (this.buffer.byteLength - 1))
				return false;
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			//endregion
			
			//region Find a pattern to search for
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if(findAllResult == null)
			{
				result = this.findAllIn([searchPattern], start, length);
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
				if(result.length == 0)
					return output;
			}
			else
				result = findAllResult;
			
			// noinspection NestedFunctionCallJS
			output.searchPatternPositions.push(...Array.from(result, element => element.position));
			//endregion
			
			//region Variables for new buffer initialization
			const patternDifference = searchPattern.buffer.byteLength - replacePattern.buffer.byteLength;
			
			const changedBuffer = new ArrayBuffer(this.view.length - (result.length * patternDifference));
			const changedView = new Uint8Array(changedBuffer);
			//endregion
			
			//region Copy data from 0 to start
			// noinspection NestedFunctionCallJS
			changedView.set(new Uint8Array(this.buffer, 0, start));
			//endregion
			
			//region Replace pattern
			for(i = 0; i < result.length; i++)
			{
				//region Initial variables
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS
				const currentPosition = (i == 0) ? start : result[i - 1].position;
				//endregion
				
				//region Copy bytes other then search pattern
				// noinspection NestedFunctionCallJS
				changedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.buffer.byteLength - currentPosition), currentPosition - i * patternDifference);
				//endregion
				
				//region Put replace pattern in a new buffer
				changedView.set(replacePattern.view, result[i].position - searchPattern.buffer.byteLength - i * patternDifference);
				
				output.replacePatternPositions.push(result[i].position - searchPattern.buffer.byteLength - i * patternDifference);
				//endregion
			}
			//endregion
			
			//region Copy data from the end of old buffer
			i--;
			// noinspection NestedFunctionCallJS
			changedView.set(new Uint8Array(this.buffer, result[i].position, this.buffer.byteLength - result[i].position), result[i].position - searchPattern.buffer.byteLength + replacePattern.buffer.byteLength - i * patternDifference);
			//endregion
			
			//region Re-initialize existing buffer
			this.buffer = changedBuffer;
			this.view = new Uint8Array(this.buffer);
			//endregion
			
			output.status = 1;
			
			return output;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
		/**
		 * Skip any pattern from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @param {?number} [start=null] Start position to search from
		 * @param {?number} [length=null] Length of byte block to search at
		 * @param {boolean} [backward=false] Flag to search in backward order
		 * @returns {*}
		 */
		skipPatterns(patterns, start = null, length = null, backward = false)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
				start = (backward) ? this.buffer.byteLength : 0;
			}
			
			if(start > this.buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = this.buffer.byteLength;
			}
			
			if(backward)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
				
				if(length > start)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
				
				if(length > (this.buffer.byteLength - start))
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
			}
			
			let result = start;
			//endregion
			
			//region Search for pattern
			for(let k = 0; k < patterns.length; k++)
			{
				const patternLength = patterns[k].buffer.byteLength;
				// noinspection ConditionalExpressionJS
				const equalStart = (backward) ? (result - patternLength) : (result);
				let equal = true;
				
				for(let j = 0; j < patternLength; j++)
				{
					// noinspection EqualityComparisonWithCoercionJS
					if(this.view[j + equalStart] != patterns[k].view[j])
					{
						equal = false;
						// noinspection BreakStatementJS
						break;
					}
				}
				
				if(equal)
				{
					k = (-1);
					
					if(backward)
					{
						result -= patternLength;
						// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
						if(result <= 0)
							return result;
					}
					else
					{
						result += patternLength;
						// noinspection NonBlockStatementBodyJS
						if(result >= (start + length))
							return result;
					}
				}
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS
		/**
		 * Skip any pattern not from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should not be ommited
		 * @param start
		 * @param length
		 * @param backward
		 * @returns {number}
		 */
		skipNotPatterns(patterns, start = null, length = null, backward = false)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(start == null)
			{
				// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
				start = (backward) ? this.buffer.byteLength : 0;
			}
			
			if(start > this.buffer.byteLength)
			{
				// noinspection AssignmentToFunctionParameterJS
				start = this.buffer.byteLength;
			}
			
			if(backward)
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
				
				if(length > start)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = start;
				}
			}
			else
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
				if(length == null)
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
				
				if(length > (this.buffer.byteLength - start))
				{
					// noinspection AssignmentToFunctionParameterJS
					length = this.buffer.byteLength - start;
				}
			}
			
			let result = (-1);
			//endregion
			
			//region Search for pattern
			for(let i = 0; i < length; i++)
			{
				for(let k = 0; k < patterns.length; k++)
				{
					const patternLength = patterns[k].buffer.byteLength;
					// noinspection ConditionalExpressionJS
					const equalStart = (backward) ? (start - i - patternLength) : (start + i);
					let equal = true;
					
					for(let j = 0; j < patternLength; j++)
					{
						// noinspection EqualityComparisonWithCoercionJS
						if(this.view[j + equalStart] != patterns[k].view[j])
						{
							equal = false;
							// noinspection BreakStatementJS
							break;
						}
					}
					
					if(equal)
					{
						// noinspection ConditionalExpressionJS
						result = (backward) ? (start - i) : (start + i); // Exact position of pattern found
						// noinspection BreakStatementJS
						break;
					}
				}
				
				// noinspection EqualityComparisonWithCoercionJS
				if(result != (-1))
				{
					// noinspection BreakStatementJS
					break;
				}
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	class SeqStream 
	{
		//**********************************************************************************
		/**
		 * Constructor for "SeqStream" class
		 * @param {{[stream]: ByteStream, [length]: number, [backward]: boolean, [start]: number, [appendBlock]: number}} parameters
		 */
		constructor(parameters = {})
		{
			/**
			 * Major stream
			 * @type {ByteStream}
			 */
			this.stream = new ByteStream();
			/**
			 * Length of the major stream
			 * @type {number}
			 */
			this._length = 0;
			/**
			 * Flag to search in backward direction
			 * @type {boolean}
			 */
			this.backward = false;
			/**
			 * Start position to search
			 * @type {number}
			 */
			this._start = 0;
			/**
			 * Length of a block when append information to major stream
			 * @type {number}
			 */
			this.appendBlock = 0;
			
			this.prevLength = 0;
			this.prevStart = 0;
			
			for(const key of Object.keys(parameters))
			{
				switch(key)
				{
					case "stream":
						this.stream = parameters.stream;
						break;
					case "backward":
						this.backward = parameters.backward;
						// noinspection JSUnusedGlobalSymbols
						this._start = this.stream.buffer.byteLength;
						break;
					case "length":
						// noinspection JSUnusedGlobalSymbols
						this._length = parameters.length;
						break;
					case "start":
						// noinspection JSUnusedGlobalSymbols
						this._start = parameters.start;
						break;
					case "appendBlock":
						this.appendBlock = parameters.appendBlock;
						break;
					case "view":
						this.stream = new ByteStream({ view: parameters.view});
						break;
					case "buffer":
						this.stream = new ByteStream({ buffer: parameters.buffer});
						break;
					case "string":
						this.stream = new ByteStream({ string: parameters.string});
						break;
					case "hexstring":
						this.stream = new ByteStream({ hexstring: parameters.hexstring});
						break;
					default:
				}
			}
		}
		//**********************************************************************************
		/**
		 * Setter for "stream" property
		 * @param {ByteStream} value
		 */
		set stream(value)
		{
			this._stream = value;
			
			this.prevLength = this._length;
			// noinspection JSUnusedGlobalSymbols
			this._length = value._buffer.byteLength;
			
			this.prevStart = this._start;
			// noinspection JSUnusedGlobalSymbols
			this._start = 0;
		}
		//**********************************************************************************
		/**
		 * Getter for "stream" property
		 * @returns {ByteStream}
		 */
		get stream()
		{
			return this._stream;
		}
		//**********************************************************************************
		/**
		 * Setter for "length" property
		 * @param {number} value
		 */
		set length(value)
		{
			this.prevLength = this._length;
			// noinspection JSUnusedGlobalSymbols
			this._length = value;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Getter for "length" property
		 * @returns {number}
		 */
		get length()
		{
			// noinspection NonBlockStatementBodyJS
			if(this.appendBlock)
				return this.start;
			
			return this._length;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Setter for "start" property
		 * @param {number} value
		 */
		set start(value)
		{
			// noinspection NonBlockStatementBodyJS
			if(value > this.stream.buffer.byteLength)
				return;
			
			//region Initialization of "prev" internal variables
			this.prevStart = this._start;
			this.prevLength = this._length;
			//endregion
			
			// noinspection JSUnusedGlobalSymbols, ConditionalExpressionJS
			this._length -= ((this.backward) ? (this._start - value) : (value - this._start));
			// noinspection JSUnusedGlobalSymbols
			this._start = value;
		}
		//**********************************************************************************
		/**
		 * Getter for "start" property
		 * @returns {number}
		 */
		get start()
		{
			return this._start;
		}
		//**********************************************************************************
		/**
		 * Return ArrayBuffer with having value of existing SeqStream length
		 * @return {ArrayBuffer}
		 */
		get buffer()
		{
			return this._stream._buffer.slice(0, this._length);
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Reset current position of the "SeqStream"
		 */
		resetPosition()
		{
			// noinspection JSUnusedGlobalSymbols
			this._start = this.prevStart;
			// noinspection JSUnusedGlobalSymbols
			this._length = this.prevLength;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Find any byte pattern in "ByteStream"
		 * @param {ByteStream} pattern Stream having pattern value
		 * @param {?number} [gap] Maximum gap between start position and position of nearest object
		 * @returns {number}
		 */
		findPattern(pattern, gap = null)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((gap == null) || (gap > this.length))
			{
				// noinspection AssignmentToFunctionParameterJS
				gap = this.length;
			}
			//endregion
			
			//region Find pattern
			const result = this.stream.findPattern(pattern, this.start, this.length, this.backward);
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(result == (-1))
				return result;
			
			if(this.backward)
			{
				// noinspection NonBlockStatementBodyJS
				if(result < (this.start - pattern.buffer.byteLength - gap))
					return (-1);
			}
			else
			{
				// noinspection NonBlockStatementBodyJS
				if(result > (this.start + pattern.buffer.byteLength + gap))
					return (-1);
			}
			//endregion
			
			//region Create new values
			this.start = result;
			//endregion ;
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Find first position of any pattern from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
		 * @param {?number} [gap] Maximum gap between start position and position of nearest object
		 * @returns {{id: number, position: number}}
		 */
		findFirstIn(patterns, gap = null)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((gap == null) || (gap > this.length))
			{
				// noinspection AssignmentToFunctionParameterJS
				gap = this.length;
			}
			//endregion
			
			//region Search for patterns
			const result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(result.id == (-1))
				return result;
			
			if(this.backward)
			{
				if(result.position < (this.start - patterns[result.id].buffer.byteLength - gap))
				{
					// noinspection ConditionalExpressionJS
					return {
						id: (-1),
						position: (this.backward) ? 0 : (this.start + this.length)
					};
				}
			}
			else
			{
				if(result.position > (this.start + patterns[result.id].buffer.byteLength + gap))
				{
					// noinspection ConditionalExpressionJS
					return {
						id: (-1),
						position: (this.backward) ? 0 : (this.start + this.length)
					};
				}
			}
			//endregion
			
			//region Create new values
			this.start = result.position;
			//endregion ;
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Find all positions of any pattern from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
		 * @returns {Array}
		 */
		findAllIn(patterns)
		{
			// In case of "backward order" the start position is at the end on stream.
			// In case of "normal order" the start position is at the begging of the stream.
			// But in fact for search for all patterns we need to have start position in "normal order".
			// noinspection ConditionalExpressionJS
			const start = (this.backward) ? (this.start - this.length) : this.start;
			
			return this.stream.findAllIn(patterns, start, this.length);
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS
		/**
		 * Find first position of data, not included in patterns from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @param {?number} gap Maximum gap between start position and position of nearest object
		 * @returns {*}
		 */
		findFirstNotIn(patterns, gap = null)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((gap == null) || (gap > this._length))
			{
				// noinspection AssignmentToFunctionParameterJS
				gap = this._length;
			}
			//endregion
			
			//region Search for patterns
			const result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if((result.left.id == (-1)) && (result.right.id == (-1)))
				return result;
			
			if(this.backward)
			{
				// noinspection EqualityComparisonWithCoercionJS
				if(result.right.id != (-1))
				{
					if(result.right.position < (this._start - patterns[result.right.id]._buffer.byteLength - gap))
					{
						return {
							left: {
								id: (-1),
								position: this._start
							},
							right: {
								id: (-1),
								position: 0
							},
							value: new ByteStream()
						};
					}
				}
			}
			else
			{
				// noinspection EqualityComparisonWithCoercionJS
				if(result.left.id != (-1))
				{
					if(result.left.position > (this._start + patterns[result.left.id]._buffer.byteLength + gap))
					{
						return {
							left: {
								id: (-1),
								position: this._start
							},
							right: {
								id: (-1),
								position: 0
							},
							value: new ByteStream()
						};
					}
				}
			}
			//endregion
			
			//region Create new values
			if(this.backward)
			{
				// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
				if(result.left.id == (-1))
					this.start = 0;
				else
					this.start = result.left.position;
			}
			else
			{
				// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
				if(result.right.id == (-1))
					this.start = (this._start + this._length);
				else
					this.start = result.right.position;
			}
			//endregion ;
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Find all positions of data, not included in patterns from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @returns {Array}
		 */
		findAllNotIn(patterns)
		{
			// In case of "backward order" the start position is at the end on stream.
			// In case of "normal order" the start position is at the begging of the stream.
			// But in fact for search for all patterns we need to have start position in "normal order".
			// noinspection ConditionalExpressionJS
			const start = (this.backward) ? (this._start - this._length) : this._start;
			
			return this._stream.findAllNotIn(patterns, start, this._length);
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Find position of a sequence of any patterns from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @param {?number} [length] Length to search sequence for
		 * @param {?number} [gap] Maximum gap between start position and position of nearest object
		 * @returns {*}
		 */
		findFirstSequence(patterns, length = null, gap = null)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((length == null) || (length > this._length))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this._length;
			}
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((gap == null) || (gap > length))
			{
				// noinspection AssignmentToFunctionParameterJS
				gap = length;
			}
			//endregion
			
			//region Search for sequence
			const result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(result.value.buffer.byteLength == 0)
				return result;
			
			if(this.backward)
			{
				if(result.position < (this._start - result.value._buffer.byteLength - gap))
				{
					return {
						position: (-1),
						value: new ByteStream()
					};
				}
			}
			else
			{
				if(result.position > (this._start + result.value._buffer.byteLength + gap))
				{
					return {
						position: (-1),
						value: new ByteStream()
					};
				}
			}
			//endregion
			
			//region Create new values
			this.start = result.position;
			//endregion ;
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Find position of a sequence of any patterns from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
		 * @returns {Array}
		 */
		findAllSequences(patterns)
		{
			// In case of "backward order" the start position is at the end on stream.
			// In case of "normal order" the start position is at the begging of the stream.
			// But in fact for search for all patterns we need to have start position in "normal order".
			// noinspection ConditionalExpressionJS
			const start = (this.backward) ? (this.start - this.length) : this.start;
			
			return this.stream.findAllSequences(patterns, start, this.length);
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Find all paired patterns in the stream
		 * @param {ByteStream} leftPattern Left pattern to search for
		 * @param {ByteStream} rightPattern Right pattern to search for
		 * @param {?number} [gap] Maximum gap between start position and position of nearest object
		 * @returns {Array}
		 */
		findPairedPatterns(leftPattern, rightPattern, gap = null)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((gap == null) || (gap > this.length))
			{
				// noinspection AssignmentToFunctionParameterJS
				gap = this.length;
			}
			//endregion
			
			// In case of "backward order" the start position is at the end on stream.
			// In case of "normal order" the start position is at the begging of the stream.
			// But in fact for search for all patterns we need to have start position in "normal order".
			// noinspection ConditionalExpressionJS
			const start = (this.backward) ? (this.start - this.length) : this.start;
			
			//region Search for patterns
			const result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);
			if(result.length)
			{
				if(this.backward)
				{
					// noinspection NonBlockStatementBodyJS
					if(result[0].right < (this.start - rightPattern.buffer.byteLength - gap))
						return [];
				}
				else
				{
					// noinspection NonBlockStatementBodyJS
					if(result[0].left > (this.start + leftPattern.buffer.byteLength + gap))
						return [];
				}
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Find all paired patterns in the stream
		 * @param {Array.<ByteStream>} leftPatterns Array of left patterns to search for
		 * @param {Array.<ByteStream>} rightPatterns Array of right patterns to search for
		 * @param {?number} [gap] Maximum gap between start position and position of nearest object
		 * @returns {Array}
		 */
		findPairedArrays(leftPatterns, rightPatterns, gap = null)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if((gap == null) || (gap > this.length))
			{
				// noinspection AssignmentToFunctionParameterJS
				gap = this.length;
			}
			//endregion
			
			// In case of "backward order" the start position is at the end on stream.
			// In case of "normal order" the start position is at the begging of the stream.
			// But in fact for search for all patterns we need to have start position in "normal order".
			// noinspection ConditionalExpressionJS
			const start = (this.backward) ? (this.start - this.length) : this.start;
			
			//region Search for patterns
			const result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);
			if(result.length)
			{
				if(this.backward)
				{
					// noinspection NonBlockStatementBodyJS
					if(result[0].right.position < (this.start - rightPatterns[result[0].right.id].buffer.byteLength - gap))
						return [];
				}
				else
				{
					// noinspection NonBlockStatementBodyJS
					if(result[0].left.position > (this.start + leftPatterns[result[0].left.id].buffer.byteLength + gap))
						return [];
				}
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Replace one patter with other
		 * @param {ByteStream} searchPattern The pattern to search for
		 * @param {ByteStream} replacePattern The pattern to replace initial pattern
		 * @returns {*}
		 */
		replacePattern(searchPattern, replacePattern)
		{
			// In case of "backward order" the start position is at the end on stream.
			// In case of "normal order" the start position is at the begging of the stream.
			// But in fact for search for all patterns we need to have start position in "normal order".
			// noinspection ConditionalExpressionJS
			const start = (this.backward) ? (this.start - this.length) : this.start;
			
			return this.stream.replacePattern(searchPattern, replacePattern, start, this.length);
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Skip of any pattern from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @returns {*}
		 */
		skipPatterns(patterns)
		{
			const result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);
			
			//region Create new values
			this.start = result;
			//endregion ;
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
		/**
		 * Skip of any pattern from input array
		 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
		 * @returns {number}
		 */
		skipNotPatterns(patterns)
		{
			const result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(result == (-1))
				return (-1);
			
			//region Create new values
			this.start = result;
			//endregion ;
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Append a new "Stream" content to the current "Stream"
		 * @param {ByteStream} stream A new "stream" to append to current "stream"
		 */
		append(stream)
		{
			if((this._start + stream._buffer.byteLength) > this._stream._buffer.byteLength)
			{
				if(stream._buffer.byteLength > this.appendBlock)
				{
					// noinspection MagicNumberJS
					this.appendBlock = (stream._buffer.byteLength + 1000);
				}
				
				this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
			}
			
			this._stream._view.set(stream._view, this._start);
			
			this._length += (stream._buffer.byteLength * 2);
			this.start = (this._start + stream._buffer.byteLength);
			this.prevLength -= (stream._buffer.byteLength * 2);
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Append a "view" content to the current "Stream"
		 * @param {Uint8Array} view A new "view" to append to current "stream"
		 */
		appendView(view)
		{
			if((this._start + view.length) > this._stream._buffer.byteLength)
			{
				if(view.length > this.appendBlock)
				{
					// noinspection MagicNumberJS
					this.appendBlock = (view.length + 1000);
				}
				
				this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
			}
			
			this._stream._view.set(view, this._start);
			
			this._length += (view.length * 2);
			this.start = (this._start + view.length);
			this.prevLength -= (view.length * 2);
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols
		/**
		 * Append a new char to the current "Stream"
		 * @param {number} char A new char to append to current "stream"
		 */
		appendChar(char)
		{
			if((this._start + 1) > this._stream._buffer.byteLength)
			{
				// noinspection ConstantOnLefSideOfComparisonJS
				if(1 > this.appendBlock)
				{
					// noinspection MagicNumberJS
					this.appendBlock = 1000;
				}
				
				this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
			}
			
			this._stream._view[this._start] = char;
			
			this._length += 2;
			this.start = (this._start + 1);
			this.prevLength -= 2;
		}
		//**********************************************************************************
		// noinspection FunctionNamingConventionJS
		/**
		 * Append a new number to the current "Stream"
		 * @param {number} number A new unsigned 16-bit integer to append to current "stream"
		 */
		appendUint16(number)
		{
			if((this._start + 2) > this._stream._buffer.byteLength)
			{
				// noinspection ConstantOnLefSideOfComparisonJS
				if(2 > this.appendBlock)
				{
					// noinspection MagicNumberJS
					this.appendBlock = 1000;
				}
				
				this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
			}
			
			const value = new Uint16Array([number]);
			const view = new Uint8Array(value.buffer);
			
			this._stream._view[this._start] = view[1];
			this._stream._view[this._start + 1] = view[0];
			
			this._length += 4;
			this.start = (this._start + 2);
			this.prevLength -= 4;
		}
		//**********************************************************************************
		// noinspection FunctionNamingConventionJS
		/**
		 * Append a new number to the current "Stream"
		 * @param {number} number A new unsigned 24-bit integer to append to current "stream"
		 */
		appendUint24(number)
		{
			if((this._start + 3) > this._stream._buffer.byteLength)
			{
				// noinspection ConstantOnLefSideOfComparisonJS
				if(3 > this.appendBlock)
				{
					// noinspection MagicNumberJS
					this.appendBlock = 1000;
				}
				
				this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
			}
			
			const value = new Uint32Array([number]);
			const view = new Uint8Array(value.buffer);
			
			this._stream._view[this._start] = view[2];
			this._stream._view[this._start + 1] = view[1];
			this._stream._view[this._start + 2] = view[0];
			
			this._length += 6;
			this.start = (this._start + 3);
			this.prevLength -= 6;
		}
		//**********************************************************************************
		// noinspection FunctionNamingConventionJS
		/**
		 * Append a new number to the current "Stream"
		 * @param {number} number A new unsigned 32-bit integer to append to current "stream"
		 */
		appendUint32(number)
		{
			if((this._start + 4) > this._stream._buffer.byteLength)
			{
				// noinspection ConstantOnLefSideOfComparisonJS
				if(4 > this.appendBlock)
				{
					// noinspection MagicNumberJS
					this.appendBlock = 1000;
				}
				
				this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
			}
			
			const value = new Uint32Array([number]);
			const view = new Uint8Array(value.buffer);
			
			this._stream._view[this._start] = view[3];
			this._stream._view[this._start + 1] = view[2];
			this._stream._view[this._start + 2] = view[1];
			this._stream._view[this._start + 3] = view[0];
			
			this._length += 8;
			this.start = (this._start + 4);
			this.prevLength -= 8;
		}
		//**********************************************************************************
		// noinspection FunctionWithMultipleReturnPointsJS
		/**
		 * Get a block of data
		 * @param {number} size Size of the data block to get
		 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
		 * @returns {Array}
		 */
		getBlock(size, changeLength = true)
		{
			//region Check input parameters
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if(this._length <= 0)
				return [];
			
			if(this._length < size)
			{
				// noinspection AssignmentToFunctionParameterJS
				size = this._length;
			}
			//endregion
			
			//region Initial variables
			let result;
			//endregion
			
			//region Getting result depends on "backward" flag
			if(this.backward)
			{
				const buffer = this._stream._buffer.slice(this._length - size, this._length);
				const view = new Uint8Array(buffer);
				
				result = new Array(size);
				
				// noinspection NonBlockStatementBodyJS
				for(let i = 0; i < size; i++)
					result[size - 1 - i] = view[i];
			}
			else
			{
				const buffer = this._stream._buffer.slice(this._start, this._start + size);
				
				// noinspection NestedFunctionCallJS
				result = Array.from(new Uint8Array(buffer));
			}
			//endregion
			
			//region Change "length" value if needed
			if(changeLength)
			{
				// noinspection ConditionalExpressionJS
				this.start += ((this.backward) ? ((-1) * size) : size);
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS
		/**
		 * Get 2-byte unsigned integer value
		 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
		 * @returns {number}
		 */
		getUint16(changeLength = true)
		{
			const block = this.getBlock(2, changeLength);
			
			//region Check posibility for convertion
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if(block.length < 2)
				return 0;
			//endregion
			
			//region Convert byte array to "Uint32Array" value
			const value = new Uint16Array(1);
			const view = new Uint8Array(value.buffer);
			
			view[0] = block[1];
			view[1] = block[0];
			//endregion
			
			return value[0];
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS
		/**
		 * Get 3-byte unsigned integer value
		 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
		 * @returns {number}
		 */
		getUint24(changeLength = true)
		{
			const block = this.getBlock(3, changeLength);
			
			//region Check posibility for convertion
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if(block.length < 3)
				return 0;
			//endregion
			
			//region Convert byte array to "Uint32Array" value
			const value = new Uint32Array(1);
			const view = new Uint8Array(value.buffer);
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			for(let i = 3; i >= 1; i--)
				view[3 - i] = block[i - 1];
			//endregion
			
			return value[0];
		}
		//**********************************************************************************
		// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS
		/**
		 * Get 4-byte unsigned integer value
		 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
		 * @returns {number}
		 */
		getUint32(changeLength = true)
		{
			const block = this.getBlock(4, changeLength);
			
			//region Check posibility for convertion
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			if(block.length < 4)
				return 0;
			//endregion
			
			//region Convert byte array to "Uint32Array" value
			const value = new Uint32Array(1);
			const view = new Uint8Array(value.buffer);
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
			for(let i = 3; i >= 0; i--)
				view[3 - i] = block[i];
			//endregion
			
			return value[0];
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	class SignedCertificateTimestamp
	{
		//**********************************************************************************
		/**
		 * Constructor for SignedCertificateTimestamp class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {number}
			 * @desc version
			 */
			this.version = getParametersValue$2(parameters, "version", SignedCertificateTimestamp.defaultValues("version"));
			/**
			 * @type {ArrayBuffer}
			 * @desc logID
			 */
			this.logID = getParametersValue$2(parameters, "logID", SignedCertificateTimestamp.defaultValues("logID"));
			/**
			 * @type {Date}
			 * @desc timestamp
			 */
			this.timestamp = getParametersValue$2(parameters, "timestamp", SignedCertificateTimestamp.defaultValues("timestamp"));
			/**
			 * @type {ArrayBuffer}
			 * @desc extensions
			 */
			this.extensions = getParametersValue$2(parameters, "extensions", SignedCertificateTimestamp.defaultValues("extensions"));
			/**
			 * @type {string}
			 * @desc hashAlgorithm
			 */
			this.hashAlgorithm = getParametersValue$2(parameters, "hashAlgorithm", SignedCertificateTimestamp.defaultValues("hashAlgorithm"));
			/**
			 * @type {string}
			 * @desc signatureAlgorithm
			 */
			this.signatureAlgorithm = getParametersValue$2(parameters, "signatureAlgorithm", SignedCertificateTimestamp.defaultValues("signatureAlgorithm"));
			/**
			 * @type {Object}
			 * @desc signature
			 */
			this.signature = getParametersValue$2(parameters, "signature", SignedCertificateTimestamp.defaultValues("signature"));
			//endregion
			
			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
			
			//region If input argument array contains "stream"
			if("stream" in parameters)
				this.fromStream(parameters.stream);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "version":
					return 0;
				case "logID":
				case "extensions":
					return new ArrayBuffer(0);
				case "timestamp":
					return new Date(0);
				case "hashAlgorithm":
				case "signatureAlgorithm":
					return "";
				case "signature":
					return new Any();
				default:
					throw new Error(`Invalid member name for SignedCertificateTimestamp class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			if((schema instanceof RawData) === false)
				throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
			
			const seqStream = new SeqStream({
				stream: new ByteStream({
					buffer: schema.data
				})
			});
			
			this.fromStream(seqStream);
		}
		//**********************************************************************************
		/**
		 * Convert SeqStream data into current class
		 * @param {!SeqStream} stream
		 */
		fromStream(stream)
		{
			const blockLength = stream.getUint16();
			
			this.version = (stream.getBlock(1))[0];
			
			if(this.version === 0)
			{
				this.logID = (new Uint8Array(stream.getBlock(32))).buffer.slice(0);
				this.timestamp = new Date(utilFromBase$2(new Uint8Array(stream.getBlock(8)), 8));
				
				//region Extensions
				const extensionsLength = stream.getUint16();
				this.extensions = (new Uint8Array(stream.getBlock(extensionsLength))).buffer.slice(0);
				//endregion
				
				//region Hash algorithm
				switch((stream.getBlock(1))[0])
				{
					case 0:
						this.hashAlgorithm = "none";
						break;
					case 1:
						this.hashAlgorithm = "md5";
						break;
					case 2:
						this.hashAlgorithm = "sha1";
						break;
					case 3:
						this.hashAlgorithm = "sha224";
						break;
					case 4:
						this.hashAlgorithm = "sha256";
						break;
					case 5:
						this.hashAlgorithm = "sha384";
						break;
					case 6:
						this.hashAlgorithm = "sha512";
						break;
					default:
						throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
				}
				//endregion
				
				//region Signature algorithm
				switch((stream.getBlock(1))[0])
				{
					case 0:
						this.signatureAlgorithm = "anonymous";
						break;
					case 1:
						this.signatureAlgorithm = "rsa";
						break;
					case 2:
						this.signatureAlgorithm = "dsa";
						break;
					case 3:
						this.signatureAlgorithm = "ecdsa";
						break;
					default:
						throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
				}
				//endregion
				
				//region Signature
				const signatureLength = stream.getUint16();
				const signatureData = (new Uint8Array(stream.getBlock(signatureLength))).buffer.slice(0);
				
				const asn1 = fromBER$1(signatureData);
				if(asn1.offset === (-1))
					throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
				
				this.signature = asn1.result;
				//endregion
				
				if(blockLength !== (47 + extensionsLength + signatureLength))
					throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
			}
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			const stream = this.toStream();
			
			return new RawData({ data: stream.stream.buffer });
		}
		//**********************************************************************************
		/**
		 * Convert current object to SeqStream data
		 * @returns {SeqStream} SeqStream object
		 */
		toStream()
		{
			const stream = new SeqStream();
			
			stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecode.byteLength);
			stream.appendChar(this.version);
			stream.appendView(new Uint8Array(this.logID));
			
			const timeBuffer = new ArrayBuffer(8);
			const timeView = new Uint8Array(timeBuffer);
			
			const baseArray = utilToBase$2(this.timestamp.valueOf(), 8);
			timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
			
			stream.appendView(timeView);
			stream.appendUint16(this.extensions.byteLength);
			
			if(this.extensions.byteLength)
				stream.appendView(new Uint8Array(this.extensions));
			
			let _hashAlgorithm;
			
			switch(this.hashAlgorithm.toLowerCase())
			{
				case "none":
					_hashAlgorithm = 0;
					break;
				case "md5":
					_hashAlgorithm = 1;
					break;
				case "sha1":
					_hashAlgorithm = 2;
					break;
				case "sha224":
					_hashAlgorithm = 3;
					break;
				case "sha256":
					_hashAlgorithm = 4;
					break;
				case "sha384":
					_hashAlgorithm = 5;
					break;
				case "sha512":
					_hashAlgorithm = 6;
					break;
				default:
					throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);
			}
			
			stream.appendChar(_hashAlgorithm);
			
			let _signatureAlgorithm;
			
			switch(this.signatureAlgorithm.toLowerCase())
			{
				case "anonymous":
					_signatureAlgorithm = 0;
					break;
				case "rsa":
					_signatureAlgorithm = 1;
					break;
				case "dsa":
					_signatureAlgorithm = 2;
					break;
				case "ecdsa":
					_signatureAlgorithm = 3;
					break;
				default:
					throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);
			}
			
			stream.appendChar(_signatureAlgorithm);
			
			const _signature = this.signature.toBER(false);
			
			stream.appendUint16(_signature.byteLength);
			stream.appendView(new Uint8Array(_signature));
			
			return stream;
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				version: this.version,
				logID: bufferToHexCodes$2(this.logID),
				timestamp: this.timestamp,
				extensions: bufferToHexCodes$2(this.extensions),
				hashAlgorithm: this.hashAlgorithm,
				signatureAlgorithm: this.signatureAlgorithm,
				signature: this.signature.toJSON()
			};
		}
		//**********************************************************************************
		/**
		 * Verify SignedCertificateTimestamp for specific input data
		 * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)
		 * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format
		 * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format
		 * @param {ArrayBuffer} data Data to verify signature against. Could be encoded Certificate or encoded PreCert
		 * @param {Number} [dataType=0] Type = 0 (data is encoded Certificate), type = 1 (data is encoded PreCert)
		 * @return {Promise<void>}
		 */
		async verify(logs, data, dataType = 0)
		{
			//region Initial variables
			let logId = toBase64$1(arrayBufferToString$1(this.logID));
			
			let publicKeyBase64 = null;
			let publicKeyInfo;
			
			let stream = new SeqStream();
			//endregion
			
			//region Found and init public key
			for(const log of logs)
			{
				if(log.log_id === logId)
				{
					publicKeyBase64 = log.key;
					break;
				}
			}
			
			if(publicKeyBase64 === null)
				throw new Error(`Public key not found for CT with logId: ${logId}`);
			
			const asn1 = fromBER$1(stringToArrayBuffer$2(fromBase64$1(publicKeyBase64)));
			if(asn1.offset === (-1))
				throw new Error(`Incorrect key value for CT Log with logId: ${logId}`);
			
			publicKeyInfo = new PublicKeyInfo$1({ schema: asn1.result });
			//endregion
			
			//region Initialize signed data block
			stream.appendChar(0x00); // sct_version
			stream.appendChar(0x00); // signature_type = certificate_timestamp
			
			const timeBuffer = new ArrayBuffer(8);
			const timeView = new Uint8Array(timeBuffer);
			
			const baseArray = utilToBase$2(this.timestamp.valueOf(), 8);
			timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
			
			stream.appendView(timeView);
			
			stream.appendUint16(dataType);
			
			if(dataType === 0)
				stream.appendUint24(data.byteLength);
			
			stream.appendView(new Uint8Array(data));
			
			stream.appendUint16(this.extensions.byteLength);
			
			if(this.extensions.byteLength !== 0)
				stream.appendView(new Uint8Array(this.extensions));
			//endregion
			
			//region Perform verification
			return getEngine().subtle.verifyWithPublicKey(
				stream._stream._buffer.slice(0, stream._length),
				{ valueBlock: { valueHex: this.signature.toBER(false) } },
				publicKeyInfo,
				{ algorithmId: "" },
				"SHA-256"
			);
			//endregion
		}
		//**********************************************************************************
	}
	//**************************************************************************************
	/**
	 * Class from RFC6962
	 */
	class SignedCertificateTimestampList
	{
		//**********************************************************************************
		/**
		 * Constructor for SignedCertificateTimestampList class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<SignedCertificateTimestamp>}
			 * @desc timestamps
			 */
			this.timestamps = getParametersValue$2(parameters, "timestamps", SignedCertificateTimestampList.defaultValues("timestamps"));
			//endregion
			
			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "timestamps":
					return [];
				default:
					throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Compare values with default values for all class members
		 * @param {string} memberName String name for a class member
		 * @param {*} memberValue Value to compare with default value
		 */
		static compareWithDefault(memberName, memberValue)
		{
			switch(memberName)
			{
				case "timestamps":
					return (memberValue.length === 0);
				default:
					throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * SignedCertificateTimestampList ::= OCTET STRING
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [optional]
			 */
			const names = getParametersValue$2(parameters, "names", {});
			
			if(("optional" in names) === false)
				names.optional = false;
			
			return (new OctetString$1({
				name: (names.blockName || "SignedCertificateTimestampList"),
				optional: names.optional
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Check the schema is valid
			if((schema instanceof OctetString$1) === false)
				throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
			//endregion
			
			//region Get internal properties from parsed schema
			const seqStream = new SeqStream({
				stream: new ByteStream({
					buffer: schema.valueBlock.valueHex
				})
			});
			
			let dataLength = seqStream.getUint16();
			if(dataLength !== seqStream.length)
				throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
			
			while(seqStream.length)
				this.timestamps.push(new SignedCertificateTimestamp({ stream: seqStream }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Initial variables
			const stream = new SeqStream();
			
			let overallLength = 0;
			
			const timestampsData = [];
			//endregion
			
			//region Get overall length
			for(const timestamp of this.timestamps)
			{
				const timestampStream = timestamp.toStream();
				timestampsData.push(timestampStream);
				overallLength += timestampStream.stream.buffer.byteLength;
			}
			//endregion
			
			stream.appendUint16(overallLength);
			
			//region Set data from all timestamps
			for(const timestamp of timestampsData)
				stream.appendView(timestamp.stream.view);
			//endregion
			
			return new OctetString$1({ valueHex: stream.stream.buffer.slice(0) });
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				timestamps: Array.from(this.timestamps, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**********************************************************************************

	//**************************************************************************************
	/**
	 * Class from "[MS-WCCE]: Windows Client Certificate Enrollment Protocol"
	 */
	class CertificateTemplate
	{
		//**********************************************************************************
		/**
		 * Constructor for CertificateTemplate class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc templateID
			 */
			this.templateID = getParametersValue$2(parameters, "templateID", CertificateTemplate.defaultValues("templateID"));

			if("templateMajorVersion" in parameters)
				/**
				 * @type {number}
				 * @desc templateMajorVersion
				 */
				this.templateMajorVersion = getParametersValue$2(parameters, "templateMajorVersion", CertificateTemplate.defaultValues("templateMajorVersion"));

			if("templateMinorVersion" in parameters)
				/**
				 * @type {number}
				 * @desc templateMinorVersion
				 */
				this.templateMinorVersion = getParametersValue$2(parameters, "templateMinorVersion", CertificateTemplate.defaultValues("templateMinorVersion"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "templateID":
					return "";
				case "templateMajorVersion":
				case "templateMinorVersion":
					return 0;
				default:
					throw new Error(`Invalid member name for CertificateTemplate class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * CertificateTemplateOID ::= SEQUENCE {
	     *    templateID              OBJECT IDENTIFIER,
	     *    templateMajorVersion    INTEGER (0..4294967295) OPTIONAL,
	     *    templateMinorVersion    INTEGER (0..4294967295) OPTIONAL
	     * }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [templateID]
			 * @property {string} [templateMajorVersion]
			 * @property {string} [templateMinorVersion]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.templateID || "") }),
					new Integer$1({
						name: (names.templateMajorVersion || ""),
						optional: true
					}),
					new Integer$1({
						name: (names.templateMinorVersion || ""),
						optional: true
					}),
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"templateID",
				"templateMajorVersion",
				"templateMinorVersion"
			]);
			//endregion

			//region Check the schema is valid
			let asn1 = compareSchema(schema,
				schema,
				CertificateTemplate.schema({
					names: {
						templateID: "templateID",
						templateMajorVersion: "templateMajorVersion",
						templateMinorVersion: "templateMinorVersion"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for CertificateTemplate");
			//endregion

			//region Get internal properties from parsed schema
			this.templateID = asn1.result.templateID.valueBlock.toString();

			if("templateMajorVersion" in asn1.result)
				this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;

			if("templateMinorVersion" in asn1.result)
				this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];

			outputArray.push(new ObjectIdentifier$2({ value: this.templateID }));

			if("templateMajorVersion" in this)
				outputArray.push(new Integer$1({ value: this.templateMajorVersion }));

			if("templateMinorVersion" in this)
				outputArray.push(new Integer$1({ value: this.templateMinorVersion }));
			//endregion

			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				extnID: this.templateID
			};

			if("templateMajorVersion" in this)
				object.templateMajorVersion = this.templateMajorVersion;

			if("templateMinorVersion" in this)
				object.templateMinorVersion = this.templateMinorVersion;

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from https://docs.microsoft.com/en-us/windows/desktop/seccrypto/certification-authority-renewal
	 */
	class CAVersion
	{
		//**********************************************************************************
		/**
		 * Constructor for CAVersion class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {number}
			 * @desc certificateIndex
			 */
			this.certificateIndex = getParametersValue$2(parameters, "certificateIndex", CAVersion.defaultValues("certificateIndex"));

			/**
			 * @type {number}
			 * @desc keyIndex
			 */
			this.keyIndex = getParametersValue$2(parameters, "keyIndex", CAVersion.defaultValues("keyIndex"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "certificateIndex":
				case "keyIndex":
					return 0;
				default:
					throw new Error(`Invalid member name for CAVersion class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * CAVersion ::= INTEGER
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			return (new Integer$1());
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Check the schema is valid
			if(schema.constructor.blockName() !== Integer$1.blockName())
				throw new Error("Object's schema was not verified against input data for CAVersion");
			//endregion

			//region Check length of the input value and correct it if needed
			let value = schema.valueBlock.valueHex.slice(0);
			const valueView = new Uint8Array(value);

			switch(true)
			{
				case (value.byteLength < 4):
					{
						const tempValue = new ArrayBuffer(4);
						const tempValueView = new Uint8Array(tempValue);

						tempValueView.set(valueView, 4 - value.byteLength);

						value = tempValue.slice(0);
					}
					break;
				case (value.byteLength > 4):
					{
						const tempValue = new ArrayBuffer(4);
						const tempValueView = new Uint8Array(tempValue);

						tempValueView.set(valueView.slice(0, 4));

						value = tempValue.slice(0);
					}
					break;
				default:
			}
			//endregion

			//region Get internal properties from parsed schema
			const keyIndexBuffer = value.slice(0, 2);
			const keyIndexView8 = new Uint8Array(keyIndexBuffer);
			let temp = keyIndexView8[0];
			keyIndexView8[0] = keyIndexView8[1];
			keyIndexView8[1] = temp;

			const keyIndexView16 = new Uint16Array(keyIndexBuffer);

			this.keyIndex = keyIndexView16[0];

			const certificateIndexBuffer = value.slice(2);
			const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
			temp = certificateIndexView8[0];
			certificateIndexView8[0] = certificateIndexView8[1];
			certificateIndexView8[1] = temp;

			const certificateIndexView16 = new Uint16Array(certificateIndexBuffer);

			this.certificateIndex = certificateIndexView16[0];
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create raw values
			const certificateIndexBuffer = new ArrayBuffer(2);
			const certificateIndexView = new Uint16Array(certificateIndexBuffer);

			certificateIndexView[0] = this.certificateIndex;

			const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
			let temp = certificateIndexView8[0];
			certificateIndexView8[0] = certificateIndexView8[1];
			certificateIndexView8[1] = temp;

			const keyIndexBuffer = new ArrayBuffer(2);
			const keyIndexView = new Uint16Array(keyIndexBuffer);

			keyIndexView[0] = this.keyIndex;

			const keyIndexView8 = new Uint8Array(keyIndexBuffer);
			temp = keyIndexView8[0];
			keyIndexView8[0] = keyIndexView8[1];
			keyIndexView8[1] = temp;
			//endregion

			//region Construct and return new ASN.1 schema for this object
			return (new Integer$1({
				valueHex: utilConcatBuf$2(keyIndexBuffer, certificateIndexBuffer)
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				certificateIndex: this.certificateIndex,
				keyIndex: this.keyIndex
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class Extension
	{
		//**********************************************************************************
		/**
		 * Constructor for Extension class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {string}
			 * @desc extnID
			 */
			this.extnID = getParametersValue$2(parameters, "extnID", Extension.defaultValues("extnID"));
			/**
			 * @type {boolean}
			 * @desc critical
			 */
			this.critical = getParametersValue$2(parameters, "critical", Extension.defaultValues("critical"));
			/**
			 * @type {OctetString}
			 * @desc extnValue
			 */
			if("extnValue" in parameters)
				this.extnValue = new OctetString$1({ valueHex: parameters.extnValue });
			else
				this.extnValue = Extension.defaultValues("extnValue");

			if("parsedValue" in parameters)
				/**
				 * @type {Object}
				 * @desc parsedValue
				 */
				this.parsedValue = getParametersValue$2(parameters, "parsedValue", Extension.defaultValues("parsedValue"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "extnID":
					return "";
				case "critical":
					return false;
				case "extnValue":
					return new OctetString$1();
				case "parsedValue":
					return {};
				default:
					throw new Error(`Invalid member name for Extension class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * Extension  ::=  SEQUENCE  {
		 *    extnID      OBJECT IDENTIFIER,
		 *    critical    BOOLEAN DEFAULT FALSE,
		 *    extnValue   OCTET STRING
		 * }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [extnID]
			 * @property {string} [critical]
			 * @property {string} [extnValue]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new ObjectIdentifier$2({ name: (names.extnID || "") }),
					new Boolean$1({
						name: (names.critical || ""),
						optional: true
					}),
					new OctetString$1({ name: (names.extnValue || "") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"extnID",
				"critical",
				"extnValue"
			]);
			//endregion
			
			//region Check the schema is valid
			let asn1 = compareSchema(schema,
				schema,
				Extension.schema({
					names: {
						extnID: "extnID",
						critical: "critical",
						extnValue: "extnValue"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for Extension");
			//endregion

			//region Get internal properties from parsed schema
			this.extnID = asn1.result.extnID.valueBlock.toString();
			if("critical" in asn1.result)
				this.critical = asn1.result.critical.valueBlock.value;
			this.extnValue = asn1.result.extnValue;

			//region Get "parsedValue" for well-known extensions
			asn1 = fromBER$1(this.extnValue.valueBlock.valueHex);
			if(asn1.offset === (-1))
				return;

			switch(this.extnID)
			{
				case "2.5.29.9": // SubjectDirectoryAttributes
					try
					{
						this.parsedValue = new SubjectDirectoryAttributes({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new SubjectDirectoryAttributes();
						this.parsedValue.parsingError = "Incorrectly formated SubjectDirectoryAttributes";
					}
					break;
				case "2.5.29.14": // SubjectKeyIdentifier
					this.parsedValue = asn1.result; // Should be just a simple OCTETSTRING
					break;
				case "2.5.29.15": // KeyUsage
					this.parsedValue = asn1.result; // Should be just a simple BITSTRING
					break;
				case "2.5.29.16": // PrivateKeyUsagePeriod
					try
					{
						this.parsedValue = new PrivateKeyUsagePeriod({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new PrivateKeyUsagePeriod();
						this.parsedValue.parsingError = "Incorrectly formated PrivateKeyUsagePeriod";
					}
					break;
				case "2.5.29.17": // SubjectAltName
				case "2.5.29.18": // IssuerAltName
					try
					{
						this.parsedValue = new AltName({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new AltName();
						this.parsedValue.parsingError = "Incorrectly formated AltName";
					}
					break;
				case "2.5.29.19": // BasicConstraints
					try
					{
						this.parsedValue = new BasicConstraints({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new BasicConstraints();
						this.parsedValue.parsingError = "Incorrectly formated BasicConstraints";
					}
					break;
				case "2.5.29.20": // CRLNumber
				case "2.5.29.27": // BaseCRLNumber (delta CRL indicator)
					this.parsedValue = asn1.result; // Should be just a simple INTEGER
					break;
				case "2.5.29.21": // CRLReason
					this.parsedValue = asn1.result; // Should be just a simple ENUMERATED
					break;
				case "2.5.29.24": // InvalidityDate
					this.parsedValue = asn1.result; // Should be just a simple GeneralizedTime
					break;
				case "2.5.29.28": // IssuingDistributionPoint
					try
					{
						this.parsedValue = new IssuingDistributionPoint({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new IssuingDistributionPoint();
						this.parsedValue.parsingError = "Incorrectly formated IssuingDistributionPoint";
					}
					break;
				case "2.5.29.29": // CertificateIssuer
					try
					{
						this.parsedValue = new GeneralNames({ schema: asn1.result }); // Should be just a simple
					}
					catch(ex)
					{
						this.parsedValue = new GeneralNames();
						this.parsedValue.parsingError = "Incorrectly formated GeneralNames";
					}
					break;
				case "2.5.29.30": // NameConstraints
					try
					{
						this.parsedValue = new NameConstraints({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new NameConstraints();
						this.parsedValue.parsingError = "Incorrectly formated NameConstraints";
					}
					break;
				case "2.5.29.31": // CRLDistributionPoints
				case "2.5.29.46": // FreshestCRL
					try
					{
						this.parsedValue = new CRLDistributionPoints({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new CRLDistributionPoints();
						this.parsedValue.parsingError = "Incorrectly formated CRLDistributionPoints";
					}
					break;
				case "2.5.29.32": // CertificatePolicies
				case "1.3.6.1.4.1.311.21.10": // szOID_APPLICATION_CERT_POLICIES - Microsoft-specific OID
					try
					{
						this.parsedValue = new CertificatePolicies({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new CertificatePolicies();
						this.parsedValue.parsingError = "Incorrectly formated CertificatePolicies";
					}
					break;
				case "2.5.29.33": // PolicyMappings
					try
					{
						this.parsedValue = new PolicyMappings({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new PolicyMappings();
						this.parsedValue.parsingError = "Incorrectly formated CertificatePolicies";
					}
					break;
				case "2.5.29.35": // AuthorityKeyIdentifier
					try
					{
						this.parsedValue = new AuthorityKeyIdentifier({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new AuthorityKeyIdentifier();
						this.parsedValue.parsingError = "Incorrectly formated AuthorityKeyIdentifier";
					}
					break;
				case "2.5.29.36": // PolicyConstraints
					try
					{
						this.parsedValue = new PolicyConstraints({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new PolicyConstraints();
						this.parsedValue.parsingError = "Incorrectly formated PolicyConstraints";
					}
					break;
				case "2.5.29.37": // ExtKeyUsage
					try
					{
						this.parsedValue = new ExtKeyUsage({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new ExtKeyUsage();
						this.parsedValue.parsingError = "Incorrectly formated ExtKeyUsage";
					}
					break;
				case "2.5.29.54": // InhibitAnyPolicy
					this.parsedValue = asn1.result; // Should be just a simple INTEGER
					break;
				case "1.3.6.1.5.5.7.1.1": // AuthorityInfoAccess
				case "1.3.6.1.5.5.7.1.11": // SubjectInfoAccess
					try
					{
						this.parsedValue = new InfoAccess({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new InfoAccess();
						this.parsedValue.parsingError = "Incorrectly formated InfoAccess";
					}
					break;
				case "1.3.6.1.4.1.11129.2.4.2": // SignedCertificateTimestampList
					try
					{
						this.parsedValue = new SignedCertificateTimestampList({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new SignedCertificateTimestampList();
						this.parsedValue.parsingError = "Incorrectly formated SignedCertificateTimestampList";
					}
					break;
				case "1.3.6.1.4.1.311.20.2": // szOID_ENROLL_CERTTYPE_EXTENSION - Microsoft-specific extension
					this.parsedValue = asn1.result; // Used to be simple Unicode string
					break;
				case "1.3.6.1.4.1.311.21.2": // szOID_CERTSRV_PREVIOUS_CERT_HASH - Microsoft-specific extension
					this.parsedValue = asn1.result; // Used to be simple OctetString
					break;
				case "1.3.6.1.4.1.311.21.7": // szOID_CERTIFICATE_TEMPLATE - Microsoft-specific extension
					try
					{
						this.parsedValue = new CertificateTemplate({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new CertificateTemplate();
						this.parsedValue.parsingError = "Incorrectly formated CertificateTemplate";
					}
					break;
				case "1.3.6.1.4.1.311.21.1": // szOID_CERTSRV_CA_VERSION - Microsoft-specific extension
					try
					{
						this.parsedValue = new CAVersion({ schema: asn1.result });
					}
					catch(ex)
					{
						this.parsedValue = new CAVersion();
						this.parsedValue.parsingError = "Incorrectly formated CAVersion";
					}
					break;
				default:
			}
			//endregion
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [];

			outputArray.push(new ObjectIdentifier$2({ value: this.extnID }));

			if(this.critical !== Extension.defaultValues("critical"))
				outputArray.push(new Boolean$1({ value: this.critical }));

			outputArray.push(this.extnValue);
			//endregion

			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				extnID: this.extnID,
				extnValue: this.extnValue.toJSON()
			};

			if(this.critical !== Extension.defaultValues("critical"))
				object.critical = this.critical;

			if("parsedValue" in this)
			{
				if("toJSON" in this.parsedValue)
					object.parsedValue = this.parsedValue.toJSON();
			}

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class Extensions
	{
		//**********************************************************************************
		/**
		 * Constructor for Extensions class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<Extension>}
			 * @desc type
			 */
			this.extensions = getParametersValue$2(parameters, "extensions", Extensions.defaultValues("extensions"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "extensions":
					return [];
				default:
					throw new Error(`Invalid member name for Extensions class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @param {boolean} optional Flag that current schema should be optional
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {}, optional = false)
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [extensions]
			 * @property {string} [extension]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return (new Sequence$1({
				optional,
				name: (names.blockName || ""),
				value: [
					new Repeated({
						name: (names.extensions || ""),
						value: Extension.schema(names.extension || {})
					})
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"extensions"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				Extensions.schema({
					names: {
						extensions: "extensions"
					}
				})
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for Extensions");
			//endregion

			//region Get internal properties from parsed schema
			this.extensions = Array.from(asn1.result.extensions, element => new Extension({ schema: element }));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: Array.from(this.extensions, element => element.toSchema())
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			return {
				extensions: Array.from(this.extensions, element => element.toJSON())
			};
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	function tbsCertificate(parameters = {})
	{
		//TBSCertificate  ::=  SEQUENCE  {
		//    version         [0]  EXPLICIT Version DEFAULT v1,
		//    serialNumber         CertificateSerialNumber,
		//    signature            AlgorithmIdentifier,
		//    issuer               Name,
		//    validity             Validity,
		//    subject              Name,
		//    subjectPublicKeyInfo SubjectPublicKeyInfo,
		//    issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
		//                         -- If present, version MUST be v2 or v3
		//    subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
		//                         -- If present, version MUST be v2 or v3
		//    extensions      [3]  EXPLICIT Extensions OPTIONAL
		//    -- If present, version MUST be v3
		//}
		
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [tbsCertificateVersion]
		 * @property {string} [tbsCertificateSerialNumber]
		 * @property {string} [signature]
		 * @property {string} [issuer]
		 * @property {string} [tbsCertificateValidity]
		 * @property {string} [notBefore]
		 * @property {string} [notAfter]
		 * @property {string} [subject]
		 * @property {string} [subjectPublicKeyInfo]
		 * @property {string} [tbsCertificateIssuerUniqueID]
		 * @property {string} [tbsCertificateSubjectUniqueID]
		 * @property {string} [extensions]
		 */
		const names = getParametersValue$2(parameters, "names", {});
		
		return (new Sequence$1({
			name: (names.blockName || "tbsCertificate"),
			value: [
				new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new Integer$1({ name: (names.tbsCertificateVersion || "tbsCertificate.version") }) // EXPLICIT integer value
					]
				}),
				new Integer$1({ name: (names.tbsCertificateSerialNumber || "tbsCertificate.serialNumber") }),
				AlgorithmIdentifier$1.schema(names.signature || {
					names: {
						blockName: "tbsCertificate.signature"
					}
				}),
				RelativeDistinguishedNames.schema(names.issuer || {
					names: {
						blockName: "tbsCertificate.issuer"
					}
				}),
				new Sequence$1({
					name: (names.tbsCertificateValidity || "tbsCertificate.validity"),
					value: [
						Time.schema(names.notBefore || {
							names: {
								utcTimeName: "tbsCertificate.notBefore",
								generalTimeName: "tbsCertificate.notBefore"
							}
						}),
						Time.schema(names.notAfter || {
							names: {
								utcTimeName: "tbsCertificate.notAfter",
								generalTimeName: "tbsCertificate.notAfter"
							}
						})
					]
				}),
				RelativeDistinguishedNames.schema(names.subject || {
					names: {
						blockName: "tbsCertificate.subject"
					}
				}),
				PublicKeyInfo$1.schema(names.subjectPublicKeyInfo || {
					names: {
						blockName: "tbsCertificate.subjectPublicKeyInfo"
					}
				}),
				new Primitive$1({
					name: (names.tbsCertificateIssuerUniqueID || "tbsCertificate.issuerUniqueID"),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					}
				}), // IMPLICIT bistring value
				new Primitive$1({
					name: (names.tbsCertificateSubjectUniqueID || "tbsCertificate.subjectUniqueID"),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					}
				}), // IMPLICIT bistring value
				new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					value: [Extensions.schema(names.extensions || {
						names: {
							blockName: "tbsCertificate.extensions"
						}
					})]
				}) // EXPLICIT SEQUENCE value
			]
		}));
	}
	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class Certificate
	{
		//**********************************************************************************
		/**
		 * Constructor for Certificate class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {ArrayBuffer}
			 * @desc ToBeSigned (TBS) part of the certificate
			 */
			this.tbs = getParametersValue$2(parameters, "tbs", Certificate.defaultValues("tbs"));
			/**
			 * @type {number}
			 * @desc Version number
			 */
			this.version = getParametersValue$2(parameters, "version", Certificate.defaultValues("version"));
			/**
			 * @type {Integer}
			 * @desc Serial number of the certificate
			 */
			this.serialNumber = getParametersValue$2(parameters, "serialNumber", Certificate.defaultValues("serialNumber"));
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc This field contains the algorithm identifier for the algorithm used by the CA to sign the certificate
			 */
			this.signature = getParametersValue$2(parameters, "signature", Certificate.defaultValues("signature"));
			/**
			 * @type {RelativeDistinguishedNames}
			 * @desc The issuer field identifies the entity that has signed and issued the certificate
			 */
			this.issuer = getParametersValue$2(parameters, "issuer", Certificate.defaultValues("issuer"));
			/**
			 * @type {Time}
			 * @desc The date on which the certificate validity period begins
			 */
			this.notBefore = getParametersValue$2(parameters, "notBefore", Certificate.defaultValues("notBefore"));
			/**
			 * @type {Time}
			 * @desc The date on which the certificate validity period ends
			 */
			this.notAfter = getParametersValue$2(parameters, "notAfter", Certificate.defaultValues("notAfter"));
			/**
			 * @type {RelativeDistinguishedNames}
			 * @desc The subject field identifies the entity associated with the public key stored in the subject public key field
			 */
			this.subject = getParametersValue$2(parameters, "subject", Certificate.defaultValues("subject"));
			/**
			 * @type {PublicKeyInfo}
			 * @desc This field is used to carry the public key and identify the algorithm with which the key is used
			 */
			this.subjectPublicKeyInfo = getParametersValue$2(parameters, "subjectPublicKeyInfo", Certificate.defaultValues("subjectPublicKeyInfo"));
			
			if("issuerUniqueID" in parameters)
				/**
				 * @type {ArrayBuffer}
				 * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time
				 */
				this.issuerUniqueID = getParametersValue$2(parameters, "issuerUniqueID", Certificate.defaultValues("issuerUniqueID"));
			
			if("subjectUniqueID" in parameters)
				/**
				 * @type {ArrayBuffer}
				 * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time
				 */
				this.subjectUniqueID = getParametersValue$2(parameters, "subjectUniqueID", Certificate.defaultValues("subjectUniqueID"));
			
			if("extensions" in parameters)
				/**
				 * @type {Array}
				 * @desc If present, this field is a SEQUENCE of one or more certificate extensions
				 */
				this.extensions = getParametersValue$2(parameters, "extensions", Certificate.defaultValues("extensions"));
			
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc The signatureAlgorithm field contains the identifier for the cryptographic algorithm used by the CA to sign this certificate
			 */
			this.signatureAlgorithm = getParametersValue$2(parameters, "signatureAlgorithm", Certificate.defaultValues("signatureAlgorithm"));
			/**
			 * @type {BitString}
			 * @desc The signatureValue field contains a digital signature computed upon the ASN.1 DER encoded tbsCertificate
			 */
			this.signatureValue = getParametersValue$2(parameters, "signatureValue", Certificate.defaultValues("signatureValue"));
			//endregion
			
			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "tbs":
					return new ArrayBuffer(0);
				case "version":
					return 0;
				case "serialNumber":
					return new Integer$1();
				case "signature":
					return new AlgorithmIdentifier$1();
				case "issuer":
					return new RelativeDistinguishedNames();
				case "notBefore":
					return new Time();
				case "notAfter":
					return new Time();
				case "subject":
					return new RelativeDistinguishedNames();
				case "subjectPublicKeyInfo":
					return new PublicKeyInfo$1();
				case "issuerUniqueID":
					return new ArrayBuffer(0);
				case "subjectUniqueID":
					return new ArrayBuffer(0);
				case "extensions":
					return [];
				case "signatureAlgorithm":
					return new AlgorithmIdentifier$1();
				case "signatureValue":
					return new BitString$1();
				default:
					throw new Error(`Invalid member name for Certificate class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * Certificate  ::=  SEQUENCE  {
		 *    tbsCertificate       TBSCertificate,
		 *    signatureAlgorithm   AlgorithmIdentifier,
		 *    signatureValue       BIT STRING  }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [tbsCertificate]
			 * @property {string} [signatureAlgorithm]
			 * @property {string} [signatureValue]
			 */
			const names = getParametersValue$2(parameters, "names", {});
			
			return (new Sequence$1({
				name: (names.blockName || ""),
				value: [
					tbsCertificate(names.tbsCertificate),
					AlgorithmIdentifier$1.schema(names.signatureAlgorithm || {
						names: {
							blockName: "signatureAlgorithm"
						}
					}),
					new BitString$1({ name: (names.signatureValue || "signatureValue") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"tbsCertificate",
				"tbsCertificate.extensions",
				"tbsCertificate.version",
				"tbsCertificate.serialNumber",
				"tbsCertificate.signature",
				"tbsCertificate.issuer",
				"tbsCertificate.notBefore",
				"tbsCertificate.notAfter",
				"tbsCertificate.subject",
				"tbsCertificate.subjectPublicKeyInfo",
				"tbsCertificate.issuerUniqueID",
				"tbsCertificate.subjectUniqueID",
				"signatureAlgorithm",
				"signatureValue"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				Certificate.schema({
					names: {
						tbsCertificate: {
							names: {
								extensions: {
									names: {
										extensions: "tbsCertificate.extensions"
									}
								}
							}
						}
					}
				})
			);
			
			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for Certificate");
			//endregion
			
			//region Get internal properties from parsed schema
			this.tbs = asn1.result.tbsCertificate.valueBeforeDecode;
			
			if("tbsCertificate.version" in asn1.result)
				this.version = asn1.result["tbsCertificate.version"].valueBlock.valueDec;
			this.serialNumber = asn1.result["tbsCertificate.serialNumber"];
			this.signature = new AlgorithmIdentifier$1({ schema: asn1.result["tbsCertificate.signature"] });
			this.issuer = new RelativeDistinguishedNames({ schema: asn1.result["tbsCertificate.issuer"] });
			this.notBefore = new Time({ schema: asn1.result["tbsCertificate.notBefore"] });
			this.notAfter = new Time({ schema: asn1.result["tbsCertificate.notAfter"] });
			this.subject = new RelativeDistinguishedNames({ schema: asn1.result["tbsCertificate.subject"] });
			this.subjectPublicKeyInfo = new PublicKeyInfo$1({ schema: asn1.result["tbsCertificate.subjectPublicKeyInfo"] });
			if("tbsCertificate.issuerUniqueID" in asn1.result)
				this.issuerUniqueID = asn1.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex;
			if("tbsCertificate.subjectUniqueID" in asn1.result)
				this.subjectUniqueID = asn1.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex;
			if("tbsCertificate.extensions" in asn1.result)
				this.extensions = Array.from(asn1.result["tbsCertificate.extensions"], element => new Extension({ schema: element }));
			
			this.signatureAlgorithm = new AlgorithmIdentifier$1({ schema: asn1.result.signatureAlgorithm });
			this.signatureValue = asn1.result.signatureValue;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Create ASN.1 schema for existing values of TBS part for the certificate
		 */
		encodeTBS()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if(("version" in this) && (this.version !== Certificate.defaultValues("version")))
			{
				outputArray.push(new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new Integer$1({ value: this.version }) // EXPLICIT integer value
					]
				}));
			}
			
			outputArray.push(this.serialNumber);
			outputArray.push(this.signature.toSchema());
			outputArray.push(this.issuer.toSchema());
			
			outputArray.push(new Sequence$1({
				value: [
					this.notBefore.toSchema(),
					this.notAfter.toSchema()
				]
			}));
			
			outputArray.push(this.subject.toSchema());
			outputArray.push(this.subjectPublicKeyInfo.toSchema());
			
			if("issuerUniqueID" in this)
			{
				outputArray.push(new Primitive$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					valueHex: this.issuerUniqueID
				}));
			}
			if("subjectUniqueID" in this)
			{
				outputArray.push(new Primitive$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					valueHex: this.subjectUniqueID
				}));
			}
			
			if("extensions" in this)
			{
				outputArray.push(new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					value: [new Sequence$1({
						value: Array.from(this.extensions, element => element.toSchema())
					})]
				}));
			}
			//endregion
			
			//region Create and return output sequence
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema(encodeFlag = false)
		{
			let tbsSchema = {};
			
			//region Decode stored TBS value
			if(encodeFlag === false)
			{
				if(this.tbs.length === 0) // No stored certificate TBS part
					return Certificate.schema().value[0];
				
				tbsSchema = fromBER$1(this.tbs).result;
			}
			//endregion
			//region Create TBS schema via assembling from TBS parts
			else
				tbsSchema = this.encodeTBS();
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					tbsSchema,
					this.signatureAlgorithm.toSchema(),
					this.signatureValue
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				tbs: bufferToHexCodes$2(this.tbs, 0, this.tbs.byteLength),
				serialNumber: this.serialNumber.toJSON(),
				signature: this.signature.toJSON(),
				issuer: this.issuer.toJSON(),
				notBefore: this.notBefore.toJSON(),
				notAfter: this.notAfter.toJSON(),
				subject: this.subject.toJSON(),
				subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
				signatureAlgorithm: this.signatureAlgorithm.toJSON(),
				signatureValue: this.signatureValue.toJSON()
			};
			
			if(("version" in this) && (this.version !== Certificate.defaultValues("version")))
				object.version = this.version;
			
			if("issuerUniqueID" in this)
				object.issuerUniqueID = bufferToHexCodes$2(this.issuerUniqueID, 0, this.issuerUniqueID.byteLength);
			
			if("subjectUniqueID" in this)
				object.subjectUniqueID = bufferToHexCodes$2(this.subjectUniqueID, 0, this.subjectUniqueID.byteLength);
			
			if("extensions" in this)
				object.extensions = Array.from(this.extensions, element => element.toJSON());
			
			return object;
		}
		//**********************************************************************************
		/**
		 * Importing public key for current certificate
		 */
		getPublicKey(parameters = null)
		{
			return getEngine().subtle.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
		}
		//**********************************************************************************
		/**
		 * Get hash value for subject public key (default SHA-1)
		 * @param {String} [hashAlgorithm=SHA-1] Hashing algorithm name
		 */
		getKeyHash(hashAlgorithm = "SHA-1")
		{
			//region Get a "crypto" extension
			const crypto = getCrypto();
			if(typeof crypto === "undefined")
				return Promise.reject("Unable to create WebCrypto object");
			//endregion
			
			return crypto.digest({ name: hashAlgorithm }, new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex));
		}
		//**********************************************************************************
		/**
		 * Make a signature for current value from TBS section
		 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
		 * @param {string} [hashAlgorithm="SHA-1"] Hashing algorithm
		 */
		sign(privateKey, hashAlgorithm = "SHA-1")
		{
			//region Initial checking
			//region Check private key
			if(typeof privateKey === "undefined")
				return Promise.reject("Need to provide a private key for signing");
			//endregion
			//endregion
			
			//region Initial variables
			let sequence = Promise.resolve();
			let parameters;
			
			const engine = getEngine();
			//endregion
			
			//region Get a "default parameters" for current algorithm and set correct signature algorithm
			sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
			
			sequence = sequence.then(result =>
			{
				parameters = result.parameters;
				this.signature = result.signatureAlgorithm;
				this.signatureAlgorithm = result.signatureAlgorithm;
			});
			//endregion
			
			//region Create TBS data for signing
			sequence = sequence.then(() =>
			{
				this.tbs = this.encodeTBS().toBER(false);
			});
			//endregion
			
			//region Signing TBS data on provided private key
			sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));
			
			sequence = sequence.then(result =>
			{
				this.signatureValue = new BitString$1({ valueHex: result });
			});
			//endregion
			
			return sequence;
		}
		//**********************************************************************************
		verify(issuerCertificate = null)
		{
			//region Global variables
			let subjectPublicKeyInfo = {};
			//endregion
			
			//region Set correct "subjectPublicKeyInfo" value
			if(issuerCertificate !== null)
				subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;
			else
			{
				if(this.issuer.isEqual(this.subject)) // Self-signed certificate
					subjectPublicKeyInfo = this.subjectPublicKeyInfo;
			}
			
			if((subjectPublicKeyInfo instanceof PublicKeyInfo$1) === false)
				return Promise.reject("Please provide issuer certificate as a parameter");
			//endregion
			
			return getEngine().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	class CertificateChainValidationEngine
	{
		//**********************************************************************************
		/**
		 * Constructor for CertificateChainValidationEngine class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Array.<Certificate>}
			 * @desc Array of pre-defined trusted (by user) certificates
			 */
			this.trustedCerts = getParametersValue$2(parameters, "trustedCerts", this.defaultValues("trustedCerts"));
			/**
			 * @type {Array.<Certificate>}
			 * @desc Array with certificate chain. Could be only one end-user certificate in there!
			 */
			this.certs = getParametersValue$2(parameters, "certs", this.defaultValues("certs"));
			/**
			 * @type {Array.<CertificateRevocationList>}
			 * @desc Array of all CRLs for all certificates from certificate chain
			 */
			this.crls = getParametersValue$2(parameters, "crls", this.defaultValues("crls"));
			/**
			 * @type {Array}
			 * @desc Array of all OCSP responses
			 */
			this.ocsps = getParametersValue$2(parameters, "ocsps", this.defaultValues("ocsps"));
			/**
			 * @type {Date}
			 * @desc The date at which the check would be
			 */
			this.checkDate = getParametersValue$2(parameters, "checkDate", this.defaultValues("checkDate"));
			/**
			 * @type {Function}
			 * @desc The date at which the check would be
			 */
			this.findOrigin = getParametersValue$2(parameters, "findOrigin", this.defaultValues("findOrigin"));
			/**
			 * @type {Function}
			 * @desc The date at which the check would be
			 */
			this.findIssuer = getParametersValue$2(parameters, "findIssuer", this.defaultValues("findIssuer"));
			//endregion
		}
		//**********************************************************************************
		static defaultFindOrigin(certificate, validationEngine)
		{
			//region Firstly encode TBS for certificate
			if(certificate.tbs.byteLength === 0)
				certificate.tbs = certificate.encodeTBS();
			//endregion
			
			//region Search in Intermediate Certificates
			for(const localCert of validationEngine.certs)
			{
				//region Firstly encode TBS for certificate
				if(localCert.tbs.byteLength === 0)
					localCert.tbs = localCert.encodeTBS();
				//endregion
				
				if(isEqualBuffer$2(certificate.tbs, localCert.tbs))
					return "Intermediate Certificates";
			}
			//endregion
			
			//region Search in Trusted Certificates
			for(const trustedCert of validationEngine.trustedCerts)
			{
				//region Firstly encode TBS for certificate
				if(trustedCert.tbs.byteLength === 0)
					trustedCert.tbs = trustedCert.encodeTBS();
				//endregion
				
				if(isEqualBuffer$2(certificate.tbs, trustedCert.tbs))
					return "Trusted Certificates";
			}
			//endregion
			
			return "Unknown";
		}
		//**********************************************************************************
		async defaultFindIssuer(certificate, validationEngine)
		{
			//region Initial variables
			let result = [];
			
			let keyIdentifier = null;
			
			let authorityCertIssuer = null;
			let authorityCertSerialNumber = null;
			//endregion
			
			//region Speed-up searching in case of self-signed certificates
			if(certificate.subject.isEqual(certificate.issuer))
			{
				try
				{
					const verificationResult = await certificate.verify();
					if(verificationResult === true)
						return [certificate];
				}
				catch(ex)
				{
				}
			}
			//endregion
			
			//region Find values to speed-up search
			if("extensions" in certificate)
			{
				for(const extension of certificate.extensions)
				{
					if(extension.extnID === "2.5.29.35") // AuthorityKeyIdentifier
					{
						if("keyIdentifier" in extension.parsedValue)
							keyIdentifier = extension.parsedValue.keyIdentifier;
						else
						{
							if("authorityCertIssuer" in extension.parsedValue)
								authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
							
							if("authorityCertSerialNumber" in extension.parsedValue)
								authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
						}
						
						break;
					}
				}
			}
			//endregion
			
			//region Aux function
			function checkCertificate(possibleIssuer)
			{
				//region Firstly search for appropriate extensions
				if(keyIdentifier !== null)
				{
					if("extensions" in possibleIssuer)
					{
						let extensionFound = false;
						
						for(const extension of possibleIssuer.extensions)
						{
							if(extension.extnID === "2.5.29.14") // SubjectKeyIdentifier
							{
								extensionFound = true;
								
								if(isEqualBuffer$2(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHex))
									result.push(possibleIssuer);
								
								break;
							}
						}
						
						if(extensionFound)
							return;
					}
				}
				//endregion
				
				//region Now search for authorityCertSerialNumber
				let authorityCertSerialNumberEqual = false;
				
				if(authorityCertSerialNumber !== null)
					authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
				//endregion
				
				//region And at least search for Issuer data
				if(authorityCertIssuer !== null)
				{
					if(possibleIssuer.subject.isEqual(authorityCertIssuer))
					{
						if(authorityCertSerialNumberEqual)
							result.push(possibleIssuer);
					}
				}
				else
				{
					if(certificate.issuer.isEqual(possibleIssuer.subject))
						result.push(possibleIssuer);
				}
				//endregion
			}
			//endregion
			
			//region Search in Trusted Certificates
			for(const trustedCert of validationEngine.trustedCerts)
				checkCertificate(trustedCert);
			//endregion
			
			//region Search in Intermediate Certificates
			for(const intermediateCert of validationEngine.certs)
				checkCertificate(intermediateCert);
			//endregion
			
			//region Now perform certificate verification checking
			for(let i = 0; i < result.length; i++)
			{
				try
				{
					const verificationResult = await certificate.verify(result[i]);
					if(verificationResult === false)
						result.splice(i, 1);
				}
				catch(ex)
				{
					result.splice(i, 1); // Something wrong, remove the certificate
				}
			}
			//endregion
			
			return result;
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		defaultValues(memberName)
		{
			switch(memberName)
			{
				case "trustedCerts":
					return [];
				case "certs":
					return [];
				case "crls":
					return [];
				case "ocsps":
					return [];
				case "checkDate":
					return new Date();
				case "findOrigin":
					return CertificateChainValidationEngine.defaultFindOrigin;
				case "findIssuer":
					return this.defaultFindIssuer;
				default:
					throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);
			}
		}
		//**********************************************************************************
		async sort(passedWhenNotRevValues = false)
		{
			//region Initial variables
			const localCerts = [];
			const _this = this;
			//endregion
			
			//region Building certificate path
			async function buildPath(certificate)
			{
				const result = [];
				
				//region Aux function checking array for unique elements
				function checkUnique(array)
				{
					let unique = true;
					
					for(let i = 0; i < array.length; i++)
					{
						for(let j = 0; j < array.length; j++)
						{
							if(j === i)
								continue;
							
							if(array[i] === array[j])
							{
								unique = false;
								break;
							}
						}
						
						if(!unique)
							break;
					}
					
					return unique;
				}
				
				//endregion
				
				const findIssuerResult = await _this.findIssuer(certificate, _this);
				if(findIssuerResult.length === 0)
					throw new Error("No valid certificate paths found");
				
				for(let i = 0; i < findIssuerResult.length; i++)
				{
					if(isEqualBuffer$2(findIssuerResult[i].tbs, certificate.tbs))
					{
						result.push([findIssuerResult[i]]);
						continue;
					}
					
					const buildPathResult = await buildPath(findIssuerResult[i]);
					
					for(let j = 0; j < buildPathResult.length; j++)
					{
						const copy = buildPathResult[j].slice();
						copy.splice(0, 0, findIssuerResult[i]);
						
						if(checkUnique(copy))
							result.push(copy);
						else
							result.push(buildPathResult[j]);
					}
				}
				
				return result;
			}
			//endregion
			
			//region Find CRL for specific certificate
			async function findCRL(certificate)
			{
				//region Initial variables
				const issuerCertificates = [];
				const crls = [];
				const crlsAndCertificates = [];
				//endregion
				
				//region Find all possible CRL issuers
				issuerCertificates.push(...localCerts.filter(element => certificate.issuer.isEqual(element.subject)));
				if(issuerCertificates.length === 0)
				{
					return {
						status: 1,
						statusMessage: "No certificate's issuers"
					};
				}
				//endregion
				
				//region Find all CRLs for certificate's issuer
				crls.push(..._this.crls.filter(element => element.issuer.isEqual(certificate.issuer)));
				if(crls.length === 0)
				{
					return {
						status: 2,
						statusMessage: "No CRLs for specific certificate issuer"
					};
				}
				//endregion
				
				//region Find specific certificate of issuer for each CRL
				for(let i = 0; i < crls.length; i++)
				{
					//region Check "nextUpdate" for the CRL
					// The "nextUpdate" is older than "checkDate".
					// Thus we should do have another, updated CRL.
					// Thus the CRL assumed to be invalid.
					if(crls[i].nextUpdate.value < _this.checkDate)
						continue;
					//endregion
					
					for(let j = 0; j < issuerCertificates.length; j++)
					{
						try
						{
							const result = await crls[i].verify({ issuerCertificate: issuerCertificates[j] });
							if(result)
							{
								crlsAndCertificates.push({
									crl: crls[i],
									certificate: issuerCertificates[j]
								});
								
								break;
							}
						}
						catch(ex)
						{
						}
					}
				}
				//endregion
				
				if(crlsAndCertificates.length)
				{
					return {
						status: 0,
						statusMessage: "",
						result: crlsAndCertificates
					};
				}
				
				return {
					status: 3,
					statusMessage: "No valid CRLs found"
				};
			}
			//endregion
			
			//region Find OCSP for specific certificate
			async function findOCSP(certificate, issuerCertificate)
			{
				//region Get hash algorithm from certificate
				const hashAlgorithm = getAlgorithmByOID(certificate.signatureAlgorithm.algorithmId);
				if(("name" in hashAlgorithm) === false)
					return 1;
				if(("hash" in hashAlgorithm) === false)
					return 1;
				//endregion
				
				//region Search for OCSP response for the certificate
				for(let i = 0; i < _this.ocsps.length; i++)
				{
					const result = await _this.ocsps[i].getCertificateStatus(certificate, issuerCertificate);
					if(result.isForCertificate)
					{
						if(result.status === 0)
							return 0;
						
						return 1;
					}
				}
				//endregion
				
				return 2;
			}
			//endregion
			
			//region Check for certificate to be CA
			async function checkForCA(certificate, needToCheckCRL = false)
			{
				//region Initial variables
				let isCA = false;
				let mustBeCA = false;
				let keyUsagePresent = false;
				let cRLSign = false;
				//endregion
				
				if("extensions" in certificate)
				{
					for(let j = 0; j < certificate.extensions.length; j++)
					{
						if((certificate.extensions[j].critical === true) &&
							(("parsedValue" in certificate.extensions[j]) === false))
						{
							return {
								result: false,
								resultCode: 6,
								resultMessage: `Unable to parse critical certificate extension: ${certificate.extensions[j].extnID}`
							};
						}
						
						if(certificate.extensions[j].extnID === "2.5.29.15") // KeyUsage
						{
							keyUsagePresent = true;
							
							const view = new Uint8Array(certificate.extensions[j].parsedValue.valueBlock.valueHex);
							
							if((view[0] & 0x04) === 0x04) // Set flag "keyCertSign"
								mustBeCA = true;
							
							if((view[0] & 0x02) === 0x02) // Set flag "cRLSign"
								cRLSign = true;
						}
						
						if(certificate.extensions[j].extnID === "2.5.29.19") // BasicConstraints
						{
							if("cA" in certificate.extensions[j].parsedValue)
							{
								if(certificate.extensions[j].parsedValue.cA === true)
									isCA = true;
							}
						}
					}
					
					if((mustBeCA === true) && (isCA === false))
					{
						return {
							result: false,
							resultCode: 3,
							resultMessage: "Unable to build certificate chain - using \"keyCertSign\" flag set without BasicConstaints"
						};
					}
					
					if((keyUsagePresent === true) && (isCA === true) && (mustBeCA === false))
					{
						return {
							result: false,
							resultCode: 4,
							resultMessage: "Unable to build certificate chain - \"keyCertSign\" flag was not set"
						};
					}
					
					// noinspection OverlyComplexBooleanExpressionJS
					if((isCA === true) && (keyUsagePresent === true) && ((needToCheckCRL) && (cRLSign === false)))
					{
						return {
							result: false,
							resultCode: 5,
							resultMessage: "Unable to build certificate chain - intermediate certificate must have \"cRLSign\" key usage flag"
						};
					}
				}
				
				if(isCA === false)
				{
					return {
						result: false,
						resultCode: 7,
						resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
					};
				}
				
				return {
					result: true,
					resultCode: 0,
					resultMessage: ""
				};
			}
			//endregion
			
			//region Basic check for certificate path
			async function basicCheck(path, checkDate)
			{
				//region Check that all dates are valid
				for(let i = 0; i < path.length; i++)
				{
					if((path[i].notBefore.value > checkDate) ||
						(path[i].notAfter.value < checkDate))
					{
						return {
							result: false,
							resultCode: 8,
							resultMessage: "The certificate is either not yet valid or expired"
						};
					}
				}
				//endregion
				
				//region Check certificate name chain
				
				// We should have at least two certificates: end entity and trusted root
				if(path.length < 2)
				{
					return {
						result: false,
						resultCode: 9,
						resultMessage: "Too short certificate path"
					};
				}
				
				for(let i = (path.length - 2); i >= 0; i--)
				{
					//region Check that we do not have a "self-signed" certificate
					if(path[i].issuer.isEqual(path[i].subject) === false)
					{
						if(path[i].issuer.isEqual(path[i + 1].subject) === false)
						{
							return {
								result: false,
								resultCode: 10,
								resultMessage: "Incorrect name chaining"
							};
						}
					}
					//endregion
				}
				//endregion
				
				//region Check each certificate (except "trusted root") to be non-revoked
				if((_this.crls.length !== 0) || (_this.ocsps.length !== 0)) // If CRLs and OCSPs are empty then we consider all certificates to be valid
				{
					for(let i = 0; i < (path.length - 1); i++)
					{
						//region Initial variables
						let ocspResult = 2;
						let crlResult = {
							status: 0,
							statusMessage: ""
						};
						//endregion
						
						//region Check OCSPs first
						if(_this.ocsps.length !== 0)
						{
							ocspResult = await findOCSP(path[i], path[i + 1]);
							
							switch(ocspResult)
							{
								case 0:
									continue;
								case 1:
									return {
										result: false,
										resultCode: 12,
										resultMessage: "One of certificates was revoked via OCSP response"
									};
								case 2: // continue to check the certificate with CRL
									break;
								default:
							}
						}
						//endregion
						
						//region Check CRLs
						if(_this.crls.length !== 0)
						{
							crlResult = await findCRL(path[i]);

							if(crlResult.status === 0)
							{
								for(let j = 0; j < crlResult.result.length; j++)
								{
									//region Check that the CRL issuer certificate have not been revoked
									const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[i]);
									if(isCertificateRevoked)
									{
										return {
											result: false,
											resultCode: 12,
											resultMessage: "One of certificates had been revoked"
										};
									}
									//endregion

									//region Check that the CRL issuer certificate is a CA certificate
									const isCertificateCA = await checkForCA(crlResult.result[j].certificate, true);
									if(isCertificateCA.result === false)
									{
										return {
											result: false,
											resultCode: 13,
											resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
										};
									}
									//endregion
								}
							}
							else
							{
								if(passedWhenNotRevValues === false)
								{
									throw {
										result: false,
										resultCode: 11,
										resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
									};
								}
							}
						}
						else
						{
							if(ocspResult === 2)
							{
								return {
									result: false,
									resultCode: 11,
									resultMessage: "No revocation values found for one of certificates"
								};
							}
						}
						//endregion

						//region Check we do have links to revocation values inside issuer's certificate
						if((ocspResult === 2) && (crlResult.status === 2) && passedWhenNotRevValues)
						{
							const issuerCertificate = path[i + 1];
							let extensionFound = false;

							if("extensions" in issuerCertificate)
							{
								for(const extension of issuerCertificate.extensions)
								{
									switch(extension.extnID)
									{
										case "2.5.29.31": // CRLDistributionPoints
										case "2.5.29.46": // FreshestCRL
										case "1.3.6.1.5.5.7.1.1": // AuthorityInfoAccess
											extensionFound = true;
											break;
										default:
									}
								}
							}

							if(extensionFound)
							{
								throw {
									result: false,
									resultCode: 11,
									resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
								};
							}
						}
						//endregion
					}
				}
				//endregion
				
				//region Check each certificate (except "end entity") in the path to be a CA certificate
				for(let i = 1; i < path.length; i++)
				{
					const result = await checkForCA(path[i]);
					if(result.result === false)
					{
						return {
							result: false,
							resultCode: 14,
							resultMessage: "One of intermediate certificates is not a CA certificate"
						};
					}
				}
				//endregion
				
				return {
					result: true
				};
			}
			//endregion
			
			//region Do main work
			//region Initialize "localCerts" by value of "_this.certs" + "_this.trustedCerts" arrays
			localCerts.push(..._this.trustedCerts);
			localCerts.push(..._this.certs);
			//endregion
			
			//region Check all certificates for been unique
			for(let i = 0; i < localCerts.length; i++)
			{
				for(let j = 0; j < localCerts.length; j++)
				{
					if(i === j)
						continue;
					
					if(isEqualBuffer$2(localCerts[i].tbs, localCerts[j].tbs))
					{
						localCerts.splice(j, 1);
						i = 0;
						break;
					}
				}
			}
			//endregion
			
			//region Initial variables
			let result;
			const certificatePath = [localCerts[localCerts.length - 1]]; // The "end entity" certificate must be the least in "certs" array
			//endregion
			
			//region Build path for "end entity" certificate
			result = await buildPath(localCerts[localCerts.length - 1]);
			if(result.length === 0)
			{
				return {
					result: false,
					resultCode: 60,
					resultMessage: "Unable to find certificate path"
				};
			}
			//endregion
			
			//region Exclude certificate paths not ended with "trusted roots"
			for(let i = 0; i < result.length; i++)
			{
				let found = false;
				
				for(let j = 0; j < (result[i]).length; j++)
				{
					const certificate = (result[i])[j];
					
					for(let k = 0; k < _this.trustedCerts.length; k++)
					{
						if(isEqualBuffer$2(certificate.tbs, _this.trustedCerts[k].tbs))
						{
							found = true;
							break;
						}
					}
					
					if(found)
						break;
				}
				
				if(!found)
				{
					result.splice(i, 1);
					i = 0;
				}
			}
			
			if(result.length === 0)
			{
				throw {
					result: false,
					resultCode: 97,
					resultMessage: "No valid certificate paths found"
				};
			}
			//endregion
			
			//region Find shortest certificate path (for the moment it is the only criteria)
			let shortestLength = result[0].length;
			let shortestIndex = 0;
			
			for(let i = 0; i < result.length; i++)
			{
				if(result[i].length < shortestLength)
				{
					shortestLength = result[i].length;
					shortestIndex = i;
				}
			}
			//endregion
			
			//region Create certificate path for basic check
			for(let i = 0; i < result[shortestIndex].length; i++)
				certificatePath.push((result[shortestIndex])[i]);
			//endregion
			
			//region Perform basic checking for all certificates in the path
			result = await basicCheck(certificatePath, _this.checkDate);
			if(result.result === false)
				throw result;
			//endregion
			
			return certificatePath;
			//endregion
		}
		//**********************************************************************************
		/**
		 * Major verification function for certificate chain.
		 * @param {{initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms}} [parameters]
		 * @returns {Promise}
		 */
		async verify(parameters = {})
		{
			//region Auxiliary functions for name constraints checking
			function compareDNSName(name, constraint)
			{
				/// <summary>Compare two dNSName values</summary>
				/// <param name="name" type="String">DNS from name</param>
				/// <param name="constraint" type="String">Constraint for DNS from name</param>
				/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
				
				//region Make a "string preparation" for both name and constrain
				const namePrepared = stringPrep(name);
				const constraintPrepared = stringPrep(constraint);
				//endregion
				
				//region Make a "splitted" versions of "constraint" and "name"
				const nameSplitted = namePrepared.split(".");
				const constraintSplitted = constraintPrepared.split(".");
				//endregion
				
				//region Length calculation and additional check
				const nameLen = nameSplitted.length;
				const constrLen = constraintSplitted.length;
				
				if((nameLen === 0) || (constrLen === 0) || (nameLen < constrLen))
					return false;
				//endregion
				
				//region Check that no part of "name" has zero length
				for(let i = 0; i < nameLen; i++)
				{
					if(nameSplitted[i].length === 0)
						return false;
				}
				//endregion
				
				//region Check that no part of "constraint" has zero length
				for(let i = 0; i < constrLen; i++)
				{
					if(constraintSplitted[i].length === 0)
					{
						if(i === 0)
						{
							if(constrLen === 1)
								return false;
							
							continue;
						}
						
						return false;
					}
				}
				//endregion
				
				//region Check that "name" has a tail as "constraint"
				
				for(let i = 0; i < constrLen; i++)
				{
					if(constraintSplitted[constrLen - 1 - i].length === 0)
						continue;
					
					if(nameSplitted[nameLen - 1 - i].localeCompare(constraintSplitted[constrLen - 1 - i]) !== 0)
						return false;
				}
				//endregion
				
				return true;
			}
			
			function compareRFC822Name(name, constraint)
			{
				/// <summary>Compare two rfc822Name values</summary>
				/// <param name="name" type="String">E-mail address from name</param>
				/// <param name="constraint" type="String">Constraint for e-mail address from name</param>
				/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
				
				//region Make a "string preparation" for both name and constrain
				const namePrepared = stringPrep(name);
				const constraintPrepared = stringPrep(constraint);
				//endregion
				
				//region Make a "splitted" versions of "constraint" and "name"
				const nameSplitted = namePrepared.split("@");
				const constraintSplitted = constraintPrepared.split("@");
				//endregion
				
				//region Splitted array length checking
				if((nameSplitted.length === 0) || (constraintSplitted.length === 0) || (nameSplitted.length < constraintSplitted.length))
					return false;
				//endregion
				
				if(constraintSplitted.length === 1)
				{
					const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);
					
					if(result)
					{
						//region Make a "splitted" versions of domain name from "constraint" and "name"
						const ns = nameSplitted[1].split(".");
						const cs = constraintSplitted[0].split(".");
						//endregion
						
						if(cs[0].length === 0)
							return true;
						
						return ns.length === cs.length;
					}
					
					return false;
				}
				
				return (namePrepared.localeCompare(constraintPrepared) === 0);
			}
			
			function compareUniformResourceIdentifier(name, constraint)
			{
				/// <summary>Compare two uniformResourceIdentifier values</summary>
				/// <param name="name" type="String">uniformResourceIdentifier from name</param>
				/// <param name="constraint" type="String">Constraint for uniformResourceIdentifier from name</param>
				/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
				
				//region Make a "string preparation" for both name and constrain
				let namePrepared = stringPrep(name);
				const constraintPrepared = stringPrep(constraint);
				//endregion
				
				//region Find out a major URI part to compare with
				const ns = namePrepared.split("/");
				const cs = constraintPrepared.split("/");
				
				if(cs.length > 1) // Malformed constraint
					return false;
				
				if(ns.length > 1) // Full URI string
				{
					for(let i = 0; i < ns.length; i++)
					{
						if((ns[i].length > 0) && (ns[i].charAt(ns[i].length - 1) !== ":"))
						{
							const nsPort = ns[i].split(":");
							namePrepared = nsPort[0];
							break;
						}
					}
				}
				//endregion
				
				const result = compareDNSName(namePrepared, constraintPrepared);
				
				if(result)
				{
					//region Make a "splitted" versions of "constraint" and "name"
					const nameSplitted = namePrepared.split(".");
					const constraintSplitted = constraintPrepared.split(".");
					//endregion
					
					if(constraintSplitted[0].length === 0)
						return true;
					
					return nameSplitted.length === constraintSplitted.length;
				}
				
				return false;
			}
			
			function compareIPAddress(name, constraint)
			{
				/// <summary>Compare two iPAddress values</summary>
				/// <param name="name" type="in_window.org.pkijs.asn1.OCTETSTRING">iPAddress from name</param>
				/// <param name="constraint" type="in_window.org.pkijs.asn1.OCTETSTRING">Constraint for iPAddress from name</param>
				/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
				
				//region Common variables
				const nameView = new Uint8Array(name.valueBlock.valueHex);
				const constraintView = new Uint8Array(constraint.valueBlock.valueHex);
				//endregion
				
				//region Work with IPv4 addresses
				if((nameView.length === 4) && (constraintView.length === 8))
				{
					for(let i = 0; i < 4; i++)
					{
						if((nameView[i] ^ constraintView[i]) & constraintView[i + 4])
							return false;
					}
					
					return true;
				}
				//endregion
				
				//region Work with IPv6 addresses
				if((nameView.length === 16) && (constraintView.length === 32))
				{
					for(let i = 0; i < 16; i++)
					{
						if((nameView[i] ^ constraintView[i]) & constraintView[i + 16])
							return false;
					}
					
					return true;
				}
				//endregion
				
				return false;
			}
			
			function compareDirectoryName(name, constraint)
			{
				/// <summary>Compare two directoryName values</summary>
				/// <param name="name" type="in_window.org.pkijs.simpl.RDN">directoryName from name</param>
				/// <param name="constraint" type="in_window.org.pkijs.simpl.RDN">Constraint for directoryName from name</param>
				/// <param name="any" type="Boolean">Boolean flag - should be comparision interrupted after first match or we need to match all "constraints" parts</param>
				/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
				
				//region Initial check
				if((name.typesAndValues.length === 0) || (constraint.typesAndValues.length === 0))
					return true;
				
				if(name.typesAndValues.length < constraint.typesAndValues.length)
					return false;
				//endregion
				
				//region Initial variables
				let result = true;
				let nameStart = 0;
				//endregion
				
				for(let i = 0; i < constraint.typesAndValues.length; i++)
				{
					let localResult = false;
					
					for(let j = nameStart; j < name.typesAndValues.length; j++)
					{
						localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);
						
						if(name.typesAndValues[j].type === constraint.typesAndValues[i].type)
							result = result && localResult;
						
						if(localResult === true)
						{
							if((nameStart === 0) || (nameStart === j))
							{
								nameStart = j + 1;
								break;
							}
							else // Structure of "name" must be the same with "constraint"
								return false;
						}
					}
					
					if(localResult === false)
						return false;
				}
				
				return (nameStart === 0) ? false : result;
			}
			//endregion

			try
			{
				//region Initial checks
				if(this.certs.length === 0)
					throw "Empty certificate array";
				//endregion
				
				//region Get input variables
				let passedWhenNotRevValues = false;

				if("passedWhenNotRevValues" in parameters)
					passedWhenNotRevValues = parameters.passedWhenNotRevValues;

				let initialPolicySet = [];
				initialPolicySet.push("2.5.29.32.0"); // "anyPolicy"
				
				let initialExplicitPolicy = false;
				let initialPolicyMappingInhibit = false;
				let initialInhibitPolicy = false;
				
				let initialPermittedSubtreesSet = []; // Array of "simpl.x509.GeneralSubtree"
				let initialExcludedSubtreesSet = [];  // Array of "simpl.x509.GeneralSubtree"
				let initialRequiredNameForms = [];    // Array of "simpl.x509.GeneralSubtree"
				
				if("initialPolicySet" in parameters)
					initialPolicySet = parameters.initialPolicySet;
				
				if("initialExplicitPolicy" in parameters)
					initialExplicitPolicy = parameters.initialExplicitPolicy;
				
				if("initialPolicyMappingInhibit" in parameters)
					initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit;
				
				if("initialInhibitPolicy" in parameters)
					initialInhibitPolicy = parameters.initialInhibitPolicy;
				
				if("initialPermittedSubtreesSet" in parameters)
					initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet;
				
				if("initialExcludedSubtreesSet" in parameters)
					initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet;
				
				if("initialRequiredNameForms" in parameters)
					initialRequiredNameForms = parameters.initialRequiredNameForms;
				
				let explicitPolicyIndicator = initialExplicitPolicy;
				let policyMappingInhibitIndicator = initialPolicyMappingInhibit;
				let inhibitAnyPolicyIndicator = initialInhibitPolicy;
				
				const pendingConstraints = new Array(3);
				pendingConstraints[0] = false; // For "explicitPolicyPending"
				pendingConstraints[1] = false; // For "policyMappingInhibitPending"
				pendingConstraints[2] = false; // For "inhibitAnyPolicyPending"
				
				let explicitPolicyPending = 0;
				let policyMappingInhibitPending = 0;
				let inhibitAnyPolicyPending = 0;
				
				let permittedSubtrees = initialPermittedSubtreesSet;
				let excludedSubtrees = initialExcludedSubtreesSet;
				const requiredNameForms = initialRequiredNameForms;
				
				let pathDepth = 1;
				//endregion
				
				//region Sorting certificates in the chain array
				this.certs = await this.sort(passedWhenNotRevValues);
				//endregion
				
				//region Work with policies
				//region Support variables
				const allPolicies = []; // Array of all policies (string values)
				allPolicies.push("2.5.29.32.0"); // Put "anyPolicy" at first place
				
				const policiesAndCerts = []; // In fact "array of array" where rows are for each specific policy, column for each certificate and value is "true/false"
				
				const anyPolicyArray = new Array(this.certs.length - 1); // Minus "trusted anchor"
				for(let ii = 0; ii < (this.certs.length - 1); ii++)
					anyPolicyArray[ii] = true;
				
				policiesAndCerts.push(anyPolicyArray);
				
				const policyMappings = new Array(this.certs.length - 1); // Array of "PolicyMappings" for each certificate
				const certPolicies = new Array(this.certs.length - 1); // Array of "CertificatePolicies" for each certificate
				
				let explicitPolicyStart = (explicitPolicyIndicator) ? (this.certs.length - 1) : (-1);
				//endregion
				
				//region Gather all neccessary information from certificate chain
				for(let i = (this.certs.length - 2); i >= 0; i--, pathDepth++)
				{
					if("extensions" in this.certs[i])
					{
						//region Get information about certificate extensions
						for(let j = 0; j < this.certs[i].extensions.length; j++)
						{
							//region CertificatePolicies
							if(this.certs[i].extensions[j].extnID === "2.5.29.32")
							{
								certPolicies[i] = this.certs[i].extensions[j].parsedValue;
								
								//region Remove entry from "anyPolicies" for the certificate
								for(let s = 0; s < allPolicies.length; s++)
								{
									if(allPolicies[s] === "2.5.29.32.0")
									{
										delete (policiesAndCerts[s])[i];
										break;
									}
								}
								//endregion
								
								for(let k = 0; k < this.certs[i].extensions[j].parsedValue.certificatePolicies.length; k++)
								{
									let policyIndex = (-1);
									
									//region Try to find extension in "allPolicies" array
									for(let s = 0; s < allPolicies.length; s++)
									{
										if(this.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier === allPolicies[s])
										{
											policyIndex = s;
											break;
										}
									}
									//endregion
									
									if(policyIndex === (-1))
									{
										allPolicies.push(this.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier);
										
										const certArray = new Array(this.certs.length - 1);
										certArray[i] = true;
										
										policiesAndCerts.push(certArray);
									}
									else
										(policiesAndCerts[policyIndex])[i] = true;
								}
							}
							//endregion
							
							//region PolicyMappings
							if(this.certs[i].extensions[j].extnID === "2.5.29.33")
							{
								if(policyMappingInhibitIndicator)
								{
									return {
										result: false,
										resultCode: 98,
										resultMessage: "Policy mapping prohibited"
									};
								}
								
								policyMappings[i] = this.certs[i].extensions[j].parsedValue;
							}
							//endregion
							
							//region PolicyConstraints
							if(this.certs[i].extensions[j].extnID === "2.5.29.36")
							{
								if(explicitPolicyIndicator === false)
								{
									//region requireExplicitPolicy
									if(this.certs[i].extensions[j].parsedValue.requireExplicitPolicy === 0)
									{
										explicitPolicyIndicator = true;
										explicitPolicyStart = i;
									}
									else
									{
										if(pendingConstraints[0] === false)
										{
											pendingConstraints[0] = true;
											explicitPolicyPending = this.certs[i].extensions[j].parsedValue.requireExplicitPolicy;
										}
										else
											explicitPolicyPending = (explicitPolicyPending > this.certs[i].extensions[j].parsedValue.requireExplicitPolicy) ? this.certs[i].extensions[j].parsedValue.requireExplicitPolicy : explicitPolicyPending;
									}
									//endregion
									
									//region inhibitPolicyMapping
									if(this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping === 0)
										policyMappingInhibitIndicator = true;
									else
									{
										if(pendingConstraints[1] === false)
										{
											pendingConstraints[1] = true;
											policyMappingInhibitPending = this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1;
										}
										else
											policyMappingInhibitPending = (policyMappingInhibitPending > (this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1)) ? (this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1) : policyMappingInhibitPending;
									}
									//endregion
								}
							}
							//endregion
							
							//region InhibitAnyPolicy
							if(this.certs[i].extensions[j].extnID === "2.5.29.54")
							{
								if(inhibitAnyPolicyIndicator === false)
								{
									if(this.certs[i].extensions[j].parsedValue.valueBlock.valueDec === 0)
										inhibitAnyPolicyIndicator = true;
									else
									{
										if(pendingConstraints[2] === false)
										{
											pendingConstraints[2] = true;
											inhibitAnyPolicyPending = this.certs[i].extensions[j].parsedValue.valueBlock.valueDec;
										}
										else
											inhibitAnyPolicyPending = (inhibitAnyPolicyPending > this.certs[i].extensions[j].parsedValue.valueBlock.valueDec) ? this.certs[i].extensions[j].parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
									}
								}
							}
							//endregion
						}
						//endregion
						
						//region Check "inhibitAnyPolicyIndicator"
						if(inhibitAnyPolicyIndicator === true)
						{
							let policyIndex = (-1);
							
							//region Find "anyPolicy" index
							for(let searchAnyPolicy = 0; searchAnyPolicy < allPolicies.length; searchAnyPolicy++)
							{
								if(allPolicies[searchAnyPolicy] === "2.5.29.32.0")
								{
									policyIndex = searchAnyPolicy;
									break;
								}
							}
							//endregion
							
							if(policyIndex !== (-1))
								delete (policiesAndCerts[0])[i]; // Unset value to "undefined" for "anyPolicies" value for current certificate
						}
						//endregion
						
						//region Process with "pending constraints"
						if(explicitPolicyIndicator === false)
						{
							if(pendingConstraints[0] === true)
							{
								explicitPolicyPending--;
								if(explicitPolicyPending === 0)
								{
									explicitPolicyIndicator = true;
									explicitPolicyStart = i;
									
									pendingConstraints[0] = false;
								}
							}
						}
						
						if(policyMappingInhibitIndicator === false)
						{
							if(pendingConstraints[1] === true)
							{
								policyMappingInhibitPending--;
								if(policyMappingInhibitPending === 0)
								{
									policyMappingInhibitIndicator = true;
									pendingConstraints[1] = false;
								}
							}
						}
						
						if(inhibitAnyPolicyIndicator === false)
						{
							if(pendingConstraints[2] === true)
							{
								inhibitAnyPolicyPending--;
								if(inhibitAnyPolicyPending === 0)
								{
									inhibitAnyPolicyIndicator = true;
									pendingConstraints[2] = false;
								}
							}
						}
						//endregion
					}
				}
				//endregion
				
				//region Working with policy mappings
				for(let i = 0; i < (this.certs.length - 1); i++)
				{
					//region Check that there is "policy mapping" for level "i + 1"
					if((i < (this.certs.length - 2)) && (typeof policyMappings[i + 1] !== "undefined"))
					{
						for(let k = 0; k < policyMappings[i + 1].mappings.length; k++)
						{
							//region Check that we do not have "anyPolicy" in current mapping
							if((policyMappings[i + 1].mappings[k].issuerDomainPolicy === "2.5.29.32.0") || (policyMappings[i + 1].mappings[k].subjectDomainPolicy === "2.5.29.32.0"))
							{
								return {
									result: false,
									resultCode: 99,
									resultMessage: "The \"anyPolicy\" should not be a part of policy mapping scheme"
								};
							}
							//endregion
							
							//region Initial variables
							let issuerDomainPolicyIndex = (-1);
							let subjectDomainPolicyIndex = (-1);
							//endregion
							
							//region Search for index of policies indedes
							for(let n = 0; n < allPolicies.length; n++)
							{
								if(allPolicies[n] === policyMappings[i + 1].mappings[k].issuerDomainPolicy)
									issuerDomainPolicyIndex = n;
								
								if(allPolicies[n] === policyMappings[i + 1].mappings[k].subjectDomainPolicy)
									subjectDomainPolicyIndex = n;
							}
							//endregion
							
							//region Delete existing "issuerDomainPolicy" because on the level we mapped the policy to another one
							if(typeof (policiesAndCerts[issuerDomainPolicyIndex])[i] !== "undefined")
								delete (policiesAndCerts[issuerDomainPolicyIndex])[i];
							//endregion
							
							//region Check all policies for the certificate
							for(let j = 0; j < certPolicies[i].certificatePolicies.length; j++)
							{
								if(policyMappings[i + 1].mappings[k].subjectDomainPolicy === certPolicies[i].certificatePolicies[j].policyIdentifier)
								{
									//region Set mapped policy for current certificate
									if((issuerDomainPolicyIndex !== (-1)) && (subjectDomainPolicyIndex !== (-1)))
									{
										for(let m = 0; m <= i; m++)
										{
											if(typeof (policiesAndCerts[subjectDomainPolicyIndex])[m] !== "undefined")
											{
												(policiesAndCerts[issuerDomainPolicyIndex])[m] = true;
												delete (policiesAndCerts[subjectDomainPolicyIndex])[m];
											}
										}
									}
									//endregion
								}
							}
							//endregion
						}
					}
					//endregion
				}
				//endregion
				
				//region Working with "explicitPolicyIndicator" and "anyPolicy"
				for(let i = 0; i < allPolicies.length; i++)
				{
					if(allPolicies[i] === "2.5.29.32.0")
					{
						for(let j = 0; j < explicitPolicyStart; j++)
							delete (policiesAndCerts[i])[j];
					}
				}
				//endregion
				
				//region Create "set of authorities-constrained policies"
				const authConstrPolicies = [];
				
				for(let i = 0; i < policiesAndCerts.length; i++)
				{
					let found = true;
					
					for(let j = 0; j < (this.certs.length - 1); j++)
					{
						let anyPolicyFound = false;
						
						if((j < explicitPolicyStart) && (allPolicies[i] === "2.5.29.32.0") && (allPolicies.length > 1))
						{
							found = false;
							break;
						}
						
						if(typeof (policiesAndCerts[i])[j] === "undefined")
						{
							if(j >= explicitPolicyStart)
							{
								//region Search for "anyPolicy" in the policy set
								for(let k = 0; k < allPolicies.length; k++)
								{
									if(allPolicies[k] === "2.5.29.32.0")
									{
										if((policiesAndCerts[k])[j] === true)
											anyPolicyFound = true;
										
										break;
									}
								}
								//endregion
							}
							
							if(!anyPolicyFound)
							{
								found = false;
								break;
							}
						}
					}
					
					if(found === true)
						authConstrPolicies.push(allPolicies[i]);
				}
				//endregion
				
				//region Create "set of user-constrained policies"
				let userConstrPolicies = [];
				
				if((initialPolicySet.length === 1) && (initialPolicySet[0] === "2.5.29.32.0") && (explicitPolicyIndicator === false))
					userConstrPolicies = initialPolicySet;
				else
				{
					if((authConstrPolicies.length === 1) && (authConstrPolicies[0] === "2.5.29.32.0"))
						userConstrPolicies = initialPolicySet;
					else
					{
						for(let i = 0; i < authConstrPolicies.length; i++)
						{
							for(let j = 0; j < initialPolicySet.length; j++)
							{
								if((initialPolicySet[j] === authConstrPolicies[i]) || (initialPolicySet[j] === "2.5.29.32.0"))
								{
									userConstrPolicies.push(authConstrPolicies[i]);
									break;
								}
							}
						}
					}
				}
				//endregion
				
				//region Combine output object
				const policyResult = {
					result: (userConstrPolicies.length > 0),
					resultCode: 0,
					resultMessage: (userConstrPolicies.length > 0) ? "" : "Zero \"userConstrPolicies\" array, no intersections with \"authConstrPolicies\"",
					authConstrPolicies,
					userConstrPolicies,
					explicitPolicyIndicator,
					policyMappings,
					certificatePath: this.certs
				};
				
				if(userConstrPolicies.length === 0)
					return policyResult;
				//endregion
				//endregion
				
				//region Work with name constraints
				//region Check a result from "policy checking" part
				if(policyResult.result === false)
					return policyResult;
				//endregion
				
				//region Check all certificates, excluding "trust anchor"
				pathDepth = 1;
				
				for(let i = (this.certs.length - 2); i >= 0; i--, pathDepth++)
				{
					//region Support variables
					let subjectAltNames = [];
					
					let certPermittedSubtrees = [];
					let certExcludedSubtrees = [];
					//endregion
					
					if("extensions" in this.certs[i])
					{
						for(let j = 0; j < this.certs[i].extensions.length; j++)
						{
							//region NameConstraints
							if(this.certs[i].extensions[j].extnID === "2.5.29.30")
							{
								if("permittedSubtrees" in this.certs[i].extensions[j].parsedValue)
									certPermittedSubtrees = certPermittedSubtrees.concat(this.certs[i].extensions[j].parsedValue.permittedSubtrees);
								
								if("excludedSubtrees" in this.certs[i].extensions[j].parsedValue)
									certExcludedSubtrees = certExcludedSubtrees.concat(this.certs[i].extensions[j].parsedValue.excludedSubtrees);
							}
							//endregion
							
							//region SubjectAltName
							if(this.certs[i].extensions[j].extnID === "2.5.29.17")
								subjectAltNames = subjectAltNames.concat(this.certs[i].extensions[j].parsedValue.altNames);
							//endregion
						}
					}
					
					//region Checking for "required name forms"
					let formFound = (requiredNameForms.length <= 0);
					
					for(let j = 0; j < requiredNameForms.length; j++)
					{
						switch(requiredNameForms[j].base.type)
						{
							case 4: // directoryName
							{
								if(requiredNameForms[j].base.value.typesAndValues.length !== this.certs[i].subject.typesAndValues.length)
									continue;
								
								formFound = true;
								
								for(let k = 0; k < this.certs[i].subject.typesAndValues.length; k++)
								{
									if(this.certs[i].subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type)
									{
										formFound = false;
										break;
									}
								}
								
								if(formFound === true)
									break;
							}
								break;
							default: // ??? Probably here we should reject the certificate ???
						}
					}
					
					if(formFound === false)
					{
						policyResult.result = false;
						policyResult.resultCode = 21;
						policyResult.resultMessage = "No neccessary name form found";
						
						throw policyResult;
					}
					//endregion
					
					//region Checking for "permited sub-trees"
					//region Make groups for all types of constraints
					const constrGroups = []; // Array of array for groupped constraints
					constrGroups[0] = []; // rfc822Name
					constrGroups[1] = []; // dNSName
					constrGroups[2] = []; // directoryName
					constrGroups[3] = []; // uniformResourceIdentifier
					constrGroups[4] = []; // iPAddress
					
					for(let j = 0; j < permittedSubtrees.length; j++)
					{
						switch(permittedSubtrees[j].base.type)
						{
							//region rfc822Name
							case 1:
								constrGroups[0].push(permittedSubtrees[j]);
								break;
							//endregion
							//region dNSName
							case 2:
								constrGroups[1].push(permittedSubtrees[j]);
								break;
							//endregion
							//region directoryName
							case 4:
								constrGroups[2].push(permittedSubtrees[j]);
								break;
							//endregion
							//region uniformResourceIdentifier
							case 6:
								constrGroups[3].push(permittedSubtrees[j]);
								break;
							//endregion
							//region iPAddress
							case 7:
								constrGroups[4].push(permittedSubtrees[j]);
								break;
							//endregion
							//region default
							default:
							//endregion
						}
					}
					//endregion
					
					//region Check name constraints groupped by type, one-by-one
					for(let p = 0; p < 5; p++)
					{
						let groupPermitted = false;
						let valueExists = false;
						const group = constrGroups[p];
						
						for(let j = 0; j < group.length; j++)
						{
							switch(p)
							{
								//region rfc822Name
								case 0:
									if(subjectAltNames.length > 0)
									{
										for(let k = 0; k < subjectAltNames.length; k++)
										{
											if(subjectAltNames[k].type === 1) // rfc822Name
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);
											}
										}
									}
									else // Try to find out "emailAddress" inside "subject"
									{
										for(let k = 0; k < this.certs[i].subject.typesAndValues.length; k++)
										{
											if((this.certs[i].subject.typesAndValues[k].type === "1.2.840.113549.1.9.1") ||    // PKCS#9 e-mail address
												(this.certs[i].subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3")) // RFC1274 "rfc822Mailbox" e-mail address
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareRFC822Name(this.certs[i].subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);
											}
										}
									}
									break;
								//endregion
								//region dNSName
								case 1:
									if(subjectAltNames.length > 0)
									{
										for(let k = 0; k < subjectAltNames.length; k++)
										{
											if(subjectAltNames[k].type === 2) // dNSName
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);
											}
										}
									}
									break;
								//endregion
								//region directoryName
								case 2:
									valueExists = true;
									groupPermitted = compareDirectoryName(this.certs[i].subject, group[j].base.value);
									break;
								//endregion
								//region uniformResourceIdentifier
								case 3:
									if(subjectAltNames.length > 0)
									{
										for(let k = 0; k < subjectAltNames.length; k++)
										{
											if(subjectAltNames[k].type === 6) // uniformResourceIdentifier
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);
											}
										}
									}
									break;
								//endregion
								//region iPAddress
								case 4:
									if(subjectAltNames.length > 0)
									{
										for(let k = 0; k < subjectAltNames.length; k++)
										{
											if(subjectAltNames[k].type === 7) // iPAddress
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);
											}
										}
									}
									break;
								//endregion
								//region default
								default:
								//endregion
							}
							
							if(groupPermitted)
								break;
						}
						
						if((groupPermitted === false) && (group.length > 0) && valueExists)
						{
							policyResult.result = false;
							policyResult.resultCode = 41;
							policyResult.resultMessage = "Failed to meet \"permitted sub-trees\" name constraint";
							
							throw policyResult;
						}
					}
					//endregion
					//endregion
					
					//region Checking for "excluded sub-trees"
					let excluded = false;
					
					for(let j = 0; j < excludedSubtrees.length; j++)
					{
						switch(excludedSubtrees[j].base.type)
						{
							//region rfc822Name
							case 1:
								if(subjectAltNames.length >= 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 1) // rfc822Name
											excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								}
								else // Try to find out "emailAddress" inside "subject"
								{
									for(let k = 0; k < this.certs[i].subject.typesAndValues.length; k++)
									{
										if((this.certs[i].subject.typesAndValues[k].type === "1.2.840.113549.1.9.1") ||    // PKCS#9 e-mail address
											(this.certs[i].subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3")) // RFC1274 "rfc822Mailbox" e-mail address
											excluded = excluded || compareRFC822Name(this.certs[i].subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j].base.value);
									}
								}
								break;
							//endregion
							//region dNSName
							case 2:
								if(subjectAltNames.length > 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 2) // dNSName
											excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								}
								break;
							//endregion
							//region directoryName
							case 4:
								excluded = excluded || compareDirectoryName(this.certs[i].subject, excludedSubtrees[j].base.value);
								break;
							//endregion
							//region uniformResourceIdentifier
							case 6:
								if(subjectAltNames.length > 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 6) // uniformResourceIdentifier
											excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								}
								break;
							//endregion
							//region iPAddress
							case 7:
								if(subjectAltNames.length > 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 7) // iPAddress
											excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								}
								break;
							//endregion
							//region default
							default: // No action, but probably here we need to create a warning for "malformed constraint"
							//endregion
						}
						
						if(excluded)
							break;
					}
					
					if(excluded === true)
					{
						policyResult.result = false;
						policyResult.resultCode = 42;
						policyResult.resultMessage = "Failed to meet \"excluded sub-trees\" name constraint";
						
						throw policyResult;
					}
					//endregion
					
					//region Append "cert_..._subtrees" to "..._subtrees"
					permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
					excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
					//endregion
				}
				//endregion
				
				return policyResult;
				//endregion
			}
			catch(error)
			{
				if(error instanceof Object)
				{
					if("resultMessage" in error)
						return error;
					
					if("message" in error)
					{
						return {
							result: false,
							resultCode: -1,
							resultMessage: error.message
						};
					}
				}
				
				return {
					result: false,
					resultCode: -1,
					resultMessage: error
				};
			}
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class RevokedCertificate
	{
		//**********************************************************************************
		/**
		 * Constructor for RevokedCertificate class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {Integer}
			 * @desc userCertificate
			 */
			this.userCertificate = getParametersValue$2(parameters, "userCertificate", RevokedCertificate.defaultValues("userCertificate"));
			/**
			 * @type {Time}
			 * @desc revocationDate
			 */
			this.revocationDate = getParametersValue$2(parameters, "revocationDate", RevokedCertificate.defaultValues("revocationDate"));

			if("crlEntryExtensions" in parameters)
				/**
				 * @type {Extensions}
				 * @desc crlEntryExtensions
				 */
				this.crlEntryExtensions = getParametersValue$2(parameters, "crlEntryExtensions", RevokedCertificate.defaultValues("crlEntryExtensions"));
			//endregion

			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "userCertificate":
					return new Integer$1();
				case "revocationDate":
					return new Time();
				case "crlEntryExtensions":
					return new Extensions();
				default:
					throw new Error(`Invalid member name for RevokedCertificate class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * revokedCertificates     SEQUENCE OF SEQUENCE  {
	     *        userCertificate         CertificateSerialNumber,
	     *        revocationDate          Time,
	     *        crlEntryExtensions      Extensions OPTIONAL
	     *                                 -- if present, version MUST be v2
	     *                             }  OPTIONAL,
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [userCertificate]
			 * @property {string} [revocationDate]
			 * @property {string} [crlEntryExtensions]
			 */
			const names = getParametersValue$2(parameters, "names", {});

			return new Sequence$1({
				name: (names.blockName || ""),
				value: [
					new Integer$1({ name: (names.userCertificate || "userCertificate") }),
					Time.schema({
						names: {
							utcTimeName: (names.revocationDate || "revocationDate"),
							generalTimeName: (names.revocationDate || "revocationDate")
						}
					}),
					Extensions.schema({
						names: {
							blockName: (names.crlEntryExtensions || "crlEntryExtensions")
						}
					}, true)
				]
			});
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"userCertificate",
				"revocationDate",
				"crlEntryExtensions"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				RevokedCertificate.schema()
			);

			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for RevokedCertificate");
			//endregion

			//region Get internal properties from parsed schema
			this.userCertificate = asn1.result.userCertificate;
			this.revocationDate = new Time({ schema: asn1.result.revocationDate });

			if("crlEntryExtensions" in asn1.result)
				this.crlEntryExtensions = new Extensions({ schema: asn1.result.crlEntryExtensions });
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema()
		{
			//region Create array for output sequence
			const outputArray = [
				this.userCertificate,
				this.revocationDate.toSchema()
			];

			if("crlEntryExtensions" in this)
				outputArray.push(this.crlEntryExtensions.toSchema());
			//endregion

			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: outputArray
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				userCertificate: this.userCertificate.toJSON(),
				revocationDate: this.revocationDate.toJSON
			};

			if("crlEntryExtensions" in this)
				object.crlEntryExtensions = this.crlEntryExtensions.toJSON();

			return object;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	//**************************************************************************************
	function tbsCertList(parameters = {})
	{
		//TBSCertList  ::=  SEQUENCE  {
		//    version                 Version OPTIONAL,
		//                                 -- if present, MUST be v2
		//    signature               AlgorithmIdentifier,
		//    issuer                  Name,
		//    thisUpdate              Time,
		//    nextUpdate              Time OPTIONAL,
		//    revokedCertificates     SEQUENCE OF SEQUENCE  {
		//        userCertificate         CertificateSerialNumber,
		//        revocationDate          Time,
		//        crlEntryExtensions      Extensions OPTIONAL
		//        -- if present, version MUST be v2
		//    }  OPTIONAL,
		//    crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
		//    -- if present, version MUST be v2
		//}
		
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [tbsCertListVersion]
		 * @property {string} [signature]
		 * @property {string} [issuer]
		 * @property {string} [tbsCertListThisUpdate]
		 * @property {string} [tbsCertListNextUpdate]
		 * @property {string} [tbsCertListRevokedCertificates]
		 * @property {string} [crlExtensions]
		 */
		const names = getParametersValue$2(parameters, "names", {});
		
		return (new Sequence$1({
			name: (names.blockName || "tbsCertList"),
			value: [
				new Integer$1({
					optional: true,
					name: (names.tbsCertListVersion || "tbsCertList.version"),
					value: 2
				}), // EXPLICIT integer value (v2)
				AlgorithmIdentifier$1.schema(names.signature || {
					names: {
						blockName: "tbsCertList.signature"
					}
				}),
				RelativeDistinguishedNames.schema(names.issuer || {
					names: {
						blockName: "tbsCertList.issuer"
					}
				}),
				Time.schema(names.tbsCertListThisUpdate || {
					names: {
						utcTimeName: "tbsCertList.thisUpdate",
						generalTimeName: "tbsCertList.thisUpdate"
					}
				}),
				Time.schema(names.tbsCertListNextUpdate || {
					names: {
						utcTimeName: "tbsCertList.nextUpdate",
						generalTimeName: "tbsCertList.nextUpdate"
					}
				}, true),
				new Sequence$1({
					optional: true,
					value: [
						new Repeated({
							name: (names.tbsCertListRevokedCertificates || "tbsCertList.revokedCertificates"),
							value: new Sequence$1({
								value: [
									new Integer$1(),
									Time.schema(),
									Extensions.schema({}, true)
								]
							})
						})
					]
				}),
				new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [Extensions.schema(names.crlExtensions || {
						names: {
							blockName: "tbsCertList.extensions"
						}
					})]
				}) // EXPLICIT SEQUENCE value
			]
		}));
	}
	//**************************************************************************************
	/**
	 * Class from RFC5280
	 */
	class CertificateRevocationList {
		//**********************************************************************************
		/**
		 * Constructor for Attribute class
		 * @param {Object} [parameters={}]
		 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
		 */
		constructor(parameters = {})
		{
			//region Internal properties of the object
			/**
			 * @type {ArrayBuffer}
			 * @desc tbs
			 */
			this.tbs = getParametersValue$2(parameters, "tbs", CertificateRevocationList.defaultValues("tbs"));
			/**
			 * @type {number}
			 * @desc version
			 */
			this.version = getParametersValue$2(parameters, "version", CertificateRevocationList.defaultValues("version"));
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc signature
			 */
			this.signature = getParametersValue$2(parameters, "signature", CertificateRevocationList.defaultValues("signature"));
			/**
			 * @type {RelativeDistinguishedNames}
			 * @desc issuer
			 */
			this.issuer = getParametersValue$2(parameters, "issuer", CertificateRevocationList.defaultValues("issuer"));
			/**
			 * @type {Time}
			 * @desc thisUpdate
			 */
			this.thisUpdate = getParametersValue$2(parameters, "thisUpdate", CertificateRevocationList.defaultValues("thisUpdate"));
			
			if("nextUpdate" in parameters)
				/**
				 * @type {Time}
				 * @desc nextUpdate
				 */
				this.nextUpdate = getParametersValue$2(parameters, "nextUpdate", CertificateRevocationList.defaultValues("nextUpdate"));
			
			if("revokedCertificates" in parameters)
				/**
				 * @type {Array.<RevokedCertificate>}
				 * @desc revokedCertificates
				 */
				this.revokedCertificates = getParametersValue$2(parameters, "revokedCertificates", CertificateRevocationList.defaultValues("revokedCertificates"));
			
			if("crlExtensions" in parameters)
				/**
				 * @type {Extensions}
				 * @desc crlExtensions
				 */
				this.crlExtensions = getParametersValue$2(parameters, "crlExtensions", CertificateRevocationList.defaultValues("crlExtensions"));
			
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc signatureAlgorithm
			 */
			this.signatureAlgorithm = getParametersValue$2(parameters, "signatureAlgorithm", CertificateRevocationList.defaultValues("signatureAlgorithm"));
			/**
			 * @type {BitString}
			 * @desc signatureValue
			 */
			this.signatureValue = getParametersValue$2(parameters, "signatureValue", CertificateRevocationList.defaultValues("signatureValue"));
			//endregion
			
			//region If input argument array contains "schema" for this object
			if("schema" in parameters)
				this.fromSchema(parameters.schema);
			//endregion
		}
		//**********************************************************************************
		/**
		 * Return default values for all class members
		 * @param {string} memberName String name for a class member
		 */
		static defaultValues(memberName)
		{
			switch(memberName)
			{
				case "tbs":
					return new ArrayBuffer(0);
				case "version":
					return 1;
				case "signature":
					return new AlgorithmIdentifier$1();
				case "issuer":
					return new RelativeDistinguishedNames();
				case "thisUpdate":
					return new Time();
				case "nextUpdate":
					return new Time();
				case "revokedCertificates":
					return [];
				case "crlExtensions":
					return new Extensions();
				case "signatureAlgorithm":
					return new AlgorithmIdentifier$1();
				case "signatureValue":
					return new BitString$1();
				default:
					throw new Error(`Invalid member name for CertificateRevocationList class: ${memberName}`);
			}
		}
		//**********************************************************************************
		/**
		 * Return value of pre-defined ASN.1 schema for current class
		 *
		 * ASN.1 schema:
		 * ```asn1
		 * CertificateList  ::=  SEQUENCE  {
		 *    tbsCertList          TBSCertList,
		 *    signatureAlgorithm   AlgorithmIdentifier,
		 *    signatureValue       BIT STRING  }
		 * ```
		 *
		 * @param {Object} parameters Input parameters for the schema
		 * @returns {Object} asn1js schema object
		 */
		static schema(parameters = {})
		{
			/**
			 * @type {Object}
			 * @property {string} [blockName]
			 * @property {string} [signatureAlgorithm]
			 * @property {string} [signatureValue]
			 */
			const names = getParametersValue$2(parameters, "names", {});
			
			return (new Sequence$1({
				name: (names.blockName || "CertificateList"),
				value: [
					tbsCertList(parameters),
					AlgorithmIdentifier$1.schema(names.signatureAlgorithm || {
						names: {
							blockName: "signatureAlgorithm"
						}
					}),
					new BitString$1({ name: (names.signatureValue || "signatureValue") })
				]
			}));
		}
		//**********************************************************************************
		/**
		 * Convert parsed asn1js object into current class
		 * @param {!Object} schema
		 */
		fromSchema(schema)
		{
			//region Clear input data first
			clearProps$1(schema, [
				"tbsCertList",
				"tbsCertList.version",
				"tbsCertList.signature",
				"tbsCertList.issuer",
				"tbsCertList.thisUpdate",
				"tbsCertList.nextUpdate",
				"tbsCertList.revokedCertificates",
				"tbsCertList.extensions",
				"signatureAlgorithm",
				"signatureValue"
			]);
			//endregion
			
			//region Check the schema is valid
			const asn1 = compareSchema(schema,
				schema,
				CertificateRevocationList.schema()
			);
			
			if(asn1.verified === false)
				throw new Error("Object's schema was not verified against input data for CertificateRevocationList");
			//endregion
			
			//region Get internal properties from parsed schema
			// noinspection JSUnresolvedVariable
			this.tbs = asn1.result.tbsCertList.valueBeforeDecode;
			
			if("tbsCertList.version" in asn1.result)
				this.version = asn1.result["tbsCertList.version"].valueBlock.valueDec;
			this.signature = new AlgorithmIdentifier$1({ schema: asn1.result["tbsCertList.signature"] });
			this.issuer = new RelativeDistinguishedNames({ schema: asn1.result["tbsCertList.issuer"] });
			this.thisUpdate = new Time({ schema: asn1.result["tbsCertList.thisUpdate"] });
			if("tbsCertList.nextUpdate" in asn1.result)
				this.nextUpdate = new Time({ schema: asn1.result["tbsCertList.nextUpdate"] });
			if("tbsCertList.revokedCertificates" in asn1.result)
				this.revokedCertificates = Array.from(asn1.result["tbsCertList.revokedCertificates"], element => new RevokedCertificate({ schema: element }));
			if("tbsCertList.extensions" in asn1.result)
				this.crlExtensions = new Extensions({ schema: asn1.result["tbsCertList.extensions"] });
			
			this.signatureAlgorithm = new AlgorithmIdentifier$1({ schema: asn1.result.signatureAlgorithm });
			this.signatureValue = asn1.result.signatureValue;
			//endregion
		}
		//**********************************************************************************
		encodeTBS()
		{
			//region Create array for output sequence
			const outputArray = [];
			
			if(this.version !== CertificateRevocationList.defaultValues("version"))
				outputArray.push(new Integer$1({ value: this.version }));
			
			outputArray.push(this.signature.toSchema());
			outputArray.push(this.issuer.toSchema());
			outputArray.push(this.thisUpdate.toSchema());
			
			if("nextUpdate" in this)
				outputArray.push(this.nextUpdate.toSchema());
			
			if("revokedCertificates" in this)
			{
				outputArray.push(new Sequence$1({
					value: Array.from(this.revokedCertificates, element => element.toSchema())
				}));
			}
			
			if("crlExtensions" in this)
			{
				outputArray.push(new Constructed$1({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						this.crlExtensions.toSchema()
					]
				}));
			}
			//endregion
			
			return (new Sequence$1({
				value: outputArray
			}));
		}
		//**********************************************************************************
		/**
		 * Convert current object to asn1js object and set correct values
		 * @returns {Object} asn1js object
		 */
		toSchema(encodeFlag = false)
		{
			//region Decode stored TBS value
			let tbsSchema;
			
			if(encodeFlag === false)
			{
				if(this.tbs.length === 0) // No stored TBS part
					return CertificateRevocationList.schema();
				
				tbsSchema = fromBER$1(this.tbs).result;
			}
			//endregion
			//region Create TBS schema via assembling from TBS parts
			else
				tbsSchema = this.encodeTBS();
			//endregion
			
			//region Construct and return new ASN.1 schema for this object
			return (new Sequence$1({
				value: [
					tbsSchema,
					this.signatureAlgorithm.toSchema(),
					this.signatureValue
				]
			}));
			//endregion
		}
		//**********************************************************************************
		/**
		 * Convertion for the class to JSON object
		 * @returns {Object}
		 */
		toJSON()
		{
			const object = {
				tbs: bufferToHexCodes$2(this.tbs, 0, this.tbs.byteLength),
				signature: this.signature.toJSON(),
				issuer: this.issuer.toJSON(),
				thisUpdate: this.thisUpdate.toJSON(),
				signatureAlgorithm: this.signatureAlgorithm.toJSON(),
				signatureValue: this.signatureValue.toJSON()
			};
			
			if(this.version !== CertificateRevocationList.defaultValues("version"))
				object.version = this.version;
			
			if("nextUpdate" in this)
				object.nextUpdate = this.nextUpdate.toJSON();
			
			if("revokedCertificates" in this)
				object.revokedCertificates = Array.from(this.revokedCertificates, element => element.toJSON());
			
			if("crlExtensions" in this)
				object.crlExtensions = this.crlExtensions.toJSON();
			
			return object;
		}
		//**********************************************************************************
		isCertificateRevoked(certificate)
		{
			//region Check that issuer of the input certificate is the same with issuer of this CRL
			if(this.issuer.isEqual(certificate.issuer) === false)
				return false;
			//endregion
			
			//region Check that there are revoked certificates in this CRL
			if(("revokedCertificates" in this) === false)
				return false;
			//endregion
			
			//region Search for input certificate in revoked certificates array
			for(const revokedCertificate of this.revokedCertificates)
			{
				if(revokedCertificate.userCertificate.isEqual(certificate.serialNumber))
					return true;
			}
			//endregion
			
			return false;
		}
		//**********************************************************************************
		/**
		 * Make a signature for existing CRL data
		 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
		 * @param {string} [hashAlgorithm] Hashing algorithm. Default SHA-1
		 */
		sign(privateKey, hashAlgorithm = "SHA-1")
		{
			//region Initial checking
			//region Get a private key from function parameter
			if(typeof privateKey === "undefined")
				return Promise.reject("Need to provide a private key for signing");
			//endregion
			//endregion
			
			//region Initial variables
			let sequence = Promise.resolve();
			let parameters;
			
			const engine = getEngine();
			//endregion
			
			//region Get a "default parameters" for current algorithm and set correct signature algorithm
			sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
			
			sequence = sequence.then(result =>
			{
				parameters = result.parameters;
				this.signature = result.signatureAlgorithm;
				this.signatureAlgorithm = result.signatureAlgorithm;
			});
			//endregion
			
			//region Create TBS data for signing
			sequence = sequence.then(() =>
			{
				this.tbs = this.encodeTBS().toBER(false);
			});
			//endregion
			
			//region Signing TBS data on provided private key
			sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));
			
			sequence = sequence.then(result =>
			{
				this.signatureValue = new BitString$1({ valueHex: result });
			});
			//endregion
			
			return sequence;
		}
		//**********************************************************************************
		/**
		 * Verify existing signature
		 * @param {{[issuerCertificate]: Object, [publicKeyInfo]: Object}} parameters
		 * @returns {*}
		 */
		verify(parameters = {})
		{
			//region Global variables
			let sequence = Promise.resolve();
			
			let subjectPublicKeyInfo = -1;
			
			const engine = getEngine();
			//endregion
			
			//region Get information about CRL issuer certificate
			if("issuerCertificate" in parameters) // "issuerCertificate" must be of type "Certificate"
			{
				subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo;
				
				// The CRL issuer name and "issuerCertificate" subject name are not equal
				if(this.issuer.isEqual(parameters.issuerCertificate.subject) === false)
					return Promise.resolve(false);
			}
			
			//region In case if there is only public key during verification
			if("publicKeyInfo" in parameters)
				subjectPublicKeyInfo = parameters.publicKeyInfo; // Must be of type "PublicKeyInfo"
			//endregion
			
			if(("subjectPublicKey" in subjectPublicKeyInfo) === false)
				return Promise.reject("Issuer's certificate must be provided as an input parameter");
			//endregion
			
			//region Check the CRL for unknown critical extensions
			if("crlExtensions" in this)
			{
				for(const extension of this.crlExtensions.extensions)
				{
					if(extension.critical)
					{
						// We can not be sure that unknown extension has no value for CRL signature
						if(("parsedValue" in extension) === false)
							return Promise.resolve(false);
					}
				}
			}
			//endregion
			
			sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm));
			
			return sequence;
		}
		//**********************************************************************************
	}
	//**************************************************************************************

	/* eslint-disable no-undef,no-unreachable */

	//<nodewebcryptoossl>
	//*********************************************************************************
	let certificateBuffer = new ArrayBuffer(0); // ArrayBuffer with loaded or created CERT
	let privateKeyBuffer = new ArrayBuffer(0);
	let trustedCertificates = []; // Array of root certificates from "CA Bundle"
	const intermadiateCertificates = []; // Array of intermediate certificates
	const crls = []; // Array of CRLs for all certificates (trusted + intermediate)

	let hashAlg = "SHA-1";
	let signAlg = "RSASSA-PKCS1-v1_5";
	let curveAlg = "P-256";
	//*********************************************************************************
	function formatPEM(pemString) {
		/// <summary>Format string in order to have each line with length equal to 63</summary>
		/// <param name="pemString" type="String">String to format</param>

		const stringLength = pemString.length;
		let resultString = "";

		for (let i = 0, count = 0; i < stringLength; i++, count++) {
			if (count > 63) {
				resultString = `${resultString}\r\n`;
				count = 0;
			}

			resultString = `${resultString}${pemString[i]}`;
		}

		return resultString;
	}
	//*********************************************************************************
	function parseCertificate() {
		//region Initial check
		if (certificateBuffer.byteLength === 0) {
			alert("Nothing to parse!");
			return;
		}
		//endregion

		//region Initial activities
		document.getElementById("cert-extn-div").style.display = "none";

		const issuerTable = document.getElementById("cert-issuer-table");
		while (issuerTable.rows.length > 1)
			issuerTable.deleteRow(issuerTable.rows.length - 1);

		const subjectTable = document.getElementById("cert-subject-table");
		while (subjectTable.rows.length > 1)
			subjectTable.deleteRow(subjectTable.rows.length - 1);

		const extensionTable = document.getElementById("cert-extn-table");
		while (extensionTable.rows.length > 1)
			extensionTable.deleteRow(extensionTable.rows.length - 1);
		//endregion

		//region Decode existing X.509 certificate
		const asn1 = fromBER(certificateBuffer);
		const certificate = new Certificate({
			schema: asn1.result
		});
		//endregion

		//region Put information about X.509 certificate issuer
		const rdnmap = {
			"2.5.4.6": "C",
			"2.5.4.10": "O",
			"2.5.4.11": "OU",
			"2.5.4.3": "CN",
			"2.5.4.7": "L",
			"2.5.4.8": "S",
			"2.5.4.12": "T",
			"2.5.4.42": "GN",
			"2.5.4.43": "I",
			"2.5.4.4": "SN",
			"1.2.840.113549.1.9.1": "E-mail"
		};

		for (const typeAndValue of certificate.issuer.typesAndValues) {
			let typeval = rdnmap[typeAndValue.type];
			if (typeof typeval === "undefined")
				typeval = typeAndValue.type;

			const subjval = typeAndValue.value.valueBlock.value;

			const row = issuerTable.insertRow(issuerTable.rows.length);
			const cell0 = row.insertCell(0);
			// noinspection InnerHTMLJS
			cell0.innerHTML = typeval;
			const cell1 = row.insertCell(1);
			// noinspection InnerHTMLJS
			cell1.innerHTML = subjval;
		}
		//endregion

		//region Put information about X.509 certificate subject
		for (const typeAndValue of certificate.subject.typesAndValues) {
			let typeval = rdnmap[typeAndValue.type];
			if (typeof typeval === "undefined")
				typeval = typeAndValue.type;

			const subjval = typeAndValue.value.valueBlock.value;

			const row = subjectTable.insertRow(subjectTable.rows.length);
			const cell0 = row.insertCell(0);
			// noinspection InnerHTMLJS
			cell0.innerHTML = typeval;
			const cell1 = row.insertCell(1);
			// noinspection InnerHTMLJS
			cell1.innerHTML = subjval;
		}
		//endregion

		//region Put information about X.509 certificate serial number
		// noinspection InnerHTMLJS
		document.getElementById("cert-serial-number").innerHTML = bufferToHexCodes(certificate.serialNumber.valueBlock.valueHex);
		//endregion

		//region Put information about issuance date
		// noinspection InnerHTMLJS
		document.getElementById("cert-not-before").innerHTML = certificate.notBefore.value.toString();
		//endregion

		//region Put information about expiration date
		// noinspection InnerHTMLJS
		document.getElementById("cert-not-after").innerHTML = certificate.notAfter.value.toString();

		if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549") !== (-1)) {
			const asn1PublicKey = fromBER(certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex);
			const rsaPublicKey = new RSAPublicKey({
				schema: asn1PublicKey.result
			});

			const modulusView = new Uint8Array(rsaPublicKey.modulus.valueBlock.valueHex);
			let modulusBitLength = 0;

			if (modulusView[0] === 0x00)
				modulusBitLength = (rsaPublicKey.modulus.valueBlock.valueHex.byteLength - 1) * 8;
			else
				modulusBitLength = rsaPublicKey.modulus.valueBlock.valueHex.byteLength * 8;

				document.getElementById("cert-keysize").innerHTML = modulusBitLength.toString();
		}

		//endregion

		//region Put information about signature algorithm
		const algomap = {
			"1.2.840.113549.1.1.2": "MD2 with RSA",
			"1.2.840.113549.1.1.4": "MD5 with RSA",
			"1.2.840.10040.4.3": "SHA1 with DSA",
			"1.2.840.10045.4.1": "SHA1 with ECDSA",
			"1.2.840.10045.4.3.2": "SHA256 with ECDSA",
			"1.2.840.10045.4.3.3": "SHA384 with ECDSA",
			"1.2.840.10045.4.3.4": "SHA512 with ECDSA",
			"1.2.840.113549.1.1.10": "RSA-PSS",
			"1.2.840.113549.1.1.5": "SHA1 with RSA",
			"1.2.840.113549.1.1.14": "SHA224 with RSA",
			"1.2.840.113549.1.1.11": "SHA256 with RSA",
			"1.2.840.113549.1.1.12": "SHA384 with RSA",
			"1.2.840.113549.1.1.13": "SHA512 with RSA"
		}; // array mapping of common algorithm OIDs and corresponding types

		let signatureAlgorithm = algomap[certificate.signatureAlgorithm.algorithmId];
		if (typeof signatureAlgorithm === "undefined")
			signatureAlgorithm = certificate.signatureAlgorithm.algorithmId;
		else
			signatureAlgorithm = `${signatureAlgorithm} (${certificate.signatureAlgorithm.algorithmId})`;

		// noinspection InnerHTMLJS
		document.getElementById("cert-sign-algo").innerHTML = signatureAlgorithm;
		//endregion

		//region Put information about certificate extensions
		if ("extensions" in certificate) {
			for (let i = 0; i < certificate.extensions.length; i++) {
				const row = extensionTable.insertRow(extensionTable.rows.length);
				const cell0 = row.insertCell(0);
				// noinspection InnerHTMLJS
				cell0.innerHTML = certificate.extensions[i].extnID;
			}

			document.getElementById("cert-extn-div").style.display = "block";
		}
		//endregion
	}
	//*********************************************************************************
	function createCertificateInternal() {
		//region Initial variables 
		let sequence = Promise.resolve();

		const certificate = new Certificate();

		let publicKey;
		let privateKey;

		trustedCertificates = [];
		//endregion

		//region Get a "crypto" extension 
		const crypto = getCrypto();
		if (typeof crypto === "undefined")
			return Promise.reject("No WebCrypto extension found");
		//endregion

		//region Put a static values 
		certificate.version = 2;
		certificate.serialNumber = new Integer({
			value: 1
		});
		certificate.issuer.typesAndValues.push(new AttributeTypeAndValue({
			type: "2.5.4.6", // Country name
			value: new PrintableString({
				value: "RU"
			})
		}));
		certificate.issuer.typesAndValues.push(new AttributeTypeAndValue({
			type: "2.5.4.3", // Common name
			value: new BmpString({
				value: "Test"
			})
		}));
		certificate.subject.typesAndValues.push(new AttributeTypeAndValue({
			type: "2.5.4.6", // Country name
			value: new PrintableString({
				value: "RU"
			})
		}));
		certificate.subject.typesAndValues.push(new AttributeTypeAndValue({
			type: "2.5.4.3", // Common name
			value: new BmpString({
				value: "Test"
			})
		}));

		certificate.notBefore.value = new Date(2019, 1, 1);
		certificate.notAfter.value = new Date(2022, 1, 1);

		certificate.extensions = []; // Extensions are not a part of certificate by default, it's an optional array

		//region "BasicConstraints" extension
		const basicConstr = new BasicConstraints({
			cA: true,
			pathLenConstraint: 3
		});

		certificate.extensions.push(new Extension({
			extnID: "2.5.29.19",
			critical: true,
			extnValue: basicConstr.toSchema().toBER(false),
			parsedValue: basicConstr // Parsed value for well-known extensions
		}));
		//endregion 

		//region "KeyUsage" extension 
		const bitArray = new ArrayBuffer(1);
		const bitView = new Uint8Array(bitArray);

		bitView[0] |= 0x02; // Key usage "cRLSign" flag
		bitView[0] |= 0x04; // Key usage "keyCertSign" flag

		const keyUsage = new BitString({
			valueHex: bitArray
		});

		certificate.extensions.push(new Extension({
			extnID: "2.5.29.15",
			critical: false,
			extnValue: keyUsage.toBER(false),
			parsedValue: keyUsage // Parsed value for well-known extensions
		}));
		//endregion

		//region "ExtendedKeyUsage" extension
		const extKeyUsage = new ExtKeyUsage({
			keyPurposes: [
				"2.5.29.37.0", // anyExtendedKeyUsage
				"1.3.6.1.5.5.7.3.1", // id-kp-serverAuth
				"1.3.6.1.5.5.7.3.2", // id-kp-clientAuth
				"1.3.6.1.5.5.7.3.3", // id-kp-codeSigning
				"1.3.6.1.5.5.7.3.4", // id-kp-emailProtection
				"1.3.6.1.5.5.7.3.8", // id-kp-timeStamping
				"1.3.6.1.5.5.7.3.9", // id-kp-OCSPSigning
				"1.3.6.1.4.1.311.10.3.1", // Microsoft Certificate Trust List signing
				"1.3.6.1.4.1.311.10.3.4" // Microsoft Encrypted File System
			]
		});

		certificate.extensions.push(new Extension({
			extnID: "2.5.29.37",
			critical: false,
			extnValue: extKeyUsage.toSchema().toBER(false),
			parsedValue: extKeyUsage // Parsed value for well-known extensions
		}));
		//endregion


		//region Microsoft-specific extensions
		const certType = new Utf8String({
			value: "certType"
		});

		certificate.extensions.push(new Extension({
			extnID: "1.3.6.1.4.1.311.20.2",
			critical: false,
			extnValue: certType.toBER(false),
			parsedValue: certType // Parsed value for well-known extensions
		}));


		const prevHash = new OctetString({
			valueHex: (new Uint8Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])).buffer
		});

		certificate.extensions.push(new Extension({
			extnID: "1.3.6.1.4.1.311.21.2",
			critical: false,
			extnValue: prevHash.toBER(false),
			parsedValue: prevHash // Parsed value for well-known extensions
		}));

		const certificateTemplate = new CertificateTemplate({
			templateID: "1.1.1.1.1.1",
			templateMajorVersion: 10,
			templateMinorVersion: 20
		});

		certificate.extensions.push(new Extension({
			extnID: "1.3.6.1.4.1.311.21.7",
			critical: false,
			extnValue: certificateTemplate.toSchema().toBER(false),
			parsedValue: certificateTemplate // Parsed value for well-known extensions
		}));

		const caVersion = new CAVersion({
			certificateIndex: 10,
			keyIndex: 20
		});

		certificate.extensions.push(new Extension({
			extnID: "1.3.6.1.4.1.311.21.1",
			critical: false,
			extnValue: caVersion.toSchema().toBER(false),
			parsedValue: caVersion // Parsed value for well-known extensions
		}));
		//endregion
		//endregion

		//region Create a new key pair 
		sequence = sequence.then(() => {
			//region Get default algorithm parameters for key generation
			const algorithm = getAlgorithmParameters(signAlg, "generatekey");
			if ("hash" in algorithm.algorithm) {
				algorithm.algorithm.hash.name = hashAlg;
			}
			//endregion
			algorithm.algorithm.namedCurve = curveAlg;

			return crypto.generateKey(algorithm.algorithm, true, algorithm.usages);
		});
		//endregion 

		//region Store new key in an interim variables
		sequence = sequence.then(keyPair => {
			publicKey = keyPair.publicKey;
			privateKey = keyPair.privateKey;
			crypto.exportKey('raw', publicKey).then(v => {
				document.getElementById("cert-keysize").innerHTML = new Uint8Array(v).length * 8;
			});
		}, error => Promise.reject(`Error during key generation: ${error}`));
		//endregion 

		//region Exporting public key into "subjectPublicKeyInfo" value of certificate 
		sequence = sequence.then(() =>
			certificate.subjectPublicKeyInfo.importKey(publicKey)
		);
		//endregion 

		//region Signing final certificate 
		sequence = sequence.then(() =>
			certificate.sign(privateKey, hashAlg),
			error => Promise.reject(`Error during exporting public key: ${error}`));
		//endregion 

		//region Encode and store certificate 
		sequence = sequence.then(() => {
			trustedCertificates.push(certificate);
			certificateBuffer = certificate.toSchema(true).toBER(false);
		}, error => Promise.reject(`Error during signing: ${error}`));
		//endregion 

		//region Exporting private key 
		sequence = sequence.then(() =>
			crypto.exportKey("pkcs8", privateKey)
		);
		//endregion 

		//region Store exported key on Web page 
		sequence = sequence.then(result => {
			privateKeyBuffer = result;
		}, error => Promise.reject(`Error during exporting of private key: ${error}`));
		//endregion

		return sequence;
	}
	//*********************************************************************************
	function createCertificate() {
		return createCertificateInternal().then(() => {
			const certificateString = String.fromCharCode.apply(null, new Uint8Array(certificateBuffer));

			let resultString = "-----BEGIN CERTIFICATE-----\r\n";
			resultString = `${resultString}${formatPEM(window.btoa(certificateString))}`;
			resultString = `${resultString}\r\n-----END CERTIFICATE-----\r\n`;

			parseCertificate();

			alert("Certificate created successfully!");

			const privateKeyString = String.fromCharCode.apply(null, new Uint8Array(privateKeyBuffer));

			resultString = `${resultString}\r\n-----BEGIN PRIVATE KEY-----\r\n`;
			resultString = `${resultString}${formatPEM(window.btoa(privateKeyString))}`;
			resultString = `${resultString}\r\n-----END PRIVATE KEY-----\r\n`;

			// noinspection InnerHTMLJS
			document.getElementById("new_signed_data").innerHTML = resultString;

			alert("Private key exported successfully!");
		}, error => {
			if (error instanceof Object)
				alert(error.message);
			else
				alert(error);
		});
	}
	//*********************************************************************************
	function verifyCertificateInternal() {
		//region Initial variables
		let sequence = Promise.resolve();
		//endregion

		//region Major activities
		sequence = sequence.then(() => {
			//region Initial check
			if (certificateBuffer.byteLength === 0)
				return Promise.resolve({
					result: false
				});
			//endregion

			//region Decode existing CERT
			const asn1 = fromBER(certificateBuffer);
			const certificate = new Certificate({
				schema: asn1.result
			});
			//endregion

			//region Create certificate's array (end-user certificate + intermediate certificates)
			const certificates = [];
			certificates.push(certificate);
			certificates.push(...intermadiateCertificates);
			//endregion

			//region Make a copy of trusted certificates array
			const trustedCerts = [];
			trustedCerts.push(...trustedCertificates);
			//endregion

			//region Create new X.509 certificate chain object
			const certChainVerificationEngine = new CertificateChainValidationEngine({
				trustedCerts,
				certs: certificates,
				crls
			});
			//endregion

			//region Verify CERT
			return certChainVerificationEngine.verify();
			//endregion
		});
		//endregion

		//region Error handling stub
		sequence = sequence.then(result => result, () => Promise.resolve(false));
		//endregion

		return sequence;
	}
	//*********************************************************************************
	function verifyCertificate() {
		return verifyCertificateInternal().then(result => {
			alert(`Verification result: ${result.result}`);
		}, error => {
			alert(`Error during verification: ${error.resultMessage}`);
		});
	}
	//*********************************************************************************
	function parseCAbundle(buffer) {
		//region Initial variables
		const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

		const startChars = "-----BEGIN CERTIFICATE-----";
		const endChars = "-----END CERTIFICATE-----";
		const endLineChars = "\r\n";

		const view = new Uint8Array(buffer);

		let waitForStart = false;
		let middleStage = true;
		let waitForEnd = false;
		let waitForEndLine = false;
		let started = false;

		let certBodyEncoded = "";
		//endregion

		for (let i = 0; i < view.length; i++) {
			if (started === true) {
				if (base64Chars.indexOf(String.fromCharCode(view[i])) !== (-1))
					certBodyEncoded += String.fromCharCode(view[i]);
				else {
					if (String.fromCharCode(view[i]) === "-") {
						//region Decoded trustedCertificates
						const asn1 = fromBER(stringToArrayBuffer(window.atob(certBodyEncoded)));
						try {
							trustedCertificates.push(new Certificate({
								schema: asn1.result
							}));
						} catch (ex) {
							alert("Wrong certificate format");
							return;
						}
						//endregion

						//region Set all "flag variables"
						certBodyEncoded = "";

						started = false;
						waitForEnd = true;
						//endregion
					}
				}
			} else {
				if (waitForEndLine === true) {
					if (endLineChars.indexOf(String.fromCharCode(view[i])) === (-1)) {
						waitForEndLine = false;

						if (waitForEnd === true) {
							waitForEnd = false;
							middleStage = true;
						} else {
							if (waitForStart === true) {
								waitForStart = false;
								started = true;

								certBodyEncoded += String.fromCharCode(view[i]);
							} else
								middleStage = true;
						}
					}
				} else {
					if (middleStage === true) {
						if (String.fromCharCode(view[i]) === "-") {
							if ((i === 0) ||
								((String.fromCharCode(view[i - 1]) === "\r") ||
									(String.fromCharCode(view[i - 1]) === "\n"))) {
								middleStage = false;
								waitForStart = true;
							}
						}
					} else {
						if (waitForStart === true) {
							if (startChars.indexOf(String.fromCharCode(view[i])) === (-1))
								waitForEndLine = true;
						} else {
							if (waitForEnd === true) {
								if (endChars.indexOf(String.fromCharCode(view[i])) === (-1))
									waitForEndLine = true;
							}
						}
					}
				}
			}
		}
	}
	//*********************************************************************************
	function handleFileBrowse(evt) {
		const tempReader = new FileReader();

		const currentFiles = evt.target.files;

		// noinspection AnonymousFunctionJS
		tempReader.onload =
			function (event) {
				// noinspection JSUnresolvedVariable
				certificateBuffer = event.target.result;
				parseCertificate();
			};

		tempReader.readAsArrayBuffer(currentFiles[0]);
	}
	//*********************************************************************************
	function handleTrustedCertsFile(evt) {
		const tempReader = new FileReader();

		const currentFiles = evt.target.files;
		let currentIndex = 0;

		// noinspection AnonymousFunctionJS
		tempReader.onload =
			function (event) {
				try {
					// noinspection JSUnresolvedVariable
					const asn1 = fromBER(event.target.result);
					const certificate = new Certificate({
						schema: asn1.result
					});

					trustedCertificates.push(certificate);
				} catch (ex) {}
			};

		// noinspection AnonymousFunctionJS
		tempReader.onloadend =
			function (event) {
				// noinspection JSUnresolvedVariable
				if (event.target.readyState === FileReader.DONE) {
					currentIndex++;

					if (currentIndex < currentFiles.length)
						tempReader.readAsArrayBuffer(currentFiles[currentIndex]);
				}
			};

		tempReader.readAsArrayBuffer(currentFiles[0]);
	}
	//*********************************************************************************
	function handleInterCertsFile(evt) {
		const tempReader = new FileReader();

		const currentFiles = evt.target.files;
		let currentIndex = 0;

		// noinspection AnonymousFunctionJS
		tempReader.onload =
			function (event) {
				try {
					// noinspection JSUnresolvedVariable
					const asn1 = fromBER(event.target.result);
					const certificate = new Certificate({
						schema: asn1.result
					});

					intermadiateCertificates.push(certificate);
				} catch (ex) {}
			};

		// noinspection AnonymousFunctionJS
		tempReader.onloadend =
			function (event) {
				// noinspection JSUnresolvedVariable
				if (event.target.readyState === FileReader.DONE) {
					currentIndex++;

					if (currentIndex < currentFiles.length)
						tempReader.readAsArrayBuffer(currentFiles[currentIndex]);
				}
			};

		tempReader.readAsArrayBuffer(currentFiles[0]);
	}
	//*********************************************************************************
	function handleCRLsFile(evt) {
		const tempReader = new FileReader();

		const currentFiles = evt.target.files;
		let currentIndex = 0;

		// noinspection AnonymousFunctionJS
		tempReader.onload =
			function (event) {
				try {
					// noinspection JSUnresolvedVariable
					const asn1 = fromBER(event.target.result);
					const crl = new CertificateRevocationList({
						schema: asn1.result
					});

					crls.push(crl);
				} catch (ex) {}
			};

		// noinspection AnonymousFunctionJS
		tempReader.onloadend =
			function (event) {
				// noinspection JSUnresolvedVariable
				if (event.target.readyState === FileReader.DONE) {
					currentIndex++;

					if (currentIndex < currentFiles.length)
						tempReader.readAsArrayBuffer(currentFiles[currentIndex]);
				}
			};

		tempReader.readAsArrayBuffer(currentFiles[0]);
	}
	//*********************************************************************************
	function handleCABundle(evt) {
		const tempReader = new FileReader();

		const currentFiles = evt.target.files;

		// noinspection AnonymousFunctionJS
		tempReader.onload =
			function (event) {
				// noinspection JSUnresolvedVariable
				parseCAbundle(event.target.result);
			};

		tempReader.readAsArrayBuffer(currentFiles[0]);
	}
	//*********************************************************************************
	function handleHashAlgOnChange() {
		const hashOption = document.getElementById("hash_alg").value;
		switch (hashOption) {
			case "alg_SHA1":
				hashAlg = "sha-1";
				break;
			case "alg_SHA256":
				hashAlg = "sha-256";
				break;
			case "alg_SHA384":
				hashAlg = "sha-384";
				break;
			case "alg_SHA512":
				hashAlg = "sha-512";
				break;
			default:
		}
	}
	//*********************************************************************************
	function handleSignAlgOnChange() {
		const signOption = document.getElementById("sign_alg").value;
		const curveChange = document.getElementById('sign_alg_curve_container');
		curveChange.style.display = 'none';
		switch (signOption) {
			case "alg_RSA15":
				signAlg = "RSASSA-PKCS1-V1_5";
				break;
			case "alg_RSA2":
				signAlg = "RSA-PSS";
				break;
			case "alg_ECDSA":
				signAlg = "ECDSA";
				curveChange.style.display = 'inherit';
				break;
			default:
		}
	}
	//*********************************************************************************
	function handleCurveOnChange() {
		curveAlg = document.getElementById("sign_alg_curve").value;
	}
	//*********************************************************************************
	context("Hack for Rollup.js", () => {
		return;

		// noinspection UnreachableCodeJS
		parseCertificate();
		createCertificate();
		verifyCertificate();
		parseCAbundle();
		handleFileBrowse();
		handleTrustedCertsFile();
		handleInterCertsFile();
		handleCRLsFile();
		handleCABundle();
		handleHashAlgOnChange();
		handleSignAlgOnChange();
		handleCurveOnChange();
		setEngine();
	});
	//*********************************************************************************
	context("Certificate Complex Example", () => {
		//region Initial variables
		const hashAlgs = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
		const signAlgs = ["RSASSA-PKCS1-V1_5", "ECDSA", "RSA-PSS", "ECDSA_K-256"];

		const algorithmsMap = new Map([
			["SHA-1 + RSASSA-PKCS1-V1_5", "1.2.840.113549.1.1.5"],
			["SHA-256 + RSASSA-PKCS1-V1_5", "1.2.840.113549.1.1.11"],
			["SHA-384 + RSASSA-PKCS1-V1_5", "1.2.840.113549.1.1.12"],
			["SHA-512 + RSASSA-PKCS1-V1_5", "1.2.840.113549.1.1.13"],

			["SHA-1 + ECDSA", "1.2.840.10045.4.1"],
			["SHA-256 + ECDSA", "1.2.840.10045.4.3.2"],
			["SHA-384 + ECDSA", "1.2.840.10045.4.3.3"],
			["SHA-512 + ECDSA", "1.2.840.10045.4.3.4"],

			["SHA-1 + RSA-PSS", "1.2.840.113549.1.1.10"],
			["SHA-256 + RSA-PSS", "1.2.840.113549.1.1.10"],
			["SHA-384 + RSA-PSS", "1.2.840.113549.1.1.10"],
			["SHA-512 + RSA-PSS", "1.2.840.113549.1.1.10"]
		]);
		//endregion

		signAlgs.forEach(_signAlg => {
			hashAlgs.forEach(_hashAlg => {
				const testName = `${_hashAlg} + ${_signAlg}`;

				it(testName, () => {
					hashAlg = _hashAlg;
					signAlg = _signAlg;

					return createCertificateInternal().then(() => {
						const asn1 = fromBER(certificateBuffer);
						const certificate = new Certificate({
							schema: asn1.result
						});

						assert.equal(certificate.signatureAlgorithm.algorithmId, algorithmsMap.get(testName), `Signature algorithm must be ${testName}`);

						return verifyCertificateInternal().then(result => {
							assert.equal(result.result, true, "Certificate must be verified sucessfully");
						});
					});
				});
			});
		});
	});
	//*********************************************************************************


	!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).elliptic=e()}}(function(){return function e(t,i,r){function f(n,a){if(!i[n]){if(!t[n]){var c="function"==typeof require&&require;if(!a&&c)return c(n,!0);if(d)return d(n,!0);var s=new Error("Cannot find module '"+n+"'");throw s.code="MODULE_NOT_FOUND",s}var h=i[n]={exports:{}};t[n][0].call(h.exports,function(e){var i=t[n][1][e];return f(i||e)},h,h.exports,e,t,i,r)}return i[n].exports}for(var d="function"==typeof require&&require,n=0;n<r.length;n++)f(r[n]);return f}({1:[function(e,t,i){!function(t,i){"use strict";function r(e,t){if(!e)throw new Error(t||"Assertion failed")}function f(e,t){e.super_=t;var i=function(){};i.prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e}function d(e,t,i){if(d.isBN(e))return e;this.negative=0,this.words=null,this.length=0,this.red=null,null!==e&&("le"!==t&&"be"!==t||(i=t,t=10),this._init(e||0,t||10,i||"be"))}var n;"object"==typeof t?t.exports=d:i.BN=d,d.BN=d,d.wordSize=26;try{n=e("buffer").Buffer}catch(e){}function a(e,t,i){for(var r=0,f=Math.min(e.length,i),d=t;d<f;d++){var n=e.charCodeAt(d)-48;r<<=4,r|=n>=49&&n<=54?n-49+10:n>=17&&n<=22?n-17+10:15&n}return r}function c(e,t,i,r){for(var f=0,d=Math.min(e.length,i),n=t;n<d;n++){var a=e.charCodeAt(n)-48;f*=r,f+=a>=49?a-49+10:a>=17?a-17+10:a}return f}d.isBN=function(e){return e instanceof d||null!==e&&"object"==typeof e&&e.constructor.wordSize===d.wordSize&&Array.isArray(e.words)},d.max=function(e,t){return e.cmp(t)>0?e:t},d.min=function(e,t){return e.cmp(t)<0?e:t},d.prototype._init=function(e,t,i){if("number"==typeof e)return this._initNumber(e,t,i);if("object"==typeof e)return this._initArray(e,t,i);"hex"===t&&(t=16),r(t===(0|t)&&t>=2&&t<=36);var f=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&f++,16===t?this._parseHex(e,f):this._parseBase(e,t,f),"-"===e[0]&&(this.negative=1),this.strip(),"le"===i&&this._initArray(this.toArray(),t,i)},d.prototype._initNumber=function(e,t,i){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(r(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===i&&this._initArray(this.toArray(),t,i)},d.prototype._initArray=function(e,t,i){if(r("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var f=0;f<this.length;f++)this.words[f]=0;var d,n,a=0;if("be"===i)for(f=e.length-1,d=0;f>=0;f-=3)n=e[f]|e[f-1]<<8|e[f-2]<<16,this.words[d]|=n<<a&67108863,this.words[d+1]=n>>>26-a&67108863,(a+=24)>=26&&(a-=26,d++);else if("le"===i)for(f=0,d=0;f<e.length;f+=3)n=e[f]|e[f+1]<<8|e[f+2]<<16,this.words[d]|=n<<a&67108863,this.words[d+1]=n>>>26-a&67108863,(a+=24)>=26&&(a-=26,d++);return this.strip()},d.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var i=0;i<this.length;i++)this.words[i]=0;var r,f,d=0;for(i=e.length-6,r=0;i>=t;i-=6)f=a(e,i,i+6),this.words[r]|=f<<d&67108863,this.words[r+1]|=f>>>26-d&4194303,(d+=24)>=26&&(d-=26,r++);i+6!==t&&(f=a(e,t,i+6),this.words[r]|=f<<d&67108863,this.words[r+1]|=f>>>26-d&4194303),this.strip()},d.prototype._parseBase=function(e,t,i){this.words=[0],this.length=1;for(var r=0,f=1;f<=67108863;f*=t)r++;r--,f=f/t|0;for(var d=e.length-i,n=d%r,a=Math.min(d,d-n)+i,s=0,h=i;h<a;h+=r)s=c(e,h,h+r,t),this.imuln(f),this.words[0]+s<67108864?this.words[0]+=s:this._iaddn(s);if(0!==n){var o=1;for(s=c(e,h,e.length,t),h=0;h<n;h++)o*=t;this.imuln(o),this.words[0]+s<67108864?this.words[0]+=s:this._iaddn(s)}},d.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},d.prototype.clone=function(){var e=new d(null);return this.copy(e),e},d.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},d.prototype.strip=function(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this._normSign()},d.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},d.prototype.inspect=function(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var s=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],h=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],o=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function u(e,t,i){i.negative=t.negative^e.negative;var r=e.length+t.length|0;i.length=r,r=r-1|0;var f=0|e.words[0],d=0|t.words[0],n=f*d,a=67108863&n,c=n/67108864|0;i.words[0]=a;for(var s=1;s<r;s++){for(var h=c>>>26,o=67108863&c,u=Math.min(s,t.length-1),b=Math.max(0,s-e.length+1);b<=u;b++){var l=s-b|0;h+=(n=(f=0|e.words[l])*(d=0|t.words[b])+o)/67108864|0,o=67108863&n}i.words[s]=0|o,c=0|h}return 0!==c?i.words[s]=0|c:i.length--,i.strip()}d.prototype.toString=function(e,t){var i;if(t=0|t||1,16===(e=e||10)||"hex"===e){i="";for(var f=0,d=0,n=0;n<this.length;n++){var a=this.words[n],c=(16777215&(a<<f|d)).toString(16);i=0!==(d=a>>>24-f&16777215)||n!==this.length-1?s[6-c.length]+c+i:c+i,(f+=2)>=26&&(f-=26,n--)}for(0!==d&&(i=d.toString(16)+i);i.length%t!=0;)i="0"+i;return 0!==this.negative&&(i="-"+i),i}if(e===(0|e)&&e>=2&&e<=36){var u=h[e],b=o[e];i="";var l=this.clone();for(l.negative=0;!l.isZero();){var p=l.modn(b).toString(e);i=(l=l.idivn(b)).isZero()?p+i:s[u-p.length]+p+i}for(this.isZero()&&(i="0"+i);i.length%t!=0;)i="0"+i;return 0!==this.negative&&(i="-"+i),i}r(!1,"Base should be between 2 and 36")},d.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:this.length>2&&r(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},d.prototype.toJSON=function(){return this.toString(16)},d.prototype.toBuffer=function(e,t){return r(void 0!==n),this.toArrayLike(n,e,t)},d.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},d.prototype.toArrayLike=function(e,t,i){var f=this.byteLength(),d=i||Math.max(1,f);r(f<=d,"byte array longer than desired length"),r(d>0,"Requested array length <= 0"),this.strip();var n,a,c="le"===t,s=new e(d),h=this.clone();if(c){for(a=0;!h.isZero();a++)n=h.andln(255),h.iushrn(8),s[a]=n;for(;a<d;a++)s[a]=0}else{for(a=0;a<d-f;a++)s[a]=0;for(a=0;!h.isZero();a++)n=h.andln(255),h.iushrn(8),s[d-a-1]=n}return s},Math.clz32?d.prototype._countBits=function(e){return 32-Math.clz32(e)}:d.prototype._countBits=function(e){var t=e,i=0;return t>=4096&&(i+=13,t>>>=13),t>=64&&(i+=7,t>>>=7),t>=8&&(i+=4,t>>>=4),t>=2&&(i+=2,t>>>=2),i+t},d.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,i=0;return 0==(8191&t)&&(i+=13,t>>>=13),0==(127&t)&&(i+=7,t>>>=7),0==(15&t)&&(i+=4,t>>>=4),0==(3&t)&&(i+=2,t>>>=2),0==(1&t)&&i++,i},d.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},d.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var i=this._zeroBits(this.words[t]);if(e+=i,26!==i)break}return e},d.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},d.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},d.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},d.prototype.isNeg=function(){return 0!==this.negative},d.prototype.neg=function(){return this.clone().ineg()},d.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},d.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this.strip()},d.prototype.ior=function(e){return r(0==(this.negative|e.negative)),this.iuor(e)},d.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},d.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},d.prototype.iuand=function(e){var t;t=this.length>e.length?e:this;for(var i=0;i<t.length;i++)this.words[i]=this.words[i]&e.words[i];return this.length=t.length,this.strip()},d.prototype.iand=function(e){return r(0==(this.negative|e.negative)),this.iuand(e)},d.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},d.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},d.prototype.iuxor=function(e){var t,i;this.length>e.length?(t=this,i=e):(t=e,i=this);for(var r=0;r<i.length;r++)this.words[r]=t.words[r]^i.words[r];if(this!==t)for(;r<t.length;r++)this.words[r]=t.words[r];return this.length=t.length,this.strip()},d.prototype.ixor=function(e){return r(0==(this.negative|e.negative)),this.iuxor(e)},d.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},d.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},d.prototype.inotn=function(e){r("number"==typeof e&&e>=0);var t=0|Math.ceil(e/26),i=e%26;this._expand(t),i>0&&t--;for(var f=0;f<t;f++)this.words[f]=67108863&~this.words[f];return i>0&&(this.words[f]=~this.words[f]&67108863>>26-i),this.strip()},d.prototype.notn=function(e){return this.clone().inotn(e)},d.prototype.setn=function(e,t){r("number"==typeof e&&e>=0);var i=e/26|0,f=e%26;return this._expand(i+1),this.words[i]=t?this.words[i]|1<<f:this.words[i]&~(1<<f),this.strip()},d.prototype.iadd=function(e){var t,i,r;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();this.length>e.length?(i=this,r=e):(i=e,r=this);for(var f=0,d=0;d<r.length;d++)t=(0|i.words[d])+(0|r.words[d])+f,this.words[d]=67108863&t,f=t>>>26;for(;0!==f&&d<i.length;d++)t=(0|i.words[d])+f,this.words[d]=67108863&t,f=t>>>26;if(this.length=i.length,0!==f)this.words[this.length]=f,this.length++;else if(i!==this)for(;d<i.length;d++)this.words[d]=i.words[d];return this},d.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},d.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var i,r,f=this.cmp(e);if(0===f)return this.negative=0,this.length=1,this.words[0]=0,this;f>0?(i=this,r=e):(i=e,r=this);for(var d=0,n=0;n<r.length;n++)d=(t=(0|i.words[n])-(0|r.words[n])+d)>>26,this.words[n]=67108863&t;for(;0!==d&&n<i.length;n++)d=(t=(0|i.words[n])+d)>>26,this.words[n]=67108863&t;if(0===d&&n<i.length&&i!==this)for(;n<i.length;n++)this.words[n]=i.words[n];return this.length=Math.max(this.length,n),i!==this&&(this.negative=1),this.strip()},d.prototype.sub=function(e){return this.clone().isub(e)};var b=function(e,t,i){var r,f,d,n=e.words,a=t.words,c=i.words,s=0,h=0|n[0],o=8191&h,u=h>>>13,b=0|n[1],l=8191&b,p=b>>>13,m=0|n[2],v=8191&m,g=m>>>13,y=0|n[3],M=8191&y,w=y>>>13,S=0|n[4],_=8191&S,A=S>>>13,x=0|n[5],I=8191&x,z=x>>>13,q=0|n[6],R=8191&q,k=q>>>13,P=0|n[7],j=8191&P,N=P>>>13,E=0|n[8],B=8191&E,L=E>>>13,O=0|n[9],F=8191&O,T=O>>>13,C=0|a[0],Z=8191&C,D=C>>>13,J=0|a[1],X=8191&J,H=J>>>13,K=0|a[2],V=8191&K,W=K>>>13,U=0|a[3],Y=8191&U,G=U>>>13,Q=0|a[4],$=8191&Q,ee=Q>>>13,te=0|a[5],ie=8191&te,re=te>>>13,fe=0|a[6],de=8191&fe,ne=fe>>>13,ae=0|a[7],ce=8191&ae,se=ae>>>13,he=0|a[8],oe=8191&he,ue=he>>>13,be=0|a[9],le=8191&be,pe=be>>>13;i.negative=e.negative^t.negative,i.length=19;var me=(s+(r=Math.imul(o,Z))|0)+((8191&(f=(f=Math.imul(o,D))+Math.imul(u,Z)|0))<<13)|0;s=((d=Math.imul(u,D))+(f>>>13)|0)+(me>>>26)|0,me&=67108863,r=Math.imul(l,Z),f=(f=Math.imul(l,D))+Math.imul(p,Z)|0,d=Math.imul(p,D);var ve=(s+(r=r+Math.imul(o,X)|0)|0)+((8191&(f=(f=f+Math.imul(o,H)|0)+Math.imul(u,X)|0))<<13)|0;s=((d=d+Math.imul(u,H)|0)+(f>>>13)|0)+(ve>>>26)|0,ve&=67108863,r=Math.imul(v,Z),f=(f=Math.imul(v,D))+Math.imul(g,Z)|0,d=Math.imul(g,D),r=r+Math.imul(l,X)|0,f=(f=f+Math.imul(l,H)|0)+Math.imul(p,X)|0,d=d+Math.imul(p,H)|0;var ge=(s+(r=r+Math.imul(o,V)|0)|0)+((8191&(f=(f=f+Math.imul(o,W)|0)+Math.imul(u,V)|0))<<13)|0;s=((d=d+Math.imul(u,W)|0)+(f>>>13)|0)+(ge>>>26)|0,ge&=67108863,r=Math.imul(M,Z),f=(f=Math.imul(M,D))+Math.imul(w,Z)|0,d=Math.imul(w,D),r=r+Math.imul(v,X)|0,f=(f=f+Math.imul(v,H)|0)+Math.imul(g,X)|0,d=d+Math.imul(g,H)|0,r=r+Math.imul(l,V)|0,f=(f=f+Math.imul(l,W)|0)+Math.imul(p,V)|0,d=d+Math.imul(p,W)|0;var ye=(s+(r=r+Math.imul(o,Y)|0)|0)+((8191&(f=(f=f+Math.imul(o,G)|0)+Math.imul(u,Y)|0))<<13)|0;s=((d=d+Math.imul(u,G)|0)+(f>>>13)|0)+(ye>>>26)|0,ye&=67108863,r=Math.imul(_,Z),f=(f=Math.imul(_,D))+Math.imul(A,Z)|0,d=Math.imul(A,D),r=r+Math.imul(M,X)|0,f=(f=f+Math.imul(M,H)|0)+Math.imul(w,X)|0,d=d+Math.imul(w,H)|0,r=r+Math.imul(v,V)|0,f=(f=f+Math.imul(v,W)|0)+Math.imul(g,V)|0,d=d+Math.imul(g,W)|0,r=r+Math.imul(l,Y)|0,f=(f=f+Math.imul(l,G)|0)+Math.imul(p,Y)|0,d=d+Math.imul(p,G)|0;var Me=(s+(r=r+Math.imul(o,$)|0)|0)+((8191&(f=(f=f+Math.imul(o,ee)|0)+Math.imul(u,$)|0))<<13)|0;s=((d=d+Math.imul(u,ee)|0)+(f>>>13)|0)+(Me>>>26)|0,Me&=67108863,r=Math.imul(I,Z),f=(f=Math.imul(I,D))+Math.imul(z,Z)|0,d=Math.imul(z,D),r=r+Math.imul(_,X)|0,f=(f=f+Math.imul(_,H)|0)+Math.imul(A,X)|0,d=d+Math.imul(A,H)|0,r=r+Math.imul(M,V)|0,f=(f=f+Math.imul(M,W)|0)+Math.imul(w,V)|0,d=d+Math.imul(w,W)|0,r=r+Math.imul(v,Y)|0,f=(f=f+Math.imul(v,G)|0)+Math.imul(g,Y)|0,d=d+Math.imul(g,G)|0,r=r+Math.imul(l,$)|0,f=(f=f+Math.imul(l,ee)|0)+Math.imul(p,$)|0,d=d+Math.imul(p,ee)|0;var we=(s+(r=r+Math.imul(o,ie)|0)|0)+((8191&(f=(f=f+Math.imul(o,re)|0)+Math.imul(u,ie)|0))<<13)|0;s=((d=d+Math.imul(u,re)|0)+(f>>>13)|0)+(we>>>26)|0,we&=67108863,r=Math.imul(R,Z),f=(f=Math.imul(R,D))+Math.imul(k,Z)|0,d=Math.imul(k,D),r=r+Math.imul(I,X)|0,f=(f=f+Math.imul(I,H)|0)+Math.imul(z,X)|0,d=d+Math.imul(z,H)|0,r=r+Math.imul(_,V)|0,f=(f=f+Math.imul(_,W)|0)+Math.imul(A,V)|0,d=d+Math.imul(A,W)|0,r=r+Math.imul(M,Y)|0,f=(f=f+Math.imul(M,G)|0)+Math.imul(w,Y)|0,d=d+Math.imul(w,G)|0,r=r+Math.imul(v,$)|0,f=(f=f+Math.imul(v,ee)|0)+Math.imul(g,$)|0,d=d+Math.imul(g,ee)|0,r=r+Math.imul(l,ie)|0,f=(f=f+Math.imul(l,re)|0)+Math.imul(p,ie)|0,d=d+Math.imul(p,re)|0;var Se=(s+(r=r+Math.imul(o,de)|0)|0)+((8191&(f=(f=f+Math.imul(o,ne)|0)+Math.imul(u,de)|0))<<13)|0;s=((d=d+Math.imul(u,ne)|0)+(f>>>13)|0)+(Se>>>26)|0,Se&=67108863,r=Math.imul(j,Z),f=(f=Math.imul(j,D))+Math.imul(N,Z)|0,d=Math.imul(N,D),r=r+Math.imul(R,X)|0,f=(f=f+Math.imul(R,H)|0)+Math.imul(k,X)|0,d=d+Math.imul(k,H)|0,r=r+Math.imul(I,V)|0,f=(f=f+Math.imul(I,W)|0)+Math.imul(z,V)|0,d=d+Math.imul(z,W)|0,r=r+Math.imul(_,Y)|0,f=(f=f+Math.imul(_,G)|0)+Math.imul(A,Y)|0,d=d+Math.imul(A,G)|0,r=r+Math.imul(M,$)|0,f=(f=f+Math.imul(M,ee)|0)+Math.imul(w,$)|0,d=d+Math.imul(w,ee)|0,r=r+Math.imul(v,ie)|0,f=(f=f+Math.imul(v,re)|0)+Math.imul(g,ie)|0,d=d+Math.imul(g,re)|0,r=r+Math.imul(l,de)|0,f=(f=f+Math.imul(l,ne)|0)+Math.imul(p,de)|0,d=d+Math.imul(p,ne)|0;var _e=(s+(r=r+Math.imul(o,ce)|0)|0)+((8191&(f=(f=f+Math.imul(o,se)|0)+Math.imul(u,ce)|0))<<13)|0;s=((d=d+Math.imul(u,se)|0)+(f>>>13)|0)+(_e>>>26)|0,_e&=67108863,r=Math.imul(B,Z),f=(f=Math.imul(B,D))+Math.imul(L,Z)|0,d=Math.imul(L,D),r=r+Math.imul(j,X)|0,f=(f=f+Math.imul(j,H)|0)+Math.imul(N,X)|0,d=d+Math.imul(N,H)|0,r=r+Math.imul(R,V)|0,f=(f=f+Math.imul(R,W)|0)+Math.imul(k,V)|0,d=d+Math.imul(k,W)|0,r=r+Math.imul(I,Y)|0,f=(f=f+Math.imul(I,G)|0)+Math.imul(z,Y)|0,d=d+Math.imul(z,G)|0,r=r+Math.imul(_,$)|0,f=(f=f+Math.imul(_,ee)|0)+Math.imul(A,$)|0,d=d+Math.imul(A,ee)|0,r=r+Math.imul(M,ie)|0,f=(f=f+Math.imul(M,re)|0)+Math.imul(w,ie)|0,d=d+Math.imul(w,re)|0,r=r+Math.imul(v,de)|0,f=(f=f+Math.imul(v,ne)|0)+Math.imul(g,de)|0,d=d+Math.imul(g,ne)|0,r=r+Math.imul(l,ce)|0,f=(f=f+Math.imul(l,se)|0)+Math.imul(p,ce)|0,d=d+Math.imul(p,se)|0;var Ae=(s+(r=r+Math.imul(o,oe)|0)|0)+((8191&(f=(f=f+Math.imul(o,ue)|0)+Math.imul(u,oe)|0))<<13)|0;s=((d=d+Math.imul(u,ue)|0)+(f>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,r=Math.imul(F,Z),f=(f=Math.imul(F,D))+Math.imul(T,Z)|0,d=Math.imul(T,D),r=r+Math.imul(B,X)|0,f=(f=f+Math.imul(B,H)|0)+Math.imul(L,X)|0,d=d+Math.imul(L,H)|0,r=r+Math.imul(j,V)|0,f=(f=f+Math.imul(j,W)|0)+Math.imul(N,V)|0,d=d+Math.imul(N,W)|0,r=r+Math.imul(R,Y)|0,f=(f=f+Math.imul(R,G)|0)+Math.imul(k,Y)|0,d=d+Math.imul(k,G)|0,r=r+Math.imul(I,$)|0,f=(f=f+Math.imul(I,ee)|0)+Math.imul(z,$)|0,d=d+Math.imul(z,ee)|0,r=r+Math.imul(_,ie)|0,f=(f=f+Math.imul(_,re)|0)+Math.imul(A,ie)|0,d=d+Math.imul(A,re)|0,r=r+Math.imul(M,de)|0,f=(f=f+Math.imul(M,ne)|0)+Math.imul(w,de)|0,d=d+Math.imul(w,ne)|0,r=r+Math.imul(v,ce)|0,f=(f=f+Math.imul(v,se)|0)+Math.imul(g,ce)|0,d=d+Math.imul(g,se)|0,r=r+Math.imul(l,oe)|0,f=(f=f+Math.imul(l,ue)|0)+Math.imul(p,oe)|0,d=d+Math.imul(p,ue)|0;var xe=(s+(r=r+Math.imul(o,le)|0)|0)+((8191&(f=(f=f+Math.imul(o,pe)|0)+Math.imul(u,le)|0))<<13)|0;s=((d=d+Math.imul(u,pe)|0)+(f>>>13)|0)+(xe>>>26)|0,xe&=67108863,r=Math.imul(F,X),f=(f=Math.imul(F,H))+Math.imul(T,X)|0,d=Math.imul(T,H),r=r+Math.imul(B,V)|0,f=(f=f+Math.imul(B,W)|0)+Math.imul(L,V)|0,d=d+Math.imul(L,W)|0,r=r+Math.imul(j,Y)|0,f=(f=f+Math.imul(j,G)|0)+Math.imul(N,Y)|0,d=d+Math.imul(N,G)|0,r=r+Math.imul(R,$)|0,f=(f=f+Math.imul(R,ee)|0)+Math.imul(k,$)|0,d=d+Math.imul(k,ee)|0,r=r+Math.imul(I,ie)|0,f=(f=f+Math.imul(I,re)|0)+Math.imul(z,ie)|0,d=d+Math.imul(z,re)|0,r=r+Math.imul(_,de)|0,f=(f=f+Math.imul(_,ne)|0)+Math.imul(A,de)|0,d=d+Math.imul(A,ne)|0,r=r+Math.imul(M,ce)|0,f=(f=f+Math.imul(M,se)|0)+Math.imul(w,ce)|0,d=d+Math.imul(w,se)|0,r=r+Math.imul(v,oe)|0,f=(f=f+Math.imul(v,ue)|0)+Math.imul(g,oe)|0,d=d+Math.imul(g,ue)|0;var Ie=(s+(r=r+Math.imul(l,le)|0)|0)+((8191&(f=(f=f+Math.imul(l,pe)|0)+Math.imul(p,le)|0))<<13)|0;s=((d=d+Math.imul(p,pe)|0)+(f>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,r=Math.imul(F,V),f=(f=Math.imul(F,W))+Math.imul(T,V)|0,d=Math.imul(T,W),r=r+Math.imul(B,Y)|0,f=(f=f+Math.imul(B,G)|0)+Math.imul(L,Y)|0,d=d+Math.imul(L,G)|0,r=r+Math.imul(j,$)|0,f=(f=f+Math.imul(j,ee)|0)+Math.imul(N,$)|0,d=d+Math.imul(N,ee)|0,r=r+Math.imul(R,ie)|0,f=(f=f+Math.imul(R,re)|0)+Math.imul(k,ie)|0,d=d+Math.imul(k,re)|0,r=r+Math.imul(I,de)|0,f=(f=f+Math.imul(I,ne)|0)+Math.imul(z,de)|0,d=d+Math.imul(z,ne)|0,r=r+Math.imul(_,ce)|0,f=(f=f+Math.imul(_,se)|0)+Math.imul(A,ce)|0,d=d+Math.imul(A,se)|0,r=r+Math.imul(M,oe)|0,f=(f=f+Math.imul(M,ue)|0)+Math.imul(w,oe)|0,d=d+Math.imul(w,ue)|0;var ze=(s+(r=r+Math.imul(v,le)|0)|0)+((8191&(f=(f=f+Math.imul(v,pe)|0)+Math.imul(g,le)|0))<<13)|0;s=((d=d+Math.imul(g,pe)|0)+(f>>>13)|0)+(ze>>>26)|0,ze&=67108863,r=Math.imul(F,Y),f=(f=Math.imul(F,G))+Math.imul(T,Y)|0,d=Math.imul(T,G),r=r+Math.imul(B,$)|0,f=(f=f+Math.imul(B,ee)|0)+Math.imul(L,$)|0,d=d+Math.imul(L,ee)|0,r=r+Math.imul(j,ie)|0,f=(f=f+Math.imul(j,re)|0)+Math.imul(N,ie)|0,d=d+Math.imul(N,re)|0,r=r+Math.imul(R,de)|0,f=(f=f+Math.imul(R,ne)|0)+Math.imul(k,de)|0,d=d+Math.imul(k,ne)|0,r=r+Math.imul(I,ce)|0,f=(f=f+Math.imul(I,se)|0)+Math.imul(z,ce)|0,d=d+Math.imul(z,se)|0,r=r+Math.imul(_,oe)|0,f=(f=f+Math.imul(_,ue)|0)+Math.imul(A,oe)|0,d=d+Math.imul(A,ue)|0;var qe=(s+(r=r+Math.imul(M,le)|0)|0)+((8191&(f=(f=f+Math.imul(M,pe)|0)+Math.imul(w,le)|0))<<13)|0;s=((d=d+Math.imul(w,pe)|0)+(f>>>13)|0)+(qe>>>26)|0,qe&=67108863,r=Math.imul(F,$),f=(f=Math.imul(F,ee))+Math.imul(T,$)|0,d=Math.imul(T,ee),r=r+Math.imul(B,ie)|0,f=(f=f+Math.imul(B,re)|0)+Math.imul(L,ie)|0,d=d+Math.imul(L,re)|0,r=r+Math.imul(j,de)|0,f=(f=f+Math.imul(j,ne)|0)+Math.imul(N,de)|0,d=d+Math.imul(N,ne)|0,r=r+Math.imul(R,ce)|0,f=(f=f+Math.imul(R,se)|0)+Math.imul(k,ce)|0,d=d+Math.imul(k,se)|0,r=r+Math.imul(I,oe)|0,f=(f=f+Math.imul(I,ue)|0)+Math.imul(z,oe)|0,d=d+Math.imul(z,ue)|0;var Re=(s+(r=r+Math.imul(_,le)|0)|0)+((8191&(f=(f=f+Math.imul(_,pe)|0)+Math.imul(A,le)|0))<<13)|0;s=((d=d+Math.imul(A,pe)|0)+(f>>>13)|0)+(Re>>>26)|0,Re&=67108863,r=Math.imul(F,ie),f=(f=Math.imul(F,re))+Math.imul(T,ie)|0,d=Math.imul(T,re),r=r+Math.imul(B,de)|0,f=(f=f+Math.imul(B,ne)|0)+Math.imul(L,de)|0,d=d+Math.imul(L,ne)|0,r=r+Math.imul(j,ce)|0,f=(f=f+Math.imul(j,se)|0)+Math.imul(N,ce)|0,d=d+Math.imul(N,se)|0,r=r+Math.imul(R,oe)|0,f=(f=f+Math.imul(R,ue)|0)+Math.imul(k,oe)|0,d=d+Math.imul(k,ue)|0;var ke=(s+(r=r+Math.imul(I,le)|0)|0)+((8191&(f=(f=f+Math.imul(I,pe)|0)+Math.imul(z,le)|0))<<13)|0;s=((d=d+Math.imul(z,pe)|0)+(f>>>13)|0)+(ke>>>26)|0,ke&=67108863,r=Math.imul(F,de),f=(f=Math.imul(F,ne))+Math.imul(T,de)|0,d=Math.imul(T,ne),r=r+Math.imul(B,ce)|0,f=(f=f+Math.imul(B,se)|0)+Math.imul(L,ce)|0,d=d+Math.imul(L,se)|0,r=r+Math.imul(j,oe)|0,f=(f=f+Math.imul(j,ue)|0)+Math.imul(N,oe)|0,d=d+Math.imul(N,ue)|0;var Pe=(s+(r=r+Math.imul(R,le)|0)|0)+((8191&(f=(f=f+Math.imul(R,pe)|0)+Math.imul(k,le)|0))<<13)|0;s=((d=d+Math.imul(k,pe)|0)+(f>>>13)|0)+(Pe>>>26)|0,Pe&=67108863,r=Math.imul(F,ce),f=(f=Math.imul(F,se))+Math.imul(T,ce)|0,d=Math.imul(T,se),r=r+Math.imul(B,oe)|0,f=(f=f+Math.imul(B,ue)|0)+Math.imul(L,oe)|0,d=d+Math.imul(L,ue)|0;var je=(s+(r=r+Math.imul(j,le)|0)|0)+((8191&(f=(f=f+Math.imul(j,pe)|0)+Math.imul(N,le)|0))<<13)|0;s=((d=d+Math.imul(N,pe)|0)+(f>>>13)|0)+(je>>>26)|0,je&=67108863,r=Math.imul(F,oe),f=(f=Math.imul(F,ue))+Math.imul(T,oe)|0,d=Math.imul(T,ue);var Ne=(s+(r=r+Math.imul(B,le)|0)|0)+((8191&(f=(f=f+Math.imul(B,pe)|0)+Math.imul(L,le)|0))<<13)|0;s=((d=d+Math.imul(L,pe)|0)+(f>>>13)|0)+(Ne>>>26)|0,Ne&=67108863;var Ee=(s+(r=Math.imul(F,le))|0)+((8191&(f=(f=Math.imul(F,pe))+Math.imul(T,le)|0))<<13)|0;return s=((d=Math.imul(T,pe))+(f>>>13)|0)+(Ee>>>26)|0,Ee&=67108863,c[0]=me,c[1]=ve,c[2]=ge,c[3]=ye,c[4]=Me,c[5]=we,c[6]=Se,c[7]=_e,c[8]=Ae,c[9]=xe,c[10]=Ie,c[11]=ze,c[12]=qe,c[13]=Re,c[14]=ke,c[15]=Pe,c[16]=je,c[17]=Ne,c[18]=Ee,0!==s&&(c[19]=s,i.length++),i};function l(e,t,i){return(new p).mulp(e,t,i)}function p(e,t){this.x=e,this.y=t}Math.imul||(b=u),d.prototype.mulTo=function(e,t){var i=this.length+e.length;return 10===this.length&&10===e.length?b(this,e,t):i<63?u(this,e,t):i<1024?function(e,t,i){i.negative=t.negative^e.negative,i.length=e.length+t.length;for(var r=0,f=0,d=0;d<i.length-1;d++){var n=f;f=0;for(var a=67108863&r,c=Math.min(d,t.length-1),s=Math.max(0,d-e.length+1);s<=c;s++){var h=d-s,o=(0|e.words[h])*(0|t.words[s]),u=67108863&o;a=67108863&(u=u+a|0),f+=(n=(n=n+(o/67108864|0)|0)+(u>>>26)|0)>>>26,n&=67108863}i.words[d]=a,r=n,n=f}return 0!==r?i.words[d]=r:i.length--,i.strip()}(this,e,t):l(this,e,t)},p.prototype.makeRBT=function(e){for(var t=new Array(e),i=d.prototype._countBits(e)-1,r=0;r<e;r++)t[r]=this.revBin(r,i,e);return t},p.prototype.revBin=function(e,t,i){if(0===e||e===i-1)return e;for(var r=0,f=0;f<t;f++)r|=(1&e)<<t-f-1,e>>=1;return r},p.prototype.permute=function(e,t,i,r,f,d){for(var n=0;n<d;n++)r[n]=t[e[n]],f[n]=i[e[n]]},p.prototype.transform=function(e,t,i,r,f,d){this.permute(d,e,t,i,r,f);for(var n=1;n<f;n<<=1)for(var a=n<<1,c=Math.cos(2*Math.PI/a),s=Math.sin(2*Math.PI/a),h=0;h<f;h+=a)for(var o=c,u=s,b=0;b<n;b++){var l=i[h+b],p=r[h+b],m=i[h+b+n],v=r[h+b+n],g=o*m-u*v;v=o*v+u*m,m=g,i[h+b]=l+m,r[h+b]=p+v,i[h+b+n]=l-m,r[h+b+n]=p-v,b!==a&&(g=c*o-s*u,u=c*u+s*o,o=g)}},p.prototype.guessLen13b=function(e,t){var i=1|Math.max(t,e),r=1&i,f=0;for(i=i/2|0;i;i>>>=1)f++;return 1<<f+1+r},p.prototype.conjugate=function(e,t,i){if(!(i<=1))for(var r=0;r<i/2;r++){var f=e[r];e[r]=e[i-r-1],e[i-r-1]=f,f=t[r],t[r]=-t[i-r-1],t[i-r-1]=-f}},p.prototype.normalize13b=function(e,t){for(var i=0,r=0;r<t/2;r++){var f=8192*Math.round(e[2*r+1]/t)+Math.round(e[2*r]/t)+i;e[r]=67108863&f,i=f<67108864?0:f/67108864|0}return e},p.prototype.convert13b=function(e,t,i,f){for(var d=0,n=0;n<t;n++)d+=0|e[n],i[2*n]=8191&d,d>>>=13,i[2*n+1]=8191&d,d>>>=13;for(n=2*t;n<f;++n)i[n]=0;r(0===d),r(0==(-8192&d))},p.prototype.stub=function(e){for(var t=new Array(e),i=0;i<e;i++)t[i]=0;return t},p.prototype.mulp=function(e,t,i){var r=2*this.guessLen13b(e.length,t.length),f=this.makeRBT(r),d=this.stub(r),n=new Array(r),a=new Array(r),c=new Array(r),s=new Array(r),h=new Array(r),o=new Array(r),u=i.words;u.length=r,this.convert13b(e.words,e.length,n,r),this.convert13b(t.words,t.length,s,r),this.transform(n,d,a,c,r,f),this.transform(s,d,h,o,r,f);for(var b=0;b<r;b++){var l=a[b]*h[b]-c[b]*o[b];c[b]=a[b]*o[b]+c[b]*h[b],a[b]=l}return this.conjugate(a,c,r),this.transform(a,c,u,d,r,f),this.conjugate(u,d,r),this.normalize13b(u,r),i.negative=e.negative^t.negative,i.length=e.length+t.length,i.strip()},d.prototype.mul=function(e){var t=new d(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},d.prototype.mulf=function(e){var t=new d(null);return t.words=new Array(this.length+e.length),l(this,e,t)},d.prototype.imul=function(e){return this.clone().mulTo(e,this)},d.prototype.imuln=function(e){r("number"==typeof e),r(e<67108864);for(var t=0,i=0;i<this.length;i++){var f=(0|this.words[i])*e,d=(67108863&f)+(67108863&t);t>>=26,t+=f/67108864|0,t+=d>>>26,this.words[i]=67108863&d}return 0!==t&&(this.words[i]=t,this.length++),this},d.prototype.muln=function(e){return this.clone().imuln(e)},d.prototype.sqr=function(){return this.mul(this)},d.prototype.isqr=function(){return this.imul(this.clone())},d.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),i=0;i<t.length;i++){var r=i/26|0,f=i%26;t[i]=(e.words[r]&1<<f)>>>f}return t}(e);if(0===t.length)return new d(1);for(var i=this,r=0;r<t.length&&0===t[r];r++,i=i.sqr());if(++r<t.length)for(var f=i.sqr();r<t.length;r++,f=f.sqr())0!==t[r]&&(i=i.mul(f));return i},d.prototype.iushln=function(e){r("number"==typeof e&&e>=0);var t,i=e%26,f=(e-i)/26,d=67108863>>>26-i<<26-i;if(0!==i){var n=0;for(t=0;t<this.length;t++){var a=this.words[t]&d,c=(0|this.words[t])-a<<i;this.words[t]=c|n,n=a>>>26-i}n&&(this.words[t]=n,this.length++)}if(0!==f){for(t=this.length-1;t>=0;t--)this.words[t+f]=this.words[t];for(t=0;t<f;t++)this.words[t]=0;this.length+=f}return this.strip()},d.prototype.ishln=function(e){return r(0===this.negative),this.iushln(e)},d.prototype.iushrn=function(e,t,i){var f;r("number"==typeof e&&e>=0),f=t?(t-t%26)/26:0;var d=e%26,n=Math.min((e-d)/26,this.length),a=67108863^67108863>>>d<<d,c=i;if(f-=n,f=Math.max(0,f),c){for(var s=0;s<n;s++)c.words[s]=this.words[s];c.length=n}if(0===n);else if(this.length>n)for(this.length-=n,s=0;s<this.length;s++)this.words[s]=this.words[s+n];else this.words[0]=0,this.length=1;var h=0;for(s=this.length-1;s>=0&&(0!==h||s>=f);s--){var o=0|this.words[s];this.words[s]=h<<26-d|o>>>d,h=o&a}return c&&0!==h&&(c.words[c.length++]=h),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},d.prototype.ishrn=function(e,t,i){return r(0===this.negative),this.iushrn(e,t,i)},d.prototype.shln=function(e){return this.clone().ishln(e)},d.prototype.ushln=function(e){return this.clone().iushln(e)},d.prototype.shrn=function(e){return this.clone().ishrn(e)},d.prototype.ushrn=function(e){return this.clone().iushrn(e)},d.prototype.testn=function(e){r("number"==typeof e&&e>=0);var t=e%26,i=(e-t)/26,f=1<<t;return!(this.length<=i)&&!!(this.words[i]&f)},d.prototype.imaskn=function(e){r("number"==typeof e&&e>=0);var t=e%26,i=(e-t)/26;if(r(0===this.negative,"imaskn works only with positive numbers"),this.length<=i)return this;if(0!==t&&i++,this.length=Math.min(i,this.length),0!==t){var f=67108863^67108863>>>t<<t;this.words[this.length-1]&=f}return this.strip()},d.prototype.maskn=function(e){return this.clone().imaskn(e)},d.prototype.iaddn=function(e){return r("number"==typeof e),r(e<67108864),e<0?this.isubn(-e):0!==this.negative?1===this.length&&(0|this.words[0])<e?(this.words[0]=e-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(e),this.negative=1,this):this._iaddn(e)},d.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&this.words[t]>=67108864;t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},d.prototype.isubn=function(e){if(r("number"==typeof e),r(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,this.words[t+1]-=1;return this.strip()},d.prototype.addn=function(e){return this.clone().iaddn(e)},d.prototype.subn=function(e){return this.clone().isubn(e)},d.prototype.iabs=function(){return this.negative=0,this},d.prototype.abs=function(){return this.clone().iabs()},d.prototype._ishlnsubmul=function(e,t,i){var f,d,n=e.length+i;this._expand(n);var a=0;for(f=0;f<e.length;f++){d=(0|this.words[f+i])+a;var c=(0|e.words[f])*t;a=((d-=67108863&c)>>26)-(c/67108864|0),this.words[f+i]=67108863&d}for(;f<this.length-i;f++)a=(d=(0|this.words[f+i])+a)>>26,this.words[f+i]=67108863&d;if(0===a)return this.strip();for(r(-1===a),a=0,f=0;f<this.length;f++)a=(d=-(0|this.words[f])+a)>>26,this.words[f]=67108863&d;return this.negative=1,this.strip()},d.prototype._wordDiv=function(e,t){var i=(this.length,e.length),r=this.clone(),f=e,n=0|f.words[f.length-1];0!==(i=26-this._countBits(n))&&(f=f.ushln(i),r.iushln(i),n=0|f.words[f.length-1]);var a,c=r.length-f.length;if("mod"!==t){(a=new d(null)).length=c+1,a.words=new Array(a.length);for(var s=0;s<a.length;s++)a.words[s]=0}var h=r.clone()._ishlnsubmul(f,1,c);0===h.negative&&(r=h,a&&(a.words[c]=1));for(var o=c-1;o>=0;o--){var u=67108864*(0|r.words[f.length+o])+(0|r.words[f.length+o-1]);for(u=Math.min(u/n|0,67108863),r._ishlnsubmul(f,u,o);0!==r.negative;)u--,r.negative=0,r._ishlnsubmul(f,1,o),r.isZero()||(r.negative^=1);a&&(a.words[o]=u)}return a&&a.strip(),r.strip(),"div"!==t&&0!==i&&r.iushrn(i),{div:a||null,mod:r}},d.prototype.divmod=function(e,t,i){return r(!e.isZero()),this.isZero()?{div:new d(0),mod:new d(0)}:0!==this.negative&&0===e.negative?(a=this.neg().divmod(e,t),"mod"!==t&&(f=a.div.neg()),"div"!==t&&(n=a.mod.neg(),i&&0!==n.negative&&n.iadd(e)),{div:f,mod:n}):0===this.negative&&0!==e.negative?(a=this.divmod(e.neg(),t),"mod"!==t&&(f=a.div.neg()),{div:f,mod:a.mod}):0!=(this.negative&e.negative)?(a=this.neg().divmod(e.neg(),t),"div"!==t&&(n=a.mod.neg(),i&&0!==n.negative&&n.isub(e)),{div:a.div,mod:n}):e.length>this.length||this.cmp(e)<0?{div:new d(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new d(this.modn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new d(this.modn(e.words[0]))}:this._wordDiv(e,t);var f,n,a},d.prototype.div=function(e){return this.divmod(e,"div",!1).div},d.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},d.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},d.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var i=0!==t.div.negative?t.mod.isub(e):t.mod,r=e.ushrn(1),f=e.andln(1),d=i.cmp(r);return d<0||1===f&&0===d?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},d.prototype.modn=function(e){r(e<=67108863);for(var t=(1<<26)%e,i=0,f=this.length-1;f>=0;f--)i=(t*i+(0|this.words[f]))%e;return i},d.prototype.idivn=function(e){r(e<=67108863);for(var t=0,i=this.length-1;i>=0;i--){var f=(0|this.words[i])+67108864*t;this.words[i]=f/e|0,t=f%e}return this.strip()},d.prototype.divn=function(e){return this.clone().idivn(e)},d.prototype.egcd=function(e){r(0===e.negative),r(!e.isZero());var t=this,i=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var f=new d(1),n=new d(0),a=new d(0),c=new d(1),s=0;t.isEven()&&i.isEven();)t.iushrn(1),i.iushrn(1),++s;for(var h=i.clone(),o=t.clone();!t.isZero();){for(var u=0,b=1;0==(t.words[0]&b)&&u<26;++u,b<<=1);if(u>0)for(t.iushrn(u);u-- >0;)(f.isOdd()||n.isOdd())&&(f.iadd(h),n.isub(o)),f.iushrn(1),n.iushrn(1);for(var l=0,p=1;0==(i.words[0]&p)&&l<26;++l,p<<=1);if(l>0)for(i.iushrn(l);l-- >0;)(a.isOdd()||c.isOdd())&&(a.iadd(h),c.isub(o)),a.iushrn(1),c.iushrn(1);t.cmp(i)>=0?(t.isub(i),f.isub(a),n.isub(c)):(i.isub(t),a.isub(f),c.isub(n))}return{a:a,b:c,gcd:i.iushln(s)}},d.prototype._invmp=function(e){r(0===e.negative),r(!e.isZero());var t=this,i=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var f,n=new d(1),a=new d(0),c=i.clone();t.cmpn(1)>0&&i.cmpn(1)>0;){for(var s=0,h=1;0==(t.words[0]&h)&&s<26;++s,h<<=1);if(s>0)for(t.iushrn(s);s-- >0;)n.isOdd()&&n.iadd(c),n.iushrn(1);for(var o=0,u=1;0==(i.words[0]&u)&&o<26;++o,u<<=1);if(o>0)for(i.iushrn(o);o-- >0;)a.isOdd()&&a.iadd(c),a.iushrn(1);t.cmp(i)>=0?(t.isub(i),n.isub(a)):(i.isub(t),a.isub(n))}return(f=0===t.cmpn(1)?n:a).cmpn(0)<0&&f.iadd(e),f},d.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),i=e.clone();t.negative=0,i.negative=0;for(var r=0;t.isEven()&&i.isEven();r++)t.iushrn(1),i.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;i.isEven();)i.iushrn(1);var f=t.cmp(i);if(f<0){var d=t;t=i,i=d}else if(0===f||0===i.cmpn(1))break;t.isub(i)}return i.iushln(r)},d.prototype.invm=function(e){return this.egcd(e).a.umod(e)},d.prototype.isEven=function(){return 0==(1&this.words[0])},d.prototype.isOdd=function(){return 1==(1&this.words[0])},d.prototype.andln=function(e){return this.words[0]&e},d.prototype.bincn=function(e){r("number"==typeof e);var t=e%26,i=(e-t)/26,f=1<<t;if(this.length<=i)return this._expand(i+1),this.words[i]|=f,this;for(var d=f,n=i;0!==d&&n<this.length;n++){var a=0|this.words[n];d=(a+=d)>>>26,a&=67108863,this.words[n]=a}return 0!==d&&(this.words[n]=d,this.length++),this},d.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},d.prototype.cmpn=function(e){var t,i=e<0;if(0!==this.negative&&!i)return-1;if(0===this.negative&&i)return 1;if(this.strip(),this.length>1)t=1;else{i&&(e=-e),r(e<=67108863,"Number is too big");var f=0|this.words[0];t=f===e?0:f<e?-1:1}return 0!==this.negative?0|-t:t},d.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},d.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,i=this.length-1;i>=0;i--){var r=0|this.words[i],f=0|e.words[i];if(r!==f){r<f?t=-1:r>f&&(t=1);break}}return t},d.prototype.gtn=function(e){return 1===this.cmpn(e)},d.prototype.gt=function(e){return 1===this.cmp(e)},d.prototype.gten=function(e){return this.cmpn(e)>=0},d.prototype.gte=function(e){return this.cmp(e)>=0},d.prototype.ltn=function(e){return-1===this.cmpn(e)},d.prototype.lt=function(e){return-1===this.cmp(e)},d.prototype.lten=function(e){return this.cmpn(e)<=0},d.prototype.lte=function(e){return this.cmp(e)<=0},d.prototype.eqn=function(e){return 0===this.cmpn(e)},d.prototype.eq=function(e){return 0===this.cmp(e)},d.red=function(e){return new S(e)},d.prototype.toRed=function(e){return r(!this.red,"Already a number in reduction context"),r(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},d.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},d.prototype._forceRed=function(e){return this.red=e,this},d.prototype.forceRed=function(e){return r(!this.red,"Already a number in reduction context"),this._forceRed(e)},d.prototype.redAdd=function(e){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},d.prototype.redIAdd=function(e){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},d.prototype.redSub=function(e){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},d.prototype.redISub=function(e){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},d.prototype.redShl=function(e){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},d.prototype.redMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},d.prototype.redIMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},d.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},d.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},d.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},d.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},d.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},d.prototype.redPow=function(e){return r(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var m={k256:null,p224:null,p192:null,p25519:null};function v(e,t){this.name=e,this.p=new d(t,16),this.n=this.p.bitLength(),this.k=new d(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function g(){v.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function y(){v.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function M(){v.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function w(){v.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function S(e){if("string"==typeof e){var t=d._prime(e);this.m=t.p,this.prime=t}else r(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null}function _(e){S.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new d(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}v.prototype._tmp=function(){var e=new d(null);return e.words=new Array(Math.ceil(this.n/13)),e},v.prototype.ireduce=function(e){var t,i=e;do{this.split(i,this.tmp),t=(i=(i=this.imulK(i)).iadd(this.tmp)).bitLength()}while(t>this.n);var r=t<this.n?-1:i.ucmp(this.p);return 0===r?(i.words[0]=0,i.length=1):r>0?i.isub(this.p):i.strip(),i},v.prototype.split=function(e,t){e.iushrn(this.n,0,t)},v.prototype.imulK=function(e){return e.imul(this.k)},f(g,v),g.prototype.split=function(e,t){for(var i=Math.min(e.length,9),r=0;r<i;r++)t.words[r]=e.words[r];if(t.length=i,e.length<=9)return e.words[0]=0,void(e.length=1);var f=e.words[9];for(t.words[t.length++]=4194303&f,r=10;r<e.length;r++){var d=0|e.words[r];e.words[r-10]=(4194303&d)<<4|f>>>22,f=d}f>>>=22,e.words[r-10]=f,0===f&&e.length>10?e.length-=10:e.length-=9},g.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,i=0;i<e.length;i++){var r=0|e.words[i];t+=977*r,e.words[i]=67108863&t,t=64*r+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},f(y,v),f(M,v),f(w,v),w.prototype.imulK=function(e){for(var t=0,i=0;i<e.length;i++){var r=19*(0|e.words[i])+t,f=67108863&r;r>>>=26,e.words[i]=f,t=r}return 0!==t&&(e.words[e.length++]=t),e},d._prime=function(e){if(m[e])return m[e];var t;if("k256"===e)t=new g;else if("p224"===e)t=new y;else if("p192"===e)t=new M;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new w}return m[e]=t,t},S.prototype._verify1=function(e){r(0===e.negative,"red works only with positives"),r(e.red,"red works only with red numbers")},S.prototype._verify2=function(e,t){r(0==(e.negative|t.negative),"red works only with positives"),r(e.red&&e.red===t.red,"red works only with red numbers")},S.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):e.umod(this.m)._forceRed(this)},S.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},S.prototype.add=function(e,t){this._verify2(e,t);var i=e.add(t);return i.cmp(this.m)>=0&&i.isub(this.m),i._forceRed(this)},S.prototype.iadd=function(e,t){this._verify2(e,t);var i=e.iadd(t);return i.cmp(this.m)>=0&&i.isub(this.m),i},S.prototype.sub=function(e,t){this._verify2(e,t);var i=e.sub(t);return i.cmpn(0)<0&&i.iadd(this.m),i._forceRed(this)},S.prototype.isub=function(e,t){this._verify2(e,t);var i=e.isub(t);return i.cmpn(0)<0&&i.iadd(this.m),i},S.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},S.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},S.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},S.prototype.isqr=function(e){return this.imul(e,e.clone())},S.prototype.sqr=function(e){return this.mul(e,e)},S.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(r(t%2==1),3===t){var i=this.m.add(new d(1)).iushrn(2);return this.pow(e,i)}for(var f=this.m.subn(1),n=0;!f.isZero()&&0===f.andln(1);)n++,f.iushrn(1);r(!f.isZero());var a=new d(1).toRed(this),c=a.redNeg(),s=this.m.subn(1).iushrn(1),h=this.m.bitLength();for(h=new d(2*h*h).toRed(this);0!==this.pow(h,s).cmp(c);)h.redIAdd(c);for(var o=this.pow(h,f),u=this.pow(e,f.addn(1).iushrn(1)),b=this.pow(e,f),l=n;0!==b.cmp(a);){for(var p=b,m=0;0!==p.cmp(a);m++)p=p.redSqr();r(m<l);var v=this.pow(o,new d(1).iushln(l-m-1));u=u.redMul(v),o=v.redSqr(),b=b.redMul(o),l=m}return u},S.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},S.prototype.pow=function(e,t){if(t.isZero())return new d(1);if(0===t.cmpn(1))return e.clone();var i=new Array(16);i[0]=new d(1).toRed(this),i[1]=e;for(var r=2;r<i.length;r++)i[r]=this.mul(i[r-1],e);var f=i[0],n=0,a=0,c=t.bitLength()%26;for(0===c&&(c=26),r=t.length-1;r>=0;r--){for(var s=t.words[r],h=c-1;h>=0;h--){var o=s>>h&1;f!==i[0]&&(f=this.sqr(f)),0!==o||0!==n?(n<<=1,n|=o,(4===++a||0===r&&0===h)&&(f=this.mul(f,i[n]),a=0,n=0)):a=0}c=26}return f},S.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},S.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},d.mont=function(e){return new _(e)},f(_,S),_.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},_.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},_.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var i=e.imul(t),r=i.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),f=i.isub(r).iushrn(this.shift),d=f;return f.cmp(this.m)>=0?d=f.isub(this.m):f.cmpn(0)<0&&(d=f.iadd(this.m)),d._forceRed(this)},_.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new d(0)._forceRed(this);var i=e.mul(t),r=i.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),f=i.isub(r).iushrn(this.shift),n=f;return f.cmp(this.m)>=0?n=f.isub(this.m):f.cmpn(0)<0&&(n=f.iadd(this.m)),n._forceRed(this)},_.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(void 0===t||t,this)},{}],2:[function(e,t,i){"use strict";var r=i;r.version=e("../package.json").version,r.utils=e("./elliptic/utils"),r.rand=e("brorand"),r.hmacDRBG=e("./elliptic/hmac-drbg"),r.curve=e("./elliptic/curve"),r.curves=e("./elliptic/curves"),r.ec=e("./elliptic/ec"),r.eddsa=e("./elliptic/eddsa")},{"../package.json":26,"./elliptic/curve":5,"./elliptic/curves":8,"./elliptic/ec":9,"./elliptic/eddsa":12,"./elliptic/hmac-drbg":15,"./elliptic/utils":17,brorand:18}],3:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../../elliptic").utils,d=f.getNAF,n=f.getJSF,a=f.assert;function c(e,t){this.type=e,this.p=new r(t.p,16),this.red=t.prime?r.red(t.prime):r.mont(this.p),this.zero=new r(0).toRed(this.red),this.one=new r(1).toRed(this.red),this.two=new r(2).toRed(this.red),this.n=t.n&&new r(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4);var i=this.n&&this.p.div(this.n);!i||i.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function s(e,t){this.curve=e,this.type=t,this.precomputed=null}t.exports=c,c.prototype.point=function(){throw new Error("Not implemented")},c.prototype.validate=function(){throw new Error("Not implemented")},c.prototype._fixedNafMul=function(e,t){a(e.precomputed);var i=e._getDoubles(),r=d(t,1),f=(1<<i.step+1)-(i.step%2==0?2:1);f/=3;for(var n=[],c=0;c<r.length;c+=i.step){var s=0;for(t=c+i.step-1;t>=c;t--)s=(s<<1)+r[t];n.push(s)}for(var h=this.jpoint(null,null,null),o=this.jpoint(null,null,null),u=f;u>0;u--){for(c=0;c<n.length;c++){(s=n[c])===u?o=o.mixedAdd(i.points[c]):s===-u&&(o=o.mixedAdd(i.points[c].neg()))}h=h.add(o)}return h.toP()},c.prototype._wnafMul=function(e,t){var i=4,r=e._getNAFPoints(i);i=r.wnd;for(var f=r.points,n=d(t,i),c=this.jpoint(null,null,null),s=n.length-1;s>=0;s--){for(t=0;s>=0&&0===n[s];s--)t++;if(s>=0&&t++,c=c.dblp(t),s<0)break;var h=n[s];a(0!==h),c="affine"===e.type?h>0?c.mixedAdd(f[h-1>>1]):c.mixedAdd(f[-h-1>>1].neg()):h>0?c.add(f[h-1>>1]):c.add(f[-h-1>>1].neg())}return"affine"===e.type?c.toP():c},c.prototype._wnafMulAdd=function(e,t,i,r,f){for(var a=this._wnafT1,c=this._wnafT2,s=this._wnafT3,h=0,o=0;o<r;o++){var u=(x=t[o])._getNAFPoints(e);a[o]=u.wnd,c[o]=u.points}for(o=r-1;o>=1;o-=2){var b=o-1,l=o;if(1===a[b]&&1===a[l]){var p=[t[b],null,null,t[l]];0===t[b].y.cmp(t[l].y)?(p[1]=t[b].add(t[l]),p[2]=t[b].toJ().mixedAdd(t[l].neg())):0===t[b].y.cmp(t[l].y.redNeg())?(p[1]=t[b].toJ().mixedAdd(t[l]),p[2]=t[b].add(t[l].neg())):(p[1]=t[b].toJ().mixedAdd(t[l]),p[2]=t[b].toJ().mixedAdd(t[l].neg()));var m=[-3,-1,-5,-7,0,7,5,1,3],v=n(i[b],i[l]);h=Math.max(v[0].length,h),s[b]=new Array(h),s[l]=new Array(h);for(var g=0;g<h;g++){var y=0|v[0][g],M=0|v[1][g];s[b][g]=m[3*(y+1)+(M+1)],s[l][g]=0,c[b]=p}}else s[b]=d(i[b],a[b]),s[l]=d(i[l],a[l]),h=Math.max(s[b].length,h),h=Math.max(s[l].length,h)}var w=this.jpoint(null,null,null),S=this._wnafT4;for(o=h;o>=0;o--){for(var _=0;o>=0;){var A=!0;for(g=0;g<r;g++)S[g]=0|s[g][o],0!==S[g]&&(A=!1);if(!A)break;_++,o--}if(o>=0&&_++,w=w.dblp(_),o<0)break;for(g=0;g<r;g++){var x,I=S[g];0!==I&&(I>0?x=c[g][I-1>>1]:I<0&&(x=c[g][-I-1>>1].neg()),w="affine"===x.type?w.mixedAdd(x):w.add(x))}}for(o=0;o<r;o++)c[o]=null;return f?w:w.toP()},c.BasePoint=s,s.prototype.eq=function(){throw new Error("Not implemented")},s.prototype.validate=function(){return this.curve.validate(this)},c.prototype.decodePoint=function(e,t){e=f.toArray(e,t);var i=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1==2*i)return 6===e[0]?a(e[e.length-1]%2==0):7===e[0]&&a(e[e.length-1]%2==1),this.point(e.slice(1,1+i),e.slice(1+i,1+2*i));if((2===e[0]||3===e[0])&&e.length-1===i)return this.pointFromX(e.slice(1,1+i),3===e[0]);throw new Error("Unknown point format")},s.prototype.encodeCompressed=function(e){return this.encode(e,!0)},s.prototype._encode=function(e){var t=this.curve.p.byteLength(),i=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(i):[4].concat(i,this.getY().toArray("be",t))},s.prototype.encode=function(e,t){return f.encode(this._encode(t),e)},s.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},s.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return!!t&&t.points.length>=Math.ceil((e.bitLength()+1)/t.step)},s.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var i=[this],r=this,f=0;f<t;f+=e){for(var d=0;d<e;d++)r=r.dbl();i.push(r)}return{step:e,points:i}},s.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],i=(1<<e)-1,r=1===i?null:this.dbl(),f=1;f<i;f++)t[f]=t[f-1].add(r);return{wnd:e,points:t}},s.prototype._getBeta=function(){return null},s.prototype.dblp=function(e){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}},{"../../elliptic":2,"bn.js":1}],4:[function(e,t,i){"use strict";var r=e("../curve"),f=e("../../elliptic"),d=e("bn.js"),n=e("inherits"),a=r.base,c=f.utils.assert;function s(e){this.twisted=1!=(0|e.a),this.mOneA=this.twisted&&-1==(0|e.a),this.extended=this.mOneA,a.call(this,"edwards",e),this.a=new d(e.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new d(e.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new d(e.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),c(!this.twisted||0===this.c.fromRed().cmpn(1)),this.oneC=1==(0|e.c)}function h(e,t,i,r,f){a.BasePoint.call(this,e,"projective"),null===t&&null===i&&null===r?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new d(t,16),this.y=new d(i,16),this.z=r?new d(r,16):this.curve.one,this.t=f&&new d(f,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}n(s,a),t.exports=s,s.prototype._mulA=function(e){return this.mOneA?e.redNeg():this.a.redMul(e)},s.prototype._mulC=function(e){return this.oneC?e:this.c.redMul(e)},s.prototype.jpoint=function(e,t,i,r){return this.point(e,t,i,r)},s.prototype.pointFromX=function(e,t){(e=new d(e,16)).red||(e=e.toRed(this.red));var i=e.redSqr(),r=this.c2.redSub(this.a.redMul(i)),f=this.one.redSub(this.c2.redMul(this.d).redMul(i)),n=r.redMul(f.redInvm()),a=n.redSqrt();if(0!==a.redSqr().redSub(n).cmp(this.zero))throw new Error("invalid point");var c=a.fromRed().isOdd();return(t&&!c||!t&&c)&&(a=a.redNeg()),this.point(e,a)},s.prototype.pointFromY=function(e,t){(e=new d(e,16)).red||(e=e.toRed(this.red));var i=e.redSqr(),r=i.redSub(this.one),f=i.redMul(this.d).redAdd(this.one),n=r.redMul(f.redInvm());if(0===n.cmp(this.zero)){if(t)throw new Error("invalid point");return this.point(this.zero,e)}var a=n.redSqrt();if(0!==a.redSqr().redSub(n).cmp(this.zero))throw new Error("invalid point");return a.isOdd()!==t&&(a=a.redNeg()),this.point(a,e)},s.prototype.validate=function(e){if(e.isInfinity())return!0;e.normalize();var t=e.x.redSqr(),i=e.y.redSqr(),r=t.redMul(this.a).redAdd(i),f=this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(i)));return 0===r.cmp(f)},n(h,a.BasePoint),s.prototype.pointFromJSON=function(e){return h.fromJSON(this,e)},s.prototype.point=function(e,t,i,r){return new h(this,e,t,i,r)},h.fromJSON=function(e,t){return new h(e,t[0],t[1],t[2])},h.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},h.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&0===this.y.cmp(this.z)},h.prototype._extDbl=function(){var e=this.x.redSqr(),t=this.y.redSqr(),i=this.z.redSqr();i=i.redIAdd(i);var r=this.curve._mulA(e),f=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),d=r.redAdd(t),n=d.redSub(i),a=r.redSub(t),c=f.redMul(n),s=d.redMul(a),h=f.redMul(a),o=n.redMul(d);return this.curve.point(c,s,o,h)},h.prototype._projDbl=function(){var e,t,i,r=this.x.redAdd(this.y).redSqr(),f=this.x.redSqr(),d=this.y.redSqr();if(this.curve.twisted){var n=(s=this.curve._mulA(f)).redAdd(d);if(this.zOne)e=r.redSub(f).redSub(d).redMul(n.redSub(this.curve.two)),t=n.redMul(s.redSub(d)),i=n.redSqr().redSub(n).redSub(n);else{var a=this.z.redSqr(),c=n.redSub(a).redISub(a);e=r.redSub(f).redISub(d).redMul(c),t=n.redMul(s.redSub(d)),i=n.redMul(c)}}else{var s=f.redAdd(d);a=this.curve._mulC(this.c.redMul(this.z)).redSqr(),c=s.redSub(a).redSub(a);e=this.curve._mulC(r.redISub(s)).redMul(c),t=this.curve._mulC(s).redMul(f.redISub(d)),i=s.redMul(c)}return this.curve.point(e,t,i)},h.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},h.prototype._extAdd=function(e){var t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),i=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),r=this.t.redMul(this.curve.dd).redMul(e.t),f=this.z.redMul(e.z.redAdd(e.z)),d=i.redSub(t),n=f.redSub(r),a=f.redAdd(r),c=i.redAdd(t),s=d.redMul(n),h=a.redMul(c),o=d.redMul(c),u=n.redMul(a);return this.curve.point(s,h,u,o)},h.prototype._projAdd=function(e){var t,i,r=this.z.redMul(e.z),f=r.redSqr(),d=this.x.redMul(e.x),n=this.y.redMul(e.y),a=this.curve.d.redMul(d).redMul(n),c=f.redSub(a),s=f.redAdd(a),h=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(d).redISub(n),o=r.redMul(c).redMul(h);return this.curve.twisted?(t=r.redMul(s).redMul(n.redSub(this.curve._mulA(d))),i=c.redMul(s)):(t=r.redMul(s).redMul(n.redSub(d)),i=this.curve._mulC(c).redMul(s)),this.curve.point(o,t,i)},h.prototype.add=function(e){return this.isInfinity()?e:e.isInfinity()?this:this.curve.extended?this._extAdd(e):this._projAdd(e)},h.prototype.mul=function(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve._wnafMul(this,e)},h.prototype.mulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!1)},h.prototype.jmulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!0)},h.prototype.normalize=function(){if(this.zOne)return this;var e=this.z.redInvm();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t&&(this.t=this.t.redMul(e)),this.z=this.curve.one,this.zOne=!0,this},h.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},h.prototype.getX=function(){return this.normalize(),this.x.fromRed()},h.prototype.getY=function(){return this.normalize(),this.y.fromRed()},h.prototype.eq=function(e){return this===e||0===this.getX().cmp(e.getX())&&0===this.getY().cmp(e.getY())},h.prototype.eqXToP=function(e){var t=e.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(t))return!0;for(var i=e.clone(),r=this.curve.redN.redMul(this.z);;){if(i.iadd(this.curve.n),i.cmp(this.curve.p)>=0)return!1;if(t.redIAdd(r),0===this.x.cmp(t))return!0}return!1},h.prototype.toP=h.prototype.normalize,h.prototype.mixedAdd=h.prototype.add},{"../../elliptic":2,"../curve":5,"bn.js":1,inherits:25}],5:[function(e,t,i){"use strict";var r=i;r.base=e("./base"),r.short=e("./short"),r.mont=e("./mont"),r.edwards=e("./edwards")},{"./base":3,"./edwards":4,"./mont":6,"./short":7}],6:[function(e,t,i){"use strict";var r=e("../curve"),f=e("bn.js"),d=e("inherits"),n=r.base,a=e("../../elliptic").utils;function c(e){n.call(this,"mont",e),this.a=new f(e.a,16).toRed(this.red),this.b=new f(e.b,16).toRed(this.red),this.i4=new f(4).toRed(this.red).redInvm(),this.two=new f(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}function s(e,t,i){n.BasePoint.call(this,e,"projective"),null===t&&null===i?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new f(t,16),this.z=new f(i,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}d(c,n),t.exports=c,c.prototype.validate=function(e){var t=e.normalize().x,i=t.redSqr(),r=i.redMul(t).redAdd(i.redMul(this.a)).redAdd(t);return 0===r.redSqrt().redSqr().cmp(r)},d(s,n.BasePoint),c.prototype.decodePoint=function(e,t){return this.point(a.toArray(e,t),1)},c.prototype.point=function(e,t){return new s(this,e,t)},c.prototype.pointFromJSON=function(e){return s.fromJSON(this,e)},s.prototype.precompute=function(){},s.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},s.fromJSON=function(e,t){return new s(e,t[0],t[1]||e.one)},s.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},s.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},s.prototype.dbl=function(){var e=this.x.redAdd(this.z).redSqr(),t=this.x.redSub(this.z).redSqr(),i=e.redSub(t),r=e.redMul(t),f=i.redMul(t.redAdd(this.curve.a24.redMul(i)));return this.curve.point(r,f)},s.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.diffAdd=function(e,t){var i=this.x.redAdd(this.z),r=this.x.redSub(this.z),f=e.x.redAdd(e.z),d=e.x.redSub(e.z).redMul(i),n=f.redMul(r),a=t.z.redMul(d.redAdd(n).redSqr()),c=t.x.redMul(d.redISub(n).redSqr());return this.curve.point(a,c)},s.prototype.mul=function(e){for(var t=e.clone(),i=this,r=this.curve.point(null,null),f=[];0!==t.cmpn(0);t.iushrn(1))f.push(t.andln(1));for(var d=f.length-1;d>=0;d--)0===f[d]?(i=i.diffAdd(r,this),r=r.dbl()):(r=i.diffAdd(r,this),i=i.dbl());return r},s.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.eq=function(e){return 0===this.getX().cmp(e.getX())},s.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},s.prototype.getX=function(){return this.normalize(),this.x.fromRed()}},{"../../elliptic":2,"../curve":5,"bn.js":1,inherits:25}],7:[function(e,t,i){"use strict";var r=e("../curve"),f=e("../../elliptic"),d=e("bn.js"),n=e("inherits"),a=r.base,c=f.utils.assert;function s(e){a.call(this,"short",e),this.a=new d(e.a,16).toRed(this.red),this.b=new d(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function h(e,t,i,r){a.BasePoint.call(this,e,"affine"),null===t&&null===i?(this.x=null,this.y=null,this.inf=!0):(this.x=new d(t,16),this.y=new d(i,16),r&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function o(e,t,i,r){a.BasePoint.call(this,e,"jacobian"),null===t&&null===i&&null===r?(this.x=this.curve.one,this.y=this.curve.one,this.z=new d(0)):(this.x=new d(t,16),this.y=new d(i,16),this.z=new d(r,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}n(s,a),t.exports=s,s.prototype._getEndomorphism=function(e){if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3)){var t,i;if(e.beta)t=new d(e.beta,16).toRed(this.red);else{var r=this._getEndoRoots(this.p);t=(t=r[0].cmp(r[1])<0?r[0]:r[1]).toRed(this.red)}if(e.lambda)i=new d(e.lambda,16);else{var f=this._getEndoRoots(this.n);0===this.g.mul(f[0]).x.cmp(this.g.x.redMul(t))?i=f[0]:(i=f[1],c(0===this.g.mul(i).x.cmp(this.g.x.redMul(t))))}return{beta:t,lambda:i,basis:e.basis?e.basis.map(function(e){return{a:new d(e.a,16),b:new d(e.b,16)}}):this._getEndoBasis(i)}}},s.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:d.mont(e),i=new d(2).toRed(t).redInvm(),r=i.redNeg(),f=new d(3).toRed(t).redNeg().redSqrt().redMul(i);return[r.redAdd(f).fromRed(),r.redSub(f).fromRed()]},s.prototype._getEndoBasis=function(e){for(var t,i,r,f,n,a,c,s,h,o=this.n.ushrn(Math.floor(this.n.bitLength()/2)),u=e,b=this.n.clone(),l=new d(1),p=new d(0),m=new d(0),v=new d(1),g=0;0!==u.cmpn(0);){var y=b.div(u);s=b.sub(y.mul(u)),h=m.sub(y.mul(l));var M=v.sub(y.mul(p));if(!r&&s.cmp(o)<0)t=c.neg(),i=l,r=s.neg(),f=h;else if(r&&2==++g)break;c=s,b=u,u=s,m=l,l=h,v=p,p=M}n=s.neg(),a=h;var w=r.sqr().add(f.sqr());return n.sqr().add(a.sqr()).cmp(w)>=0&&(n=t,a=i),r.negative&&(r=r.neg(),f=f.neg()),n.negative&&(n=n.neg(),a=a.neg()),[{a:r,b:f},{a:n,b:a}]},s.prototype._endoSplit=function(e){var t=this.endo.basis,i=t[0],r=t[1],f=r.b.mul(e).divRound(this.n),d=i.b.neg().mul(e).divRound(this.n),n=f.mul(i.a),a=d.mul(r.a),c=f.mul(i.b),s=d.mul(r.b);return{k1:e.sub(n).sub(a),k2:c.add(s).neg()}},s.prototype.pointFromX=function(e,t){(e=new d(e,16)).red||(e=e.toRed(this.red));var i=e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),r=i.redSqrt();if(0!==r.redSqr().redSub(i).cmp(this.zero))throw new Error("invalid point");var f=r.fromRed().isOdd();return(t&&!f||!t&&f)&&(r=r.redNeg()),this.point(e,r)},s.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,i=e.y,r=this.a.redMul(t),f=t.redSqr().redMul(t).redIAdd(r).redIAdd(this.b);return 0===i.redSqr().redISub(f).cmpn(0)},s.prototype._endoWnafMulAdd=function(e,t,i){for(var r=this._endoWnafT1,f=this._endoWnafT2,d=0;d<e.length;d++){var n=this._endoSplit(t[d]),a=e[d],c=a._getBeta();n.k1.negative&&(n.k1.ineg(),a=a.neg(!0)),n.k2.negative&&(n.k2.ineg(),c=c.neg(!0)),r[2*d]=a,r[2*d+1]=c,f[2*d]=n.k1,f[2*d+1]=n.k2}for(var s=this._wnafMulAdd(1,r,f,2*d,i),h=0;h<2*d;h++)r[h]=null,f[h]=null;return s},n(h,a.BasePoint),s.prototype.point=function(e,t,i){return new h(this,e,t,i)},s.prototype.pointFromJSON=function(e,t){return h.fromJSON(this,e,t)},h.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(e){var i=this.curve,r=function(e){return i.point(e.x.redMul(i.endo.beta),e.y)};e.beta=t,t.precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(r)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(r)}}}return t}},h.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},h.fromJSON=function(e,t,i){"string"==typeof t&&(t=JSON.parse(t));var r=e.point(t[0],t[1],i);if(!t[2])return r;function f(t){return e.point(t[0],t[1],i)}var d=t[2];return r.precomputed={beta:null,doubles:d.doubles&&{step:d.doubles.step,points:[r].concat(d.doubles.points.map(f))},naf:d.naf&&{wnd:d.naf.wnd,points:[r].concat(d.naf.points.map(f))}},r},h.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},h.prototype.isInfinity=function(){return this.inf},h.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y);0!==t.cmpn(0)&&(t=t.redMul(this.x.redSub(e.x).redInvm()));var i=t.redSqr().redISub(this.x).redISub(e.x),r=t.redMul(this.x.redSub(i)).redISub(this.y);return this.curve.point(i,r)},h.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,i=this.x.redSqr(),r=e.redInvm(),f=i.redAdd(i).redIAdd(i).redIAdd(t).redMul(r),d=f.redSqr().redISub(this.x.redAdd(this.x)),n=f.redMul(this.x.redSub(d)).redISub(this.y);return this.curve.point(d,n)},h.prototype.getX=function(){return this.x.fromRed()},h.prototype.getY=function(){return this.y.fromRed()},h.prototype.mul=function(e){return e=new d(e,16),this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},h.prototype.mulAdd=function(e,t,i){var r=[this,t],f=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(r,f):this.curve._wnafMulAdd(1,r,f,2)},h.prototype.jmulAdd=function(e,t,i){var r=[this,t],f=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(r,f,!0):this.curve._wnafMulAdd(1,r,f,2,!0)},h.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},h.prototype.neg=function(e){if(this.inf)return this;var t=this.curve.point(this.x,this.y.redNeg());if(e&&this.precomputed){var i=this.precomputed,r=function(e){return e.neg()};t.precomputed={naf:i.naf&&{wnd:i.naf.wnd,points:i.naf.points.map(r)},doubles:i.doubles&&{step:i.doubles.step,points:i.doubles.points.map(r)}}}return t},h.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},n(o,a.BasePoint),s.prototype.jpoint=function(e,t,i){return new o(this,e,t,i)},o.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),i=this.x.redMul(t),r=this.y.redMul(t).redMul(e);return this.curve.point(i,r)},o.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},o.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),i=this.z.redSqr(),r=this.x.redMul(t),f=e.x.redMul(i),d=this.y.redMul(t.redMul(e.z)),n=e.y.redMul(i.redMul(this.z)),a=r.redSub(f),c=d.redSub(n);if(0===a.cmpn(0))return 0!==c.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var s=a.redSqr(),h=s.redMul(a),o=r.redMul(s),u=c.redSqr().redIAdd(h).redISub(o).redISub(o),b=c.redMul(o.redISub(u)).redISub(d.redMul(h)),l=this.z.redMul(e.z).redMul(a);return this.curve.jpoint(u,b,l)},o.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),i=this.x,r=e.x.redMul(t),f=this.y,d=e.y.redMul(t).redMul(this.z),n=i.redSub(r),a=f.redSub(d);if(0===n.cmpn(0))return 0!==a.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var c=n.redSqr(),s=c.redMul(n),h=i.redMul(c),o=a.redSqr().redIAdd(s).redISub(h).redISub(h),u=a.redMul(h.redISub(o)).redISub(f.redMul(s)),b=this.z.redMul(n);return this.curve.jpoint(o,u,b)},o.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}var r=this.curve.a,f=this.curve.tinv,d=this.x,n=this.y,a=this.z,c=a.redSqr().redSqr(),s=n.redAdd(n);for(i=0;i<e;i++){var h=d.redSqr(),o=s.redSqr(),u=o.redSqr(),b=h.redAdd(h).redIAdd(h).redIAdd(r.redMul(c)),l=d.redMul(o),p=b.redSqr().redISub(l.redAdd(l)),m=l.redISub(p),v=b.redMul(m);v=v.redIAdd(v).redISub(u);var g=s.redMul(a);i+1<e&&(c=c.redMul(u)),d=p,a=g,s=v}return this.curve.jpoint(d,s.redMul(f),a)},o.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},o.prototype._zeroDbl=function(){var e,t,i;if(this.zOne){var r=this.x.redSqr(),f=this.y.redSqr(),d=f.redSqr(),n=this.x.redAdd(f).redSqr().redISub(r).redISub(d);n=n.redIAdd(n);var a=r.redAdd(r).redIAdd(r),c=a.redSqr().redISub(n).redISub(n),s=d.redIAdd(d);s=(s=s.redIAdd(s)).redIAdd(s),e=c,t=a.redMul(n.redISub(c)).redISub(s),i=this.y.redAdd(this.y)}else{var h=this.x.redSqr(),o=this.y.redSqr(),u=o.redSqr(),b=this.x.redAdd(o).redSqr().redISub(h).redISub(u);b=b.redIAdd(b);var l=h.redAdd(h).redIAdd(h),p=l.redSqr(),m=u.redIAdd(u);m=(m=m.redIAdd(m)).redIAdd(m),e=p.redISub(b).redISub(b),t=l.redMul(b.redISub(e)).redISub(m),i=(i=this.y.redMul(this.z)).redIAdd(i)}return this.curve.jpoint(e,t,i)},o.prototype._threeDbl=function(){var e,t,i;if(this.zOne){var r=this.x.redSqr(),f=this.y.redSqr(),d=f.redSqr(),n=this.x.redAdd(f).redSqr().redISub(r).redISub(d);n=n.redIAdd(n);var a=r.redAdd(r).redIAdd(r).redIAdd(this.curve.a),c=a.redSqr().redISub(n).redISub(n);e=c;var s=d.redIAdd(d);s=(s=s.redIAdd(s)).redIAdd(s),t=a.redMul(n.redISub(c)).redISub(s),i=this.y.redAdd(this.y)}else{var h=this.z.redSqr(),o=this.y.redSqr(),u=this.x.redMul(o),b=this.x.redSub(h).redMul(this.x.redAdd(h));b=b.redAdd(b).redIAdd(b);var l=u.redIAdd(u),p=(l=l.redIAdd(l)).redAdd(l);e=b.redSqr().redISub(p),i=this.y.redAdd(this.z).redSqr().redISub(o).redISub(h);var m=o.redSqr();m=(m=(m=m.redIAdd(m)).redIAdd(m)).redIAdd(m),t=b.redMul(l.redISub(e)).redISub(m)}return this.curve.jpoint(e,t,i)},o.prototype._dbl=function(){var e=this.curve.a,t=this.x,i=this.y,r=this.z,f=r.redSqr().redSqr(),d=t.redSqr(),n=i.redSqr(),a=d.redAdd(d).redIAdd(d).redIAdd(e.redMul(f)),c=t.redAdd(t),s=(c=c.redIAdd(c)).redMul(n),h=a.redSqr().redISub(s.redAdd(s)),o=s.redISub(h),u=n.redSqr();u=(u=(u=u.redIAdd(u)).redIAdd(u)).redIAdd(u);var b=a.redMul(o).redISub(u),l=i.redAdd(i).redMul(r);return this.curve.jpoint(h,b,l)},o.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),i=this.z.redSqr(),r=t.redSqr(),f=e.redAdd(e).redIAdd(e),d=f.redSqr(),n=this.x.redAdd(t).redSqr().redISub(e).redISub(r),a=(n=(n=(n=n.redIAdd(n)).redAdd(n).redIAdd(n)).redISub(d)).redSqr(),c=r.redIAdd(r);c=(c=(c=c.redIAdd(c)).redIAdd(c)).redIAdd(c);var s=f.redIAdd(n).redSqr().redISub(d).redISub(a).redISub(c),h=t.redMul(s);h=(h=h.redIAdd(h)).redIAdd(h);var o=this.x.redMul(a).redISub(h);o=(o=o.redIAdd(o)).redIAdd(o);var u=this.y.redMul(s.redMul(c.redISub(s)).redISub(n.redMul(a)));u=(u=(u=u.redIAdd(u)).redIAdd(u)).redIAdd(u);var b=this.z.redAdd(n).redSqr().redISub(i).redISub(a);return this.curve.jpoint(o,u,b)},o.prototype.mul=function(e,t){return e=new d(e,t),this.curve._wnafMul(this,e)},o.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),i=e.z.redSqr();if(0!==this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0))return!1;var r=t.redMul(this.z),f=i.redMul(e.z);return 0===this.y.redMul(f).redISub(e.y.redMul(r)).cmpn(0)},o.prototype.eqXToP=function(e){var t=this.z.redSqr(),i=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(i))return!0;for(var r=e.clone(),f=this.curve.redN.redMul(t);;){if(r.iadd(this.curve.n),r.cmp(this.curve.p)>=0)return!1;if(i.redIAdd(f),0===this.x.cmp(i))return!0}return!1},o.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},o.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},{"../../elliptic":2,"../curve":5,"bn.js":1,inherits:25}],8:[function(e,t,i){"use strict";var r,f=i,d=e("hash.js"),n=e("../elliptic"),a=n.utils.assert;function c(e){"short"===e.type?this.curve=new n.curve.short(e):"edwards"===e.type?this.curve=new n.curve.edwards(e):this.curve=new n.curve.mont(e),this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,a(this.g.validate(),"Invalid curve"),a(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function s(e,t){Object.defineProperty(f,e,{configurable:!0,enumerable:!0,get:function(){var i=new c(t);return Object.defineProperty(f,e,{configurable:!0,enumerable:!0,value:i}),i}})}f.PresetCurve=c,s("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:d.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),s("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:d.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),s("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:d.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),s("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:d.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),s("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:d.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),s("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"0",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:d.sha256,gRed:!1,g:["9"]}),s("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:d.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});try{r=e("./precomputed/secp256k1")}catch(e){r=void 0}s("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:d.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]})},{"../elliptic":2,"./precomputed/secp256k1":16,"hash.js":19}],9:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../../elliptic"),d=f.utils.assert,n=e("./key"),a=e("./signature");function c(e){if(!(this instanceof c))return new c(e);"string"==typeof e&&(d(f.curves.hasOwnProperty(e),"Unknown curve "+e),e=f.curves[e]),e instanceof f.curves.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),this.hash=e.hash||e.curve.hash}t.exports=c,c.prototype.keyPair=function(e){return new n(this,e)},c.prototype.keyFromPrivate=function(e,t){return n.fromPrivate(this,e,t)},c.prototype.keyFromPublic=function(e,t){return n.fromPublic(this,e,t)},c.prototype.genKeyPair=function(e){e||(e={});for(var t=new f.hmacDRBG({hash:this.hash,pers:e.pers,entropy:e.entropy||f.rand(this.hash.hmacStrength),nonce:this.n.toArray()}),i=this.n.byteLength(),d=this.n.sub(new r(2));;){var n=new r(t.generate(i));if(!(n.cmp(d)>0))return n.iaddn(1),this.keyFromPrivate(n)}},c.prototype._truncateToN=function(e,t){var i=8*e.byteLength()-this.n.bitLength();return i>0&&(e=e.ushrn(i)),!t&&e.cmp(this.n)>=0?e.sub(this.n):e},c.prototype.sign=function(e,t,i,d){"object"==typeof i&&(d=i,i=null),d||(d={}),t=this.keyFromPrivate(t,i),e=this._truncateToN(new r(e,16));for(var n=this.n.byteLength(),c=t.getPrivate().toArray("be",n),s=e.toArray("be",n),h=new f.hmacDRBG({hash:this.hash,entropy:c,nonce:s,pers:d.pers,persEnc:d.persEnc}),o=this.n.sub(new r(1)),u=0;;u++){var b=d.k?d.k(u):new r(h.generate(this.n.byteLength()));if(!((b=this._truncateToN(b,!0)).cmpn(1)<=0||b.cmp(o)>=0)){var l=this.g.mul(b);if(!l.isInfinity()){var p=l.getX(),m=p.umod(this.n);if(0!==m.cmpn(0)){var v=b.invm(this.n).mul(m.mul(t.getPrivate()).iadd(e));if(0!==(v=v.umod(this.n)).cmpn(0)){var g=(l.getY().isOdd()?1:0)|(0!==p.cmp(m)?2:0);return d.canonical&&v.cmp(this.nh)>0&&(v=this.n.sub(v),g^=1),new a({r:m,s:v,recoveryParam:g})}}}}}},c.prototype.verify=function(e,t,i,f){e=this._truncateToN(new r(e,16)),i=this.keyFromPublic(i,f);var d=(t=new a(t,"hex")).r,n=t.s;if(d.cmpn(1)<0||d.cmp(this.n)>=0)return!1;if(n.cmpn(1)<0||n.cmp(this.n)>=0)return!1;var c,s=n.invm(this.n),h=s.mul(e).umod(this.n),o=s.mul(d).umod(this.n);return this.curve._maxwellTrick?!(c=this.g.jmulAdd(h,i.getPublic(),o)).isInfinity()&&c.eqXToP(d):!(c=this.g.mulAdd(h,i.getPublic(),o)).isInfinity()&&0===c.getX().umod(this.n).cmp(d)},c.prototype.recoverPubKey=function(e,t,i,f){d((3&i)===i,"The recovery param is more than two bits"),t=new a(t,f);var n=this.n,c=new r(e),s=t.r,h=t.s,o=1&i,u=i>>1;if(s.cmp(this.curve.p.umod(this.curve.n))>=0&&u)throw new Error("Unable to find sencond key candinate");s=u?this.curve.pointFromX(s.add(this.curve.n),o):this.curve.pointFromX(s,o);var b=t.r.invm(n),l=n.sub(c).mul(b).umod(n),p=h.mul(b).umod(n);return this.g.mulAdd(l,s,p)},c.prototype.getKeyRecoveryParam=function(e,t,i,r){if(null!==(t=new a(t,r)).recoveryParam)return t.recoveryParam;for(var f=0;f<4;f++){var d;try{d=this.recoverPubKey(e,t,f)}catch(e){continue}if(d.eq(i))return f}throw new Error("Unable to find valid recovery factor")}},{"../../elliptic":2,"./key":10,"./signature":11,"bn.js":1}],10:[function(e,t,i){"use strict";var r=e("bn.js");function f(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc)}t.exports=f,f.fromPublic=function(e,t,i){return t instanceof f?t:new f(e,{pub:t,pubEnc:i})},f.fromPrivate=function(e,t,i){return t instanceof f?t:new f(e,{priv:t,privEnc:i})},f.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},f.prototype.getPublic=function(e,t){return"string"==typeof e&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub},f.prototype.getPrivate=function(e){return"hex"===e?this.priv.toString(16,2):this.priv},f.prototype._importPrivate=function(e,t){this.priv=new r(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)},f.prototype._importPublic=function(e,t){e.x||e.y?this.pub=this.ec.curve.point(e.x,e.y):this.pub=this.ec.curve.decodePoint(e,t)},f.prototype.derive=function(e){return e.mul(this.priv).getX()},f.prototype.sign=function(e,t,i){return this.ec.sign(e,this,t,i)},f.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},f.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},{"bn.js":1}],11:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../../elliptic").utils,d=f.assert;function n(e,t){if(e instanceof n)return e;this._importDER(e,t)||(d(e.r&&e.s,"Signature without r or s"),this.r=new r(e.r,16),this.s=new r(e.s,16),void 0===e.recoveryParam?this.recoveryParam=null:this.recoveryParam=e.recoveryParam)}function a(){this.place=0}function c(e,t){var i=e[t.place++];if(!(128&i))return i;for(var r=15&i,f=0,d=0,n=t.place;d<r;d++,n++)f<<=8,f|=e[n];return t.place=n,f}function s(e){for(var t=0,i=e.length-1;!e[t]&&!(128&e[t+1])&&t<i;)t++;return 0===t?e:e.slice(t)}function h(e,t){if(t<128)e.push(t);else{var i=1+(Math.log(t)/Math.LN2>>>3);for(e.push(128|i);--i;)e.push(t>>>(i<<3)&255);e.push(t)}}t.exports=n,n.prototype._importDER=function(e,t){e=f.toArray(e,t);var i=new a;if(48!==e[i.place++])return!1;if(c(e,i)+i.place!==e.length)return!1;if(2!==e[i.place++])return!1;var d=c(e,i),n=e.slice(i.place,d+i.place);if(i.place+=d,2!==e[i.place++])return!1;var s=c(e,i);if(e.length!==s+i.place)return!1;var h=e.slice(i.place,s+i.place);return 0===n[0]&&128&n[1]&&(n=n.slice(1)),0===h[0]&&128&h[1]&&(h=h.slice(1)),this.r=new r(n),this.s=new r(h),this.recoveryParam=null,!0},n.prototype.toDER=function(e){var t=this.r.toArray(),i=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&i[0]&&(i=[0].concat(i)),t=s(t),i=s(i);!(i[0]||128&i[1]);)i=i.slice(1);var r=[2];h(r,t.length),(r=r.concat(t)).push(2),h(r,i.length);var d=r.concat(i),n=[48];return h(n,d.length),n=n.concat(d),f.encode(n,e)}},{"../../elliptic":2,"bn.js":1}],12:[function(e,t,i){"use strict";var r=e("hash.js"),f=e("../../elliptic"),d=f.utils,n=d.assert,a=d.parseBytes,c=e("./key"),s=e("./signature");function h(e){if(n("ed25519"===e,"only tested with ed25519 so far"),!(this instanceof h))return new h(e);e=f.curves[e].curve;this.curve=e,this.g=e.g,this.g.precompute(e.n.bitLength()+1),this.pointClass=e.point().constructor,this.encodingLength=Math.ceil(e.n.bitLength()/8),this.hash=r.sha512}t.exports=h,h.prototype.sign=function(e,t){e=a(e);var i=this.keyFromSecret(t),r=this.hashInt(i.messagePrefix(),e),f=this.g.mul(r),d=this.encodePoint(f),n=this.hashInt(d,i.pubBytes(),e).mul(i.priv()),c=r.add(n).umod(this.curve.n);return this.makeSignature({R:f,S:c,Rencoded:d})},h.prototype.verify=function(e,t,i){e=a(e),t=this.makeSignature(t);var r=this.keyFromPublic(i),f=this.hashInt(t.Rencoded(),r.pubBytes(),e),d=this.g.mul(t.S());return t.R().add(r.pub().mul(f)).eq(d)},h.prototype.hashInt=function(){for(var e=this.hash(),t=0;t<arguments.length;t++)e.update(arguments[t]);return d.intFromLE(e.digest()).umod(this.curve.n)},h.prototype.keyFromPublic=function(e){return c.fromPublic(this,e)},h.prototype.keyFromSecret=function(e){return c.fromSecret(this,e)},h.prototype.makeSignature=function(e){return e instanceof s?e:new s(this,e)},h.prototype.encodePoint=function(e){var t=e.getY().toArray("le",this.encodingLength);return t[this.encodingLength-1]|=e.getX().isOdd()?128:0,t},h.prototype.decodePoint=function(e){var t=(e=d.parseBytes(e)).length-1,i=e.slice(0,t).concat(-129&e[t]),r=0!=(128&e[t]),f=d.intFromLE(i);return this.curve.pointFromY(f,r)},h.prototype.encodeInt=function(e){return e.toArray("le",this.encodingLength)},h.prototype.decodeInt=function(e){return d.intFromLE(e)},h.prototype.isPoint=function(e){return e instanceof this.pointClass}},{"../../elliptic":2,"./key":13,"./signature":14,"hash.js":19}],13:[function(e,t,i){"use strict";var r=e("../../elliptic").utils,f=r.assert,d=r.parseBytes,n=r.cachedProperty;function a(e,t){this.eddsa=e,this._secret=d(t.secret),e.isPoint(t.pub)?this._pub=t.pub:this._pubBytes=d(t.pub)}a.fromPublic=function(e,t){return t instanceof a?t:new a(e,{pub:t})},a.fromSecret=function(e,t){return t instanceof a?t:new a(e,{secret:t})},a.prototype.secret=function(){return this._secret},n(a,"pubBytes",function(){return this.eddsa.encodePoint(this.pub())}),n(a,"pub",function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())}),n(a,"privBytes",function(){var e=this.eddsa,t=this.hash(),i=e.encodingLength-1,r=t.slice(0,e.encodingLength);return r[0]&=248,r[i]&=127,r[i]|=64,r}),n(a,"priv",function(){return this.eddsa.decodeInt(this.privBytes())}),n(a,"hash",function(){return this.eddsa.hash().update(this.secret()).digest()}),n(a,"messagePrefix",function(){return this.hash().slice(this.eddsa.encodingLength)}),a.prototype.sign=function(e){return f(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)},a.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)},a.prototype.getSecret=function(e){return f(this._secret,"KeyPair is public only"),r.encode(this.secret(),e)},a.prototype.getPublic=function(e){return r.encode(this.pubBytes(),e)},t.exports=a},{"../../elliptic":2}],14:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../../elliptic").utils,d=f.assert,n=f.cachedProperty,a=f.parseBytes;function c(e,t){this.eddsa=e,"object"!=typeof t&&(t=a(t)),Array.isArray(t)&&(t={R:t.slice(0,e.encodingLength),S:t.slice(e.encodingLength)}),d(t.R&&t.S,"Signature without R or S"),e.isPoint(t.R)&&(this._R=t.R),t.S instanceof r&&(this._S=t.S),this._Rencoded=Array.isArray(t.R)?t.R:t.Rencoded,this._Sencoded=Array.isArray(t.S)?t.S:t.Sencoded}n(c,"S",function(){return this.eddsa.decodeInt(this.Sencoded())}),n(c,"R",function(){return this.eddsa.decodePoint(this.Rencoded())}),n(c,"Rencoded",function(){return this.eddsa.encodePoint(this.R())}),n(c,"Sencoded",function(){return this.eddsa.encodeInt(this.S())}),c.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())},c.prototype.toHex=function(){return f.encode(this.toBytes(),"hex").toUpperCase()},t.exports=c},{"../../elliptic":2,"bn.js":1}],15:[function(e,t,i){"use strict";var r=e("hash.js"),f=e("../elliptic").utils,d=f.assert;function n(e){if(!(this instanceof n))return new n(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.outSize,this.minEntropy=e.minEntropy||this.hash.hmacStrength,this.reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=f.toArray(e.entropy,e.entropyEnc),i=f.toArray(e.nonce,e.nonceEnc),r=f.toArray(e.pers,e.persEnc);d(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,i,r)}t.exports=n,n.prototype._init=function(e,t,i){var r=e.concat(t).concat(i);this.K=new Array(this.outLen/8),this.V=new Array(this.outLen/8);for(var f=0;f<this.V.length;f++)this.K[f]=0,this.V[f]=1;this._update(r),this.reseed=1,this.reseedInterval=281474976710656},n.prototype._hmac=function(){return new r.hmac(this.hash,this.K)},n.prototype._update=function(e){var t=this._hmac().update(this.V).update([0]);e&&(t=t.update(e)),this.K=t.digest(),this.V=this._hmac().update(this.V).digest(),e&&(this.K=this._hmac().update(this.V).update([1]).update(e).digest(),this.V=this._hmac().update(this.V).digest())},n.prototype.reseed=function(e,t,i,r){"string"!=typeof t&&(r=i,i=t,t=null),e=f.toBuffer(e,t),i=f.toBuffer(i,r),d(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(i||[])),this.reseed=1},n.prototype.generate=function(e,t,i,r){if(this.reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof t&&(r=i,i=t,t=null),i&&(i=f.toArray(i,r),this._update(i));for(var d=[];d.length<e;)this.V=this._hmac().update(this.V).digest(),d=d.concat(this.V);var n=d.slice(0,e);return this._update(i),this.reseed++,f.encode(n,t)}},{"../elliptic":2,"hash.js":19}],16:[function(e,t,i){t.exports={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}},{}],17:[function(e,t,i){"use strict";var r=i,f=e("bn.js");function d(e){return 1===e.length?"0"+e:e}function n(e){for(var t="",i=0;i<e.length;i++)t+=d(e[i].toString(16));return t}r.assert=function(e,t){if(!e)throw new Error(t||"Assertion failed")},r.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var i=[];if("string"!=typeof e){for(var r=0;r<e.length;r++)i[r]=0|e[r];return i}if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),r=0;r<e.length;r+=2)i.push(parseInt(e[r]+e[r+1],16))}else for(var r=0;r<e.length;r++){var f=e.charCodeAt(r),d=f>>8,n=255&f;d?i.push(d,n):i.push(n)}return i},r.zero2=d,r.toHex=n,r.encode=function(e,t){return"hex"===t?n(e):e},r.getNAF=function(e,t){for(var i=[],r=1<<t+1,f=e.clone();f.cmpn(1)>=0;){var d;if(f.isOdd()){var n=f.andln(r-1);d=n>(r>>1)-1?(r>>1)-n:n,f.isubn(d)}else d=0;i.push(d);for(var a=0!==f.cmpn(0)&&0===f.andln(r-1)?t+1:1,c=1;c<a;c++)i.push(0);f.iushrn(a)}return i},r.getJSF=function(e,t){var i=[[],[]];e=e.clone(),t=t.clone();for(var r=0,f=0;e.cmpn(-r)>0||t.cmpn(-f)>0;){var d,n,a,c=e.andln(3)+r&3,s=t.andln(3)+f&3;3===c&&(c=-1),3===s&&(s=-1),d=0==(1&c)?0:3!=(a=e.andln(7)+r&7)&&5!==a||2!==s?c:-c,i[0].push(d),n=0==(1&s)?0:3!=(a=t.andln(7)+f&7)&&5!==a||2!==c?s:-s,i[1].push(n),2*r===d+1&&(r=1-r),2*f===n+1&&(f=1-f),e.iushrn(1),t.iushrn(1)}return i},r.cachedProperty=function(e,t,i){var r="_"+t;e.prototype[t]=function(){return void 0!==this[r]?this[r]:this[r]=i.call(this)}},r.parseBytes=function(e){return"string"==typeof e?r.toArray(e,"hex"):e},r.intFromLE=function(e){return new f(e,"hex","le")}},{"bn.js":1}],18:[function(e,t,i){var r;function f(e){this.rand=e}if(t.exports=function(e){return r||(r=new f(null)),r.generate(e)},t.exports.Rand=f,f.prototype.generate=function(e){return this._rand(e)},"object"==typeof self)self.crypto&&self.crypto.getRandomValues?f.prototype._rand=function(e){var t=new Uint8Array(e);return self.crypto.getRandomValues(t),t}:self.msCrypto&&self.msCrypto.getRandomValues?f.prototype._rand=function(e){var t=new Uint8Array(e);return self.msCrypto.getRandomValues(t),t}:f.prototype._rand=function(){throw new Error("Not implemented yet")};else try{var d=e("crypto");f.prototype._rand=function(e){return d.randomBytes(e)}}catch(e){f.prototype._rand=function(e){for(var t=new Uint8Array(e),i=0;i<t.length;i++)t[i]=this.rand.getByte();return t}}},{}],19:[function(e,t,i){var r=i;r.utils=e("./hash/utils"),r.common=e("./hash/common"),r.sha=e("./hash/sha"),r.ripemd=e("./hash/ripemd"),r.hmac=e("./hash/hmac"),r.sha1=r.sha.sha1,r.sha256=r.sha.sha256,r.sha224=r.sha.sha224,r.sha384=r.sha.sha384,r.sha512=r.sha.sha512,r.ripemd160=r.ripemd.ripemd160},{"./hash/common":20,"./hash/hmac":21,"./hash/ripemd":22,"./hash/sha":23,"./hash/utils":24}],20:[function(e,t,i){var r=e("../hash").utils,f=r.assert;function d(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}i.BlockHash=d,d.prototype.update=function(e,t){if(e=r.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var i=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-i,e.length),0===this.pending.length&&(this.pending=null),e=r.join32(e,0,e.length-i,this.endian);for(var f=0;f<e.length;f+=this._delta32)this._update(e,f,f+this._delta32)}return this},d.prototype.digest=function(e){return this.update(this._pad()),f(null===this.pending),this._digest(e)},d.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,i=t-(e+this.padLength)%t,r=new Array(i+this.padLength);r[0]=128;for(var f=1;f<i;f++)r[f]=0;if(e<<=3,"big"===this.endian){for(var d=8;d<this.padLength;d++)r[f++]=0;r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=e>>>24&255,r[f++]=e>>>16&255,r[f++]=e>>>8&255,r[f++]=255&e}else{r[f++]=255&e,r[f++]=e>>>8&255,r[f++]=e>>>16&255,r[f++]=e>>>24&255,r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=0;for(d=8;d<this.padLength;d++)r[f++]=0}return r}},{"../hash":19}],21:[function(e,t,i){var r=e("../hash").utils,f=r.assert;function d(e,t,i){if(!(this instanceof d))return new d(e,t,i);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(r.toArray(t,i))}t.exports=d,d.prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),f(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;this.inner=(new this.Hash).update(e);for(t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},d.prototype.update=function(e,t){return this.inner.update(e,t),this},d.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},{"../hash":19}],22:[function(e,t,i){var r=e("../hash"),f=r.utils,d=f.rotl32,n=f.sum32,a=f.sum32_3,c=f.sum32_4,s=r.common.BlockHash;function h(){if(!(this instanceof h))return new h;s.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function o(e,t,i,r){return e<=15?t^i^r:e<=31?t&i|~t&r:e<=47?(t|~i)^r:e<=63?t&r|i&~r:t^(i|~r)}function u(e){return e<=15?0:e<=31?1518500249:e<=47?1859775393:e<=63?2400959708:2840853838}function b(e){return e<=15?1352829926:e<=31?1548603684:e<=47?1836072691:e<=63?2053994217:0}f.inherits(h,s),i.ripemd160=h,h.blockSize=512,h.outSize=160,h.hmacStrength=192,h.padLength=64,h.prototype._update=function(e,t){for(var i=this.h[0],r=this.h[1],f=this.h[2],s=this.h[3],h=this.h[4],g=i,y=r,M=f,w=s,S=h,_=0;_<80;_++){var A=n(d(c(i,o(_,r,f,s),e[l[_]+t],u(_)),m[_]),h);i=h,h=s,s=d(f,10),f=r,r=A,A=n(d(c(g,o(79-_,y,M,w),e[p[_]+t],b(_)),v[_]),S),g=S,S=w,w=d(M,10),M=y,y=A}A=a(this.h[1],f,w),this.h[1]=a(this.h[2],s,S),this.h[2]=a(this.h[3],h,g),this.h[3]=a(this.h[4],i,y),this.h[4]=a(this.h[0],r,M),this.h[0]=A},h.prototype._digest=function(e){return"hex"===e?f.toHex32(this.h,"little"):f.split32(this.h,"little")};var l=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],p=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],m=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],v=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},{"../hash":19}],23:[function(e,t,i){var r=e("../hash"),f=r.utils,d=f.assert,n=f.rotr32,a=f.rotl32,c=f.sum32,s=f.sum32_4,h=f.sum32_5,o=f.rotr64_hi,u=f.rotr64_lo,b=f.shr64_hi,l=f.shr64_lo,p=f.sum64,m=f.sum64_hi,v=f.sum64_lo,g=f.sum64_4_hi,y=f.sum64_4_lo,M=f.sum64_5_hi,w=f.sum64_5_lo,S=r.common.BlockHash,_=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],A=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591],x=[1518500249,1859775393,2400959708,3395469782];function I(){if(!(this instanceof I))return new I;S.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=_,this.W=new Array(64)}function z(){if(!(this instanceof z))return new z;I.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}function q(){if(!(this instanceof q))return new q;S.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=A,this.W=new Array(160)}function R(){if(!(this instanceof R))return new R;q.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}function k(){if(!(this instanceof k))return new k;S.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}function P(e,t,i){return e&t^~e&i}function j(e,t,i){return e&t^e&i^t&i}function N(e){return n(e,2)^n(e,13)^n(e,22)}function E(e){return n(e,6)^n(e,11)^n(e,25)}function B(e){return n(e,7)^n(e,18)^e>>>3}function L(e,t,i,r){return 0===e?P(t,i,r):1===e||3===e?function(e,t,i){return e^t^i}(t,i,r):2===e?j(t,i,r):void 0}function O(e,t,i,r,f,d){var n=e&i^~e&f;return n<0&&(n+=4294967296),n}function F(e,t,i,r,f,d){var n=t&r^~t&d;return n<0&&(n+=4294967296),n}function T(e,t,i,r,f,d){var n=e&i^e&f^i&f;return n<0&&(n+=4294967296),n}function C(e,t,i,r,f,d){var n=t&r^t&d^r&d;return n<0&&(n+=4294967296),n}function Z(e,t){var i=o(e,t,28)^o(t,e,2)^o(t,e,7);return i<0&&(i+=4294967296),i}function D(e,t){var i=u(e,t,28)^u(t,e,2)^u(t,e,7);return i<0&&(i+=4294967296),i}function J(e,t){var i=o(e,t,14)^o(e,t,18)^o(t,e,9);return i<0&&(i+=4294967296),i}function X(e,t){var i=u(e,t,14)^u(e,t,18)^u(t,e,9);return i<0&&(i+=4294967296),i}function H(e,t){var i=o(e,t,1)^o(e,t,8)^b(e,t,7);return i<0&&(i+=4294967296),i}function K(e,t){var i=u(e,t,1)^u(e,t,8)^l(e,t,7);return i<0&&(i+=4294967296),i}function V(e,t){var i=o(e,t,19)^o(t,e,29)^b(e,t,6);return i<0&&(i+=4294967296),i}function W(e,t){var i=u(e,t,19)^u(t,e,29)^l(e,t,6);return i<0&&(i+=4294967296),i}f.inherits(I,S),i.sha256=I,I.blockSize=512,I.outSize=256,I.hmacStrength=192,I.padLength=64,I.prototype._update=function(e,t){for(var i,r=this.W,f=0;f<16;f++)r[f]=e[t+f];for(;f<r.length;f++)r[f]=s((i=r[f-2],n(i,17)^n(i,19)^i>>>10),r[f-7],B(r[f-15]),r[f-16]);var a=this.h[0],o=this.h[1],u=this.h[2],b=this.h[3],l=this.h[4],p=this.h[5],m=this.h[6],v=this.h[7];d(this.k.length===r.length);for(f=0;f<r.length;f++){var g=h(v,E(l),P(l,p,m),this.k[f],r[f]),y=c(N(a),j(a,o,u));v=m,m=p,p=l,l=c(b,g),b=u,u=o,o=a,a=c(g,y)}this.h[0]=c(this.h[0],a),this.h[1]=c(this.h[1],o),this.h[2]=c(this.h[2],u),this.h[3]=c(this.h[3],b),this.h[4]=c(this.h[4],l),this.h[5]=c(this.h[5],p),this.h[6]=c(this.h[6],m),this.h[7]=c(this.h[7],v)},I.prototype._digest=function(e){return"hex"===e?f.toHex32(this.h,"big"):f.split32(this.h,"big")},f.inherits(z,I),i.sha224=z,z.blockSize=512,z.outSize=224,z.hmacStrength=192,z.padLength=64,z.prototype._digest=function(e){return"hex"===e?f.toHex32(this.h.slice(0,7),"big"):f.split32(this.h.slice(0,7),"big")},f.inherits(q,S),i.sha512=q,q.blockSize=1024,q.outSize=512,q.hmacStrength=192,q.padLength=128,q.prototype._prepareBlock=function(e,t){for(var i=this.W,r=0;r<32;r++)i[r]=e[t+r];for(;r<i.length;r+=2){var f=V(i[r-4],i[r-3]),d=W(i[r-4],i[r-3]),n=i[r-14],a=i[r-13],c=H(i[r-30],i[r-29]),s=K(i[r-30],i[r-29]),h=i[r-32],o=i[r-31];i[r]=g(f,d,n,a,c,s,h,o),i[r+1]=y(f,d,n,a,c,s,h,o)}},q.prototype._update=function(e,t){this._prepareBlock(e,t);var i=this.W,r=this.h[0],f=this.h[1],n=this.h[2],a=this.h[3],c=this.h[4],s=this.h[5],h=this.h[6],o=this.h[7],u=this.h[8],b=this.h[9],l=this.h[10],g=this.h[11],y=this.h[12],S=this.h[13],_=this.h[14],A=this.h[15];d(this.k.length===i.length);for(var x=0;x<i.length;x+=2){var I=_,z=A,q=J(u,b),R=X(u,b),k=O(u,b,l,g,y,S),P=F(u,b,l,g,y,S),j=this.k[x],N=this.k[x+1],E=i[x],B=i[x+1],L=M(I,z,q,R,k,P,j,N,E,B),H=w(I,z,q,R,k,P,j,N,E,B),K=(I=Z(r,f),z=D(r,f),q=T(r,f,n,a,c,s),R=C(r,f,n,a,c,s),m(I,z,q,R)),V=v(I,z,q,R);_=y,A=S,y=l,S=g,l=u,g=b,u=m(h,o,L,H),b=v(o,o,L,H),h=c,o=s,c=n,s=a,n=r,a=f,r=m(L,H,K,V),f=v(L,H,K,V)}p(this.h,0,r,f),p(this.h,2,n,a),p(this.h,4,c,s),p(this.h,6,h,o),p(this.h,8,u,b),p(this.h,10,l,g),p(this.h,12,y,S),p(this.h,14,_,A)},q.prototype._digest=function(e){return"hex"===e?f.toHex32(this.h,"big"):f.split32(this.h,"big")},f.inherits(R,q),i.sha384=R,R.blockSize=1024,R.outSize=384,R.hmacStrength=192,R.padLength=128,R.prototype._digest=function(e){return"hex"===e?f.toHex32(this.h.slice(0,12),"big"):f.split32(this.h.slice(0,12),"big")},f.inherits(k,S),i.sha1=k,k.blockSize=512,k.outSize=160,k.hmacStrength=80,k.padLength=64,k.prototype._update=function(e,t){for(var i=this.W,r=0;r<16;r++)i[r]=e[t+r];for(;r<i.length;r++)i[r]=a(i[r-3]^i[r-8]^i[r-14]^i[r-16],1);var f=this.h[0],d=this.h[1],n=this.h[2],s=this.h[3],o=this.h[4];for(r=0;r<i.length;r++){var u=~~(r/20),b=h(a(f,5),L(u,d,n,s),o,i[r],x[u]);o=s,s=n,n=a(d,30),d=f,f=b}this.h[0]=c(this.h[0],f),this.h[1]=c(this.h[1],d),this.h[2]=c(this.h[2],n),this.h[3]=c(this.h[3],s),this.h[4]=c(this.h[4],o)},k.prototype._digest=function(e){return"hex"===e?f.toHex32(this.h,"big"):f.split32(this.h,"big")}},{"../hash":19}],24:[function(e,t,i){var r=i,f=e("inherits");function d(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function n(e){return 1===e.length?"0"+e:e}function a(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}function c(e,t){if(!e)throw new Error(t||"Assertion failed")}r.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var i=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),r=0;r<e.length;r+=2)i.push(parseInt(e[r]+e[r+1],16))}else for(var r=0;r<e.length;r++){var f=e.charCodeAt(r),d=f>>8,n=255&f;d?i.push(d,n):i.push(n)}else for(r=0;r<e.length;r++)i[r]=0|e[r];return i},r.toHex=function(e){for(var t="",i=0;i<e.length;i++)t+=n(e[i].toString(16));return t},r.htonl=d,r.toHex32=function(e,t){for(var i="",r=0;r<e.length;r++){var f=e[r];"little"===t&&(f=d(f)),i+=a(f.toString(16))}return i},r.zero2=n,r.zero8=a,r.join32=function(e,t,i,r){var f=i-t;c(f%4==0);for(var d=new Array(f/4),n=0,a=t;n<d.length;n++,a+=4){var s;s="big"===r?e[a]<<24|e[a+1]<<16|e[a+2]<<8|e[a+3]:e[a+3]<<24|e[a+2]<<16|e[a+1]<<8|e[a],d[n]=s>>>0}return d},r.split32=function(e,t){for(var i=new Array(4*e.length),r=0,f=0;r<e.length;r++,f+=4){var d=e[r];"big"===t?(i[f]=d>>>24,i[f+1]=d>>>16&255,i[f+2]=d>>>8&255,i[f+3]=255&d):(i[f+3]=d>>>24,i[f+2]=d>>>16&255,i[f+1]=d>>>8&255,i[f]=255&d)}return i},r.rotr32=function(e,t){return e>>>t|e<<32-t},r.rotl32=function(e,t){return e<<t|e>>>32-t},r.sum32=function(e,t){return e+t>>>0},r.sum32_3=function(e,t,i){return e+t+i>>>0},r.sum32_4=function(e,t,i,r){return e+t+i+r>>>0},r.sum32_5=function(e,t,i,r,f){return e+t+i+r+f>>>0},r.assert=c,r.inherits=f,i.sum64=function(e,t,i,r){var f=e[t],d=r+e[t+1]>>>0,n=(d<r?1:0)+i+f;e[t]=n>>>0,e[t+1]=d},i.sum64_hi=function(e,t,i,r){return(t+r>>>0<t?1:0)+e+i>>>0},i.sum64_lo=function(e,t,i,r){return t+r>>>0},i.sum64_4_hi=function(e,t,i,r,f,d,n,a){var c=0,s=t;return c+=(s=s+r>>>0)<t?1:0,c+=(s=s+d>>>0)<d?1:0,e+i+f+n+(c+=(s=s+a>>>0)<a?1:0)>>>0},i.sum64_4_lo=function(e,t,i,r,f,d,n,a){return t+r+d+a>>>0},i.sum64_5_hi=function(e,t,i,r,f,d,n,a,c,s){var h=0,o=t;return h+=(o=o+r>>>0)<t?1:0,h+=(o=o+d>>>0)<d?1:0,h+=(o=o+a>>>0)<a?1:0,e+i+f+n+c+(h+=(o=o+s>>>0)<s?1:0)>>>0},i.sum64_5_lo=function(e,t,i,r,f,d,n,a,c,s){return t+r+d+a+s>>>0},i.rotr64_hi=function(e,t,i){return(t<<32-i|e>>>i)>>>0},i.rotr64_lo=function(e,t,i){return(e<<32-i|t>>>i)>>>0},i.shr64_hi=function(e,t,i){return e>>>i},i.shr64_lo=function(e,t,i){return(e<<32-i|t>>>i)>>>0}},{inherits:25}],25:[function(e,t,i){"function"==typeof Object.create?t.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(e,t){e.super_=t;var i=function(){};i.prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e}},{}],26:[function(e,t,i){t.exports={name:"elliptic",version:"6.3.2",description:"EC cryptography",main:"lib/elliptic.js",files:["lib"],scripts:{jscs:"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",jshint:"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",lint:"npm run jscs && npm run jshint",unit:"istanbul test _mocha --reporter=spec test/index.js",test:"npm run lint && npm run unit",version:"grunt dist && git add dist/"},repository:{type:"git",url:"git@github.com:indutny/elliptic"},keywords:["EC","Elliptic","curve","Cryptography"],author:"Fedor Indutny <fedor@indutny.com>",license:"MIT",bugs:{url:"https://github.com/indutny/elliptic/issues"},homepage:"https://github.com/indutny/elliptic",devDependencies:{brfs:"^1.4.3",coveralls:"^2.11.3",grunt:"^0.4.5","grunt-browserify":"^5.0.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2",istanbul:"^0.4.2",jscs:"^2.9.0",jshint:"^2.6.0",mocha:"^2.1.0"},dependencies:{"bn.js":"^4.4.0",brorand:"^1.0.1","hash.js":"^1.0.0",inherits:"^2.0.1"}}},{}]},{},[2])(2)});;
	window.parseCertificate = parseCertificate;
	window.createCertificate = createCertificate;
	window.verifyCertificate = verifyCertificate;
	window.parseCAbundle = parseCAbundle;
	window.handleFileBrowse = handleFileBrowse;
	window.handleTrustedCertsFile = handleTrustedCertsFile;
	window.handleInterCertsFile = handleInterCertsFile;
	window.handleCRLsFile = handleCRLsFile;
	window.handleCABundle = handleCABundle;
	window.handleHashAlgOnChange = handleHashAlgOnChange;
	window.handleSignAlgOnChange = handleSignAlgOnChange;
	window.handleCurveOnChange = handleCurveOnChange;
	function context(name, func) {}

}());
